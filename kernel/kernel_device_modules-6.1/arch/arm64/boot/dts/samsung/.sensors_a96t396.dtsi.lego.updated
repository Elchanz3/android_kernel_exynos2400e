#if 1

&pio {
	grip_i2c_sda: grip-i2c-sda {
		GPIO_CONFIG_PUD_DRV(AP,pio,184, FUNC_INPUT, PULL_UP, DRV_LV1);
	};
	grip_i2c_scl: grip-i2c-scl {
		GPIO_CONFIG_PUD_DRV(AP,pio,183, FUNC_INPUT, PULL_UP, DRV_LV1);
	};
};

&pio {
	grip_int: grip-int {
		GPIO_CONFIG_PUD_DRV(AP,pio,5, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
	};
};

&sw_i2c4 {
	gpios = <SEC_GPIO_REF(AP,pio,184) 0 /* sda */
			SEC_GPIO_REF(AP,pio,183) 0>; /* scl */
	pinctrl-0 = <&grip_i2c_sda
				 &grip_i2c_scl
				 >;
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	clock-frequency = <100000>;
	a96t396: a96t396@20 {
		compatible = "a96t396";
		reg = <0x20>;

		pinctrl-names = "default";
		pinctrl-0 = <&grip_int>;

		interrupt-parent = <SEC_GPIO_TYPE(AP,pio,5)>;
		interrupts = <SEC_GPIO_NUM(AP,pio,5) 0>;

		irq_gpio = <SEC_GPIO_REF(AP,pio,5) 0>;
#if 0
		dvdd_vreg_name = "VDD_GRIP_3P3";
#else
#if 1
		ldo_en = <SEC_GPIO_REF(AP,pio,208) 0>;
#endif
#endif
		multi_use = <1>;
#if 1
		unknown_ch_selection = <3>; /*bit "0 0" => no use , "0 1" => 1ch only, "1 0" => 2ch only, "1 1" 1ch 2ch both*/
#endif
#if 1
		fail_safe_concept = <0>;
#endif
		fw_path = "abov/a96t396_a13x_main.bin";
		firmup_cmd = <0x90>;
		checksum_msb = <0x0B>;
		checksum_lsb = <0x19>;
		set_reg = /bits/ 8 <
		0x00 0x05
0x01 0x4C
0x02 0x21
0x03 0x01
0x04 0x2F
0x05 0x34
0x06 0x18
0x07 0x20
0x08 0x2A
0x09 0x10
0x0A 0x28
0x0B 0x28
0x0C 0x44
0x0D 0x00
0x0E 0x33
0x0F 0x01
0x10 0x90
0x11 0x01
0x12 0x90
0x13 0x01
0x14 0x2C
0x15 0x01
0x16 0x2C
0x17 0x00
0x18 0xC8
0x19 0x00
0x1A 0xC8
0x1B 0x00
0x1C 0x00
0x1D 0x00
0x1E 0x00
0x1F 0x00
0x20 0x00
0x21 0x00
0x22 0x00
0x23 0x33
0x24 0x00
0x25 0x00
0x26 0x00
0x27 0x11
0x28 0x01
0x29 0x01
0x2A 0x14
0x2B 0x33
0x2C 0x00
0x2D 0x00
0x2E 0x00
0x2F 0x00
0x30 0x00
0x31 0x09
0x32 0x02
0x33 0x02
0x34 0x00
0x35 0x32
0x36 0x64
0x37 0x05
0x38 0x01
0x39 0x0E
0x3A 0x05
0x3B 0x1E
0x3C 0x32
0x3D 0x32
0x3E 0x00
0x3F 0x00
0x40 0x0A
0x41 0x04
0x42 0x04
0x43 0x20
0x44 0x20
0x45 0x34
0x46 0x33
0x47 0x28
0x48 0x28
0x49 0x19
0x4A 0x19
0x4B 0x05
0x4C 0x50
0x4D 0x07
0x4E 0x0A
0x4F 0x1E
0x50 0x1E
0x51 0x00
0x52 0x00
0x53 0x0F
0x54 0x1A
0x55 0x1A
0x56 0x0A
0x57 0x01
0x58 0x0A
0x59 0x0A
0x5A 0x23
0x5B 0x0A
0x5C 0x0A
0x5D 0x0A
0x5E 0x0A
0x5F 0x00
0x60 0x00
0x61 0x00
0x62 0x00
0x63 0x32
0x64 0x0A
0x65 0x14
0x66 0x21
0x67 0x0A
0x68 0x14
0x69 0x0A
0x6A 0x50
0x6B 0x02
0x6C 0x0A
0x6D 0x50
0x6E 0x14
0x6F 0x0A
0x70 0x32
0x71 0x04
0x72 0x00
0x73 0x00
0x74 0x00
0x75 0x10
0x76 0x00
0x77 0x00
0x78 0x00
0x79 0x00
0x7A 0x00
0x7B 0x00
0x7C 0x00
0x7D 0x00
		>;
	};
};
#endif

/* ---- SUB GRIP---- */
#if 1

&pio {
	grip_sub_i2c_sda: grip-sub-i2c-sda {
		GPIO_CONFIG_PUD_DRV(AP,pio,190, FUNC_INPUT, PULL_UP, DRV_LV1);
	};
	grip_sub_i2c_scl: grip-sub-i2c-scl {
		GPIO_CONFIG_PUD_DRV(AP,pio,189, FUNC_INPUT, PULL_UP, DRV_LV1);
	};
};

&pio {
	grip_sub_int: grip-sub-int {
		GPIO_CONFIG_PUD_DRV(AP,pio,6, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
	};
};

&sw_i2c2 {
	gpios = <SEC_GPIO_REF(AP,pio,190) 0 /* sda */
			SEC_GPIO_REF(AP,pio,189) 0>; /* scl */
	pinctrl-0 = <&grip_sub_i2c_sda
				 &grip_sub_i2c_scl
				>;
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	clock-frequency = <100000>;
	a96t396_sub: a96t396_sub@21 {

		compatible = "a96t396_sub";
		reg = <0x21>;

		pinctrl-names = "default";
		pinctrl-0 = <&grip_sub_int>;

		interrupt-parent = <SEC_GPIO_TYPE(AP,pio,6)>;
		interrupts = <SEC_GPIO_NUM(AP,pio,6) 0>;

		irq_gpio = <SEC_GPIO_REF(AP,pio,6) 0>;
#if 0
		dvdd_vreg_name = "VDD_GRIP_3P3";
#else
#if 1
		ldo_en = <SEC_GPIO_REF(AP,pio,207) 0>;
#else
		ldo_en = <SEC_GPIO_REF(AP,pio,208) 0>;
#endif
#endif
		multi_use = <1>;
#if 1
		unknown_ch_selection = <3>; /*bit "0 0" => no use , "0 1" => 1ch only, "1 0" => 2ch only, "1 1" 1ch 2ch both*/
#endif
#if 1
		fail_safe_concept = <0>;
#endif
		fw_path = "abov/a96t396_a13x_sub.bin";
		firmup_cmd = <0x90>;
		checksum_msb = <0x0B>;
		checksum_lsb = <0x1C>;
		set_reg = /bits/ 8 <
		0x00 0x05
0x01 0x4E
0x02 0x11
0x03 0x01
0x04 0x40
0x05 0x10
0x06 0x18
0x07 0x34
0x08 0x10
0x09 0x10
0x0A 0x26
0x0B 0x20
0x0C 0x34
0x0D 0x00
0x0E 0x34
0x0F 0x01
0x10 0x90
0x11 0x01
0x12 0x90
0x13 0x01
0x14 0x2C
0x15 0x01
0x16 0x2C
0x17 0x00
0x18 0xC8
0x19 0x00
0x1A 0xC8
0x1B 0x00
0x1C 0x00
0x1D 0x00
0x1E 0x00
0x1F 0x00
0x20 0x00
0x21 0x00
0x22 0x00
0x23 0x33
0x24 0x00
0x25 0x00
0x26 0x00
0x27 0x11
0x28 0x00
0x29 0x03
0x2A 0x1B
0x2B 0x44
0x2C 0x00
0x2D 0x00
0x2E 0x00
0x2F 0x00
0x30 0x00
0x31 0x09
0x32 0x02
0x33 0x02
0x34 0x00
0x35 0x32
0x36 0x64
0x37 0x05
0x38 0x01
0x39 0x0E
0x3A 0x05
0x3B 0x1E
0x3C 0x32
0x3D 0x32
0x3E 0x00
0x3F 0x00
0x40 0x0A
0x41 0x04
0x42 0x04
0x43 0x20
0x44 0x20
0x45 0x34
0x46 0x33
0x47 0x28
0x48 0x28
0x49 0x19
0x4A 0x19
0x4B 0x05
0x4C 0x50
0x4D 0x07
0x4E 0x0A
0x4F 0x1E
0x50 0x1E
0x51 0x00
0x52 0x00
0x53 0x0F
0x54 0x0D
0x55 0x1B
0x56 0x0A
0x57 0x01
0x58 0x0A
0x59 0x0A
0x5A 0x23
0x5B 0x0A
0x5C 0x0A
0x5D 0x0F
0x5E 0x0F
0x5F 0x00
0x60 0x00
0x61 0x00
0x62 0x00
0x63 0x32
0x64 0x0A
0x65 0x14
0x66 0x21
0x67 0x0A
0x68 0x14
0x69 0x0A
0x6A 0x50
0x6B 0x02
0x6C 0x0A
0x6D 0x50
0x6E 0x14
0x6F 0x0A
0x70 0x32
0x71 0x04
0x72 0x00
0x73 0x00
0x74 0x00
0x75 0x3C
0x76 0x00
0x77 0x00
0x78 0x00
0x79 0x00
0x7A 0x00
0x7B 0x00
0x7C 0x00
0x7D 0x00
		>;
	};
};
#endif

/* ---- SUB2 GRIP---- */
#if 1
&pio {
	grip_sub2_i2c_sda: grip-sub2-i2c-sda {
		GPIO_CONFIG_PUD_DRV(AP,pio,190, FUNC_INPUT, PULL_UP, DRV_LV1);
	};
	grip_sub2_i2c_scl: grip-sub2-i2c-scl {
		GPIO_CONFIG_PUD_DRV(AP,pio,189, FUNC_INPUT, PULL_UP, DRV_LV1);
	};
};

&pio {
	grip_sub2_int: grip-sub2-int {
		GPIO_CONFIG_PUD_DRV(AP,pio,194, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
	};
};

&sw_i2c2 {
	gpios = <SEC_GPIO_REF(AP,pio,190) 0 /* sda */
			SEC_GPIO_REF(AP,pio,189) 0>; /* scl */
	pinctrl-0 = <&grip_sub2_i2c_sda
				 &grip_sub2_i2c_scl
				>;
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	clock-frequency = <100000>;
	a96t396_sub2: a96t396_sub2@20 {

		compatible = "a96t396_sub2";
		reg = <0x20>;

		pinctrl-names = "default";
		pinctrl-0 = <&grip_sub2_int>;

		interrupt-parent = <SEC_GPIO_TYPE(AP,pio,194)>;
		interrupts = <SEC_GPIO_NUM(AP,pio,194) 0>;

		irq_gpio = <SEC_GPIO_REF(AP,pio,194) 0>;
#if 0
		dvdd_vreg_name = "VDD_GRIP_3P3";
#else
#if 1
		ldo_en = <SEC_GPIO_REF(AP,pio,207) 0>;
#else
		ldo_en = <SEC_GPIO_REF(AP,pio,208) 0>;
#endif
#endif
		multi_use = <1>;
#if 1
		unknown_ch_selection = <3>; /*bit "0 0" => no use , "0 1" => 1ch only, "1 0" => 2ch only, "1 1" 1ch 2ch both*/
#endif
#if 1
		fail_safe_concept = <0>;
#endif
		fw_path = "abov/a96t396_a13x_sub2.bin";
		firmup_cmd = <0x90>;
		checksum_msb = <0x0B>;
		checksum_lsb = <0x70>;
		set_reg = /bits/ 8 <
		0x00 0x05
0x01 0x4F
0x02 0x21
0x03 0x10
0x04 0x3C
0x05 0x3B
0x06 0x20
0x07 0x32
0x08 0x28
0x09 0x10
0x0A 0x3A
0x0B 0x24
0x0C 0x34
0x0D 0x00
0x0E 0x44
0x0F 0x01
0x10 0x90
0x11 0x01
0x12 0x90
0x13 0x01
0x14 0x2C
0x15 0x01
0x16 0x2C
0x17 0x00
0x18 0xC8
0x19 0x00
0x1A 0xC8
0x1B 0x00
0x1C 0x00
0x1D 0x00
0x1E 0x00
0x1F 0x00
0x20 0x00
0x21 0x00
0x22 0x00
0x23 0x00
0x24 0x00
0x25 0x00
0x26 0x00
0x27 0x12
0x28 0x00
0x29 0x1B
0x2A 0x05
0x2B 0x33
0x2C 0x00
0x2D 0x00
0x2E 0x00
0x2F 0x00
0x30 0x00
0x31 0x09
0x32 0x02
0x33 0x02
0x34 0x00
0x35 0x32
0x36 0x64
0x37 0x05
0x38 0x01
0x39 0x0E
0x3A 0x05
0x3B 0x1E
0x3C 0x32
0x3D 0x32
0x3E 0x00
0x3F 0x00
0x40 0x0A
0x41 0x04
0x42 0x04
0x43 0x20
0x44 0x20
0x45 0x34
0x46 0x33
0x47 0x28
0x48 0x28
0x49 0x19
0x4A 0x19
0x4B 0x05
0x4C 0x50
0x4D 0x07
0x4E 0x0A
0x4F 0x1E
0x50 0x1E
0x51 0x00
0x52 0x00
0x53 0x0F
0x54 0x28
0x55 0x12
0x56 0x0A
0x57 0x01
0x58 0x0A
0x59 0x0A
0x5A 0x23
0x5B 0x0A
0x5C 0x0A
0x5D 0x0F
0x5E 0x0F
0x5F 0x00
0x60 0x00
0x61 0x00
0x62 0x00
0x63 0x32
0x64 0x0A
0x65 0x14
0x66 0x21
0x67 0x0A
0x68 0x14
0x69 0x0A
0x6A 0x50
0x6B 0x02
0x6C 0x0A
0x6D 0x50
0x6E 0x14
0x6F 0x0A
0x70 0x32
0x71 0x04
0x72 0x00
0x73 0x00
0x74 0x00
0x75 0x32
0x76 0x00
0x77 0x00
0x78 0x00
0x79 0x00
0x7A 0x00
0x7B 0x00
0x7C 0x00
0x7D 0x00
		>;
	};
};
#endif

/* ---- WIFI GRIP---- */
#if 1

&pio {
	grip_wifi_i2c_sda: grip-wifi-i2c-sda {
		GPIO_CONFIG_PUD_DRV(AP,pio,186, FUNC_INPUT, PULL_UP, DRV_LV1);
	};
	grip_wifi_i2c_scl: grip-wifi-i2c-scl {
		GPIO_CONFIG_PUD_DRV(AP,pio,185, FUNC_INPUT, PULL_UP, DRV_LV1);
	};
};

&pio {
	grip_wifi_int: grip-wifi-int {
		GPIO_CONFIG_PUD_DRV(AP,pio,193, FUNC_INPUT_WAKEUP, PULL_NONE, DRV_LV1);
	};
};

&sw_i2c3 {
	gpios = <SEC_GPIO_REF(AP,pio,186) 0 /* sda */
			SEC_GPIO_REF(AP,pio,185) 0>; /* scl */
	pinctrl-0 = <&grip_wifi_i2c_sda
				 &grip_wifi_i2c_scl
				>;
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	clock-frequency = <100000>;
	a96t396_wifi: a96t396_wifi@20 {

		compatible = "a96t396_wifi";
		reg = <0x20>;

		pinctrl-names = "default";
		pinctrl-0 = <&grip_wifi_int>;

		interrupt-parent = <SEC_GPIO_TYPE(AP,pio,193)>;
		interrupts = <SEC_GPIO_NUM(AP,pio,193) 0>;

		irq_gpio = <SEC_GPIO_REF(AP,pio,193) 0>;
#if 0
		dvdd_vreg_name = "VDD_GRIP_3P3";
#else
#if 1
		ldo_en = <SEC_GPIO_REF(AP,pio,209) 0>;
#else
		ldo_en = <SEC_GPIO_REF(AP,pio,208) 0>;
#endif
#endif
		multi_use = <1>;
#if 1
		unknown_ch_selection = <3>; /*bit "0 0" => no use , "0 1" => 1ch only, "1 0" => 2ch only, "1 1" 1ch 2ch both*/
#endif
#if 1
		fail_safe_concept = <0>;
#endif
		fw_path = "abov/a96t396_a13x_wifi.bin";
		firmup_cmd = <0x90>;
		checksum_msb = <0x0B>;
		checksum_lsb = <0x11>;
		set_reg = /bits/ 8 <
		0x00 0x05
0x01 0x4D
0x02 0x11
0x03 0x01
0x04 0x2F
0x05 0x10
0x06 0x18
0x07 0x24
0x08 0x10
0x09 0x10
0x0A 0x20
0x0B 0x10
0x0C 0x34
0x0D 0x00
0x0E 0x34
0x0F 0x01
0x10 0x90
0x11 0x01
0x12 0x90
0x13 0x01
0x14 0x2C
0x15 0x01
0x16 0x2C
0x17 0x00
0x18 0xC8
0x19 0x00
0x1A 0xC8
0x1B 0x00
0x1C 0x00
0x1D 0x00
0x1E 0x00
0x1F 0x00
0x20 0x00
0x21 0x00
0x22 0x00
0x23 0x33
0x24 0x00
0x25 0x00
0x26 0x00
0x27 0x11
0x28 0x00
0x29 0x28
0x2A 0x10
0x2B 0x34
0x2C 0x00
0x2D 0x00
0x2E 0x00
0x2F 0x00
0x30 0x00
0x31 0x09
0x32 0x02
0x33 0x02
0x34 0x00
0x35 0x32
0x36 0x64
0x37 0x05
0x38 0x01
0x39 0x0E
0x3A 0x05
0x3B 0x1E
0x3C 0x32
0x3D 0x32
0x3E 0x00
0x3F 0x00
0x40 0x0A
0x41 0x04
0x42 0x04
0x43 0x20
0x44 0x20
0x45 0x34
0x46 0x33
0x47 0x28
0x48 0x28
0x49 0x19
0x4A 0x19
0x4B 0x05
0x4C 0x50
0x4D 0x07
0x4E 0x0A
0x4F 0x1E
0x50 0x1E
0x51 0x00
0x52 0x00
0x53 0x0F
0x54 0x41
0x55 0x40
0x56 0x0A
0x57 0x01
0x58 0x0A
0x59 0x0A
0x5A 0x23
0x5B 0x0A
0x5C 0x0A
0x5D 0x0A
0x5E 0x0A
0x5F 0x00
0x60 0x00
0x61 0x00
0x62 0x00
0x63 0x32
0x64 0x0A
0x65 0x14
0x66 0x21
0x67 0x0A
0x68 0x14
0x69 0x0A
0x6A 0x50
0x6B 0x02
0x6C 0x0A
0x6D 0x50
0x6E 0x14
0x6F 0x0A
0x70 0x32
0x71 0x04
0x72 0x00
0x73 0x00
0x74 0x00
0x75 0x10
0x76 0x00
0x77 0x00
0x78 0x00
0x79 0x00
0x7A 0x00
0x7B 0x00
0x7C 0x00
0x7D 0x00
		>;
	};
};
#endif
/* /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/kmodule/sensors/a96t396/dts/a96t396_hwparam.gts10p.dtsi */
#if 1
&grip_i2c_sda {
	pins_cmd_dat {
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,184), 1)>;
		bias-disable;
	};
};
&grip_i2c_scl {
	pins_cmd_dat {
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,183), 1)>;
		bias-disable;
	};
};

&a96t396 {
	fw_path = "abov/a96t396_gts10p_main.bin";
};
#endif

#if 1
&grip_sub_i2c_sda {
	pins_cmd_dat {
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,190), 1)>;
		bias-disable;
	};
};
&grip_sub_i2c_scl {
	pins_cmd_dat {
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,189), 1)>;
		bias-disable;
	};
};

&a96t396_sub {
	fw_path = "abov/a96t396_gts10p_sub.bin";
};
#endif

#if 1
&grip_sub2_i2c_sda {
	pins_cmd_dat {
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,190), 1)>;
		bias-disable;
	};
};
&grip_sub2_i2c_scl {
	pins_cmd_dat {
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,189), 1)>;
		bias-disable;
	};
};

&a96t396_sub2 {
	fw_path = "abov/a96t396_gts10p_sub2.bin";
};
#endif

#if 1
&grip_wifi_i2c_sda {
	pins_cmd_dat {
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,186), 1)>;
		bias-disable;
	};
};
&grip_wifi_i2c_scl {
	pins_cmd_dat {
		pinmux = <MTK_PINMUX(SEC_GPIO_NUM(AP,pio,185), 1)>;
		bias-disable;
	};
};
&a96t396_wifi {
	fw_path = "abov/a96t396_gts10p_wifi.bin";
};
#endif
