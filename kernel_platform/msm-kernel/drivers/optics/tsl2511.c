/*
 * Copyright (C) 2018 Samsung Electronics Co., Ltd. All rights reserved.
 *
 * This software is licensed under the terms of the GNU General Public
 * License, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#define VENDOR				"AMS"

#define TSL2511_CHIP_NAME	"TSL2511"

#define VERSION				"2"
#define SUB_VERSION			"0"
#define VENDOR_VERSION		"a"

#define MODULE_NAME_ALS		"als_rear"

#define TSL2511_SLAVE_I2C_ADDR_REVID_V0 0x29

#define AMSDRIVER_I2C_RETRY_DELAY	10
#define AMSDRIVER_I2C_MAX_RETRIES	5

/* AWB/Flicker Definition */
#define FLICKER_SENSOR_ERR_ID_SATURATION  -3

#define ALS_AUTOGAIN
#define BYTE				2
#define AWB_INTERVAL		20 /* 20 sample(from 17 to 28) */

#define FLICKER_FIFO_THR	16
#define FLICKER_DATA_CNT	200
#define FLICKER_FIFO_READ	-2

#define TSL2511_IOCTL_MAGIC		0xFD
#define TSL2511_IOCTL_READ_FLICKER	_IOR(TSL2511_IOCTL_MAGIC, 0x01, uint16_t *)

#include "tsl2511.h"
#include <linux/kfifo.h>

#if IS_ENABLED(CONFIG_SENSORS_FLICKER_SELF_TEST)
#include "flicker_test.h"

#define EOL_GAIN                1000

#define FREQ_SPEC_MARGIN        10
#define FREQ100_SPEC_IN(X)      (((X > (100 - FREQ_SPEC_MARGIN)) && (X < (100 + FREQ_SPEC_MARGIN)))?"PASS":"FAIL")
#define FREQ120_SPEC_IN(X)      (((X > (120 - FREQ_SPEC_MARGIN)) && (X < (120 + FREQ_SPEC_MARGIN)))?"PASS":"FAIL")

#define WIDE_CLEAR_SPEC_MIN     0
#define WIDE_CLEAR_SPEC_MAX     50000000
#define WIDE_SPEC_IN(X)         ((X >= WIDE_CLEAR_SPEC_MIN && X <= WIDE_CLEAR_SPEC_MAX)?"PASS":"FAIL")
#define CLEAR_SPEC_IN(X)        ((X >= WIDE_CLEAR_SPEC_MIN && X <= WIDE_CLEAR_SPEC_MAX)?"PASS":"FAIL")
#define UV_SPEC_IN(X)           ((X >= WIDE_CLEAR_SPEC_MIN && X <= WIDE_CLEAR_SPEC_MAX)?"PASS":"FAIL")
#define ICRATIO_SPEC_IN(X)      "PASS"
#endif

static int als_debug = 1;
static int als_info = 0;
static u16 sample_time_reg;
static u16 real_sample_freq;

static DECLARE_KFIFO(ams_fifo, u8, 4 * PAGE_SIZE);

module_param(als_debug, int, S_IRUGO | S_IWUSR);
module_param(als_info, int, S_IRUGO | S_IWUSR);

static struct tsl2511_device_data *tsl2511_data;

#define AMS_ROUND_SHFT_VAL			4
#define AMS_ROUND_ADD_VAL			(1 << (AMS_ROUND_SHFT_VAL - 1))
#define AMS_ALS_GAIN_FACTOR			1000
#define CPU_FRIENDLY_FACTOR_1024		1
#define AMS_ALS_Cc				(118 * CPU_FRIENDLY_FACTOR_1024)
#define AMS_ALS_Rc				(112 * CPU_FRIENDLY_FACTOR_1024)
#define AMS_ALS_Gc				(172 * CPU_FRIENDLY_FACTOR_1024)
#define AMS_ALS_Bc				(180 * CPU_FRIENDLY_FACTOR_1024)
#define AMS_ALS_Wbc				(111 * CPU_FRIENDLY_FACTOR_1024)

#define AMS_ALS_FACTOR				1000

#define AMS_ALS_TIMEBASE			(2780) /* in uSec, see data sheet */
#define AMS_ALS_ADC_MAX_COUNT			(1024) /* see data sheet */
#define AMS_ALS_THRESHOLD_LOW			(5) /* in % */
#define AMS_ALS_THRESHOLD_HIGH			(5) /* in % */

#define AMS_ALS_ATIME				(50000)

#define AMS_AGC_MAX_GAIN                        (4096 * 1000)

#define AMS_AGC_NUM_SAMPLES                     (20)
#define STEP_SAMPLES (31)


#define WIDEBAND_CONST    (1.6)
#define CLEAR_CONST       (2)

static int ams_getWord(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint16_t *readData);
static int ams_setWord(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint16_t setData);


/* REENABLE only enables those that were on record as being enabled */
#define AMS_REENABLE(ret)				{ret = ams_setByte(ctx->portHndl, DEVREG_ENABLE, ctx->shadowEnableReg); }
/* DISABLE_ALS disables ALS w/o recording that as its new state */
#define AMS_DISABLE_ALS(ret)			{ret = ams_setField(ctx->portHndl, DEVREG_ENABLE, LOW, (MASK_AEN)); }
#define AMS_REENABLE_ALS(ret)			{ret = ams_setField(ctx->portHndl, DEVREG_ENABLE, HIGH, (MASK_AEN)); }

#define AMS_DISABLE_FD(ret)			{ret = ams_setField(ctx->portHndl, DEVREG_ENABLE, LOW, (MASK_FDEN)); }
#define AMS_REENABLE_FD(ret)			{ret = ams_setField(ctx->portHndl, DEVREG_ENABLE, HIGH, (MASK_FDEN)); }
#define AMS_REENABLE_FD_PON(ret)	{ret = ams_setField(ctx->portHndl, DEVREG_ENABLE, HIGH, (MASK_FDEN | PON)); }

#define AMS_ENABLE_PON(ret)			{ret = ams_setByte(ctx->portHndl, DEVREG_ENABLE, PON); }
#define AMS_DISABLE_FDINT(ret)			{ret = ams_setField(ctx->portHndl, DEVREG_INTENAB, LOW, MASK_FIEN); }
#define AMS_REENABLE_FDINT(ret)			{ret = ams_setField(ctx->portHndl, DEVREG_INTENAB, HIGH, MASK_FIEN); }

#define AMS_SET_SAMPLE_TIME(uSec, ret); {ret = ams_setByte(ctx->portHndl, DEVREG_SAMPLE_TIME0,   (uint8_t)((uint16_t)uSec & 0x00FF));\
					ret = ams_setByte(ctx->portHndl, DEVREG_SAMPLE_TIME1,   (uint8_t)(((uint16_t)uSec & 0x0700) >> 8));}

#define AMS_SET_ALS_TIME(num_samples, ret)		{ret = ams_setByte(ctx->portHndl, DEVREG_ALS_NR_SAMPLES0, (uint8_t)((uint16_t)num_samples & 0x00FF));\
						ret = ams_setByte(ctx->portHndl, DEVREG_ALS_NR_SAMPLES1, (uint8_t)(((uint16_t)num_samples & 0x0700) >> 8)); }

// Flicker Measurement time = SAMPLE_TIME * FLICKER_NUM_SAMPLES
#define AMS_SET_FLICKER_NUM_SAMPLES(Num, ret)		{ret = ams_setByte(ctx->portHndl, DEVREG_FD_NR_SAMPLES0,   (uint8_t)((uint16_t)(Num-1) & 0x00FF));\
							ret = ams_setField(ctx->portHndl, DEVREG_FD_NR_SAMPLES1,   (uint8_t)(((uint16_t)(Num-1) & 0x0700) >> 8), 0x07);}

//#define AMS_GET_ALS_TIME(uSec, ret)		{ret = ams_getByte(ctx->portHndl, DEVREG_ATIME,   alsTimeUsToReg(uSec)); }

#define AMS_GET_ALS_GAIN(scaledGain, scaledGain1, gain, ret)	{ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS2, &(gain)); \
								scaledGain = alsGain_conversion[(gain) & 0x0F]; \
								scaledGain1 = alsGain_conversion[(((gain) & 0xF0)>> 4)]; }

//#define AMS_SET_ALS_STEP_TIME(uSec, ret)		{ret = ams_setWord(ctx->portHndl, DEVREG_ASTEPL, alsTimeUsToReg(uSec * 1000)); }

#define AMS_SET_STEP0_ALS_GAIN0(mGain, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, alsGainToReg(mGain), MASK_AGAIN0); }
#define AMS_SET_STEP0_ALS_GAIN1(mGain, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, (((alsGainToReg(mGain))<<4) & 0xF0), MASK_AGAIN1); }
#define AMS_SET_STEP0_ALS_GAIN2(mGain, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_H, alsGainToReg(mGain), MASK_AGAIN0); }

#define AMS_SET_STEP1_ALS_GAIN0(mGain, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L, alsGainToReg(mGain), MASK_AGAIN0); }
#define AMS_SET_STEP1_ALS_GAIN1(mGain, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L, (((alsGainToReg(mGain))<<4) & 0xF0), MASK_AGAIN1); }
#define AMS_SET_STEP1_ALS_GAIN2(mGain, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_H, alsGainToReg(mGain), MASK_AGAIN0); }

#define AMS_SET_ALS_PERS(persCode, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_CFG5, (persCode), MASK_APERS); }

#define AMS_SET_ALS_AINT_DIRECT(x, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_CFG2, x, MASK_AINT_DIRECT); }

#define AMS_SET_ALS_THRS_LOW(x, ret)	{ret = ams_setByte(ctx->portHndl, DEVREG_AILT0, (uint8_t)(((0x000000ff)&(x))>>0) );\
					ret = ams_setByte(ctx->portHndl, DEVREG_AILT1, (uint8_t)(((0x0000ff00)&(x))>>8));\
					ret = ams_setByte(ctx->portHndl, DEVREG_AILT2, (uint8_t)(((0x00ff0000)&(x))>>16));}

#define AMS_SET_ALS_THRS_HIGH(x, ret)	{ret = ams_setByte(ctx->portHndl, DEVREG_AIHT0, (uint8_t)(((0x000000ff)&(x))>>0) );\
					ret = ams_setByte(ctx->portHndl, DEVREG_AIHT1, (uint8_t)(((0x0000ff00)&(x))>>8));\
					ret = ams_setByte(ctx->portHndl, DEVREG_AIHT2, (uint8_t)(((0x00ff0000)&(x))>>16));}

/* Get CRGB and whatever Wideband it may have */
#define AMS_ALS_GET_ALS_DATA(x, ret)		{ret = ams_getBuf(ctx->portHndl, DEVREG_ALS_DATAL0, (uint8_t *) (x), 4); }
#define AMS_AGC_ASAT_MODE(x,ret)     {ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_AGC_ASAT_PATTERN, x, (MASK_AGC_ASAT)); }
#define AMS_AGC_PREDICT_MODE(x,ret)  {ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_AGC_PREDICT_PATTERN, x, (MASK_AGC_PREDICT)); }
#define AMS_AGC_AZ_MODE(value, ret)  {ret = ams_setField(ctx->portHndl, DEVREG_MOD_CALIB_CFG2, value, (MASK_MOD_CALIB_NTH_ITERATION_RC_ENABLE | MASK_MOD_CALIB_NTH_ITERATION_AZ_ENABLE | MASK_MOD_CALIB_NTH_ITERATION_AGC_ENABLE | MASK_MOD_CALIB_RESIDUAL_ENABLE_AUTO_CALIB_ON_GAIN_CHANGE)); }

//#define AMS_AGC_AZ_DISABLE(ret)	{ret = ams_setField(ctx->portHndl, DEVREG_MOD_CALIB_CFG2,   LOW, (MASK_MOD_CALIB_NTH_ITERATION_AGC_ENABLE));}


// SET AGC MAX GAIN
#define AMS_SET_AGC_MAX_GAIN(mGain, ret)	{ret = ams_setField(ctx->portHndl, DEVREG_CFG8, (((alsGainToReg(mGain))<<4) & 0xF0), MASK_MAX_MOD_GAIN);}

// AGC Number of sample
#define AMS_SET_AGC_NR_SAMPLES(Num, ret)		{ret = ams_setByte(ctx->portHndl, DEVREG_AGC_NR_SAMPLES_LO,   ((0xFF) & ((Num - 1)>>0)));\
							ret = ams_setByte(ctx->portHndl, DEVREG_AGC_NR_SAMPLES_HI,   ((0xFF) & ((Num - 1)>>8)));}

#define AMS_FIFO_CLEAR(ret)            {ret = ams_setField(ctx->portHndl, DEVREG_CONTROL, HIGH, MASK_FIFO_CLR);} //FIFO Buffer , FINT, FIFO_OV, FIFO_LVL all clear


// AGC Number of sample  0 ~ 511
#define AMS_SET_FIFO_THR(Num, ret)		{ret = ams_setByte(ctx->portHndl, DEVREG_FIFO_THR,   ((0x01FF & Num)>>1) & (0xFF));\
						ret = ams_setByte(ctx->portHndl, DEVREG_CFG2,   ((0x0001 & Num) & 0xFF));}


// MEAS_SEQR_RESIDUAL_0,//0xD2
#define AMS_RESIDUAL_MODE(x,ret)  {ret = ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_RESIDUAL_0, x, 0xFF); }


// Enable writing of FD_GAIN to FIFO after each complete flicker measurment
#define AMS_FD_GAIN_TO_FIFO(ret)  {ret = ams_setField(ctx->portHndl, DEVREG_MEAS_MODE1, HIGH, MASK_MOD_FIFO_FD_GAIN_WRITE_ENABLE); }

// Enable writing of FD_END_MARKER to FIFO after each complete flicker measurment
#define AMS_FD_END_MARKER_TO_FIFO(ret)  {ret = ams_setField(ctx->portHndl, DEVREG_MEAS_MODE1, HIGH, MASK_MOD_FIFO_FD_END_MARKER_WRITE_ENABLE); }


//MASK_MOD_DIVIDER_SELECT 0 , 6 clock half of freq
//#define AMS_MOD_FREQ_HALF_FREQ(ret)  {ret = ams_setByte(ctx->portHndl, DEVREG_CFG7, 0x00 ); }
//MASK_MOD_DIVIDER_SELECT 1 , 12 clock default
//#define AMS_MOD_FREQ_FULL_FREQ(ret)  {ret = ams_setByte(ctx->portHndl, DEVREG_CFG7, 0x01); }

#define TSL2511_MEASUREMENT_SEQUENCER_MOD0_FD_PATTERN_SHIFT 0
#define TSL2511_MASK_MEASUREMENT_SEQUENCER_MOD0_FD_PATTERN (0x0F << TSL2511_MEASUREMENT_SEQUENCER_MOD0_FD_PATTERN_SHIFT)

#define TSL2511_MEASUREMENT_SEQUENCER_MOD1_FD_PATTERN_SHIFT 4
#define TSL2511_MASK_MEASUREMENT_SEQUENCER_MOD1_FD_PATTERN (0x0F << TSL2511_MEASUREMENT_SEQUENCER_MOD1_FD_PATTERN_SHIFT)

#define TSL2511_MEASUREMENT_SEQUENCER_MOD2_FD_PATTERN_SHIFT 4
#define TSL2511_MASK_MEASUREMENT_SEQUENCER_MOD2_FD_PATTERN (0x0F << TSL2511_MEASUREMENT_SEQUENCER_MOD2_FD_PATTERN_SHIFT)

#define TSL2511_MEASUREMENT_SEQUENCER_ALS_PATTERN_SHIFT 0
#define TSL2511_MASK_MEASUREMENT_SEQUENCER_ALS_PATTERN (0x0F << TSL2511_MEASUREMENT_SEQUENCER_ALS_PATTERN_SHIFT)

#define TSL2511_MOD_FIFO_FD_GAIN_WRITE_ENABLE_SHIFT 5
#define TSL2511_MASK_MOD_FIFO_FD_GAIN_WRITE_ENABLE (0x01 << TSL2511_MOD_FIFO_FD_GAIN_WRITE_ENABLE_SHIFT)

#define TSL2511_MOD_FIFO_FD_END_MARKER_WRITE_ENABLE_SHIFT 7
#define TSL2511_MASK_MOD_FIFO_FD_END_MARKER_WRITE_ENABLE (0x01 << TSL2511_MOD_FIFO_FD_END_MARKER_WRITE_ENABLE_SHIFT)
#define TSL2511_REG_CFG7__mod_divider_select__WIDTH  2
#define TSL2511_REG_CFG7__mod_divider_select__SHIFT  0
#define TSL2511_REG_CFG7__mod_divider_select__MASK   0x3

#define TSL2511_REG_STATUS3__vsync_lost__SHIFT      0x3
#define TSL2511_REG_STATUS3__vsync_lost__MASK       (1 << TSL2511_REG_STATUS3__vsync_lost__SHIFT)
#define TSL2511_REG_STATUS5__sint_vsync__MASK       0x1

/* DEVREG_VSYNC_CFG   0xF7  bits definition */
#define TSL2511_REG_VSYNC_CFG__osc_calib_mode__WIDTH 2
#define TSL2511_REG_VSYNC_CFG__osc_calib_mode__SHIFT 6
#define TSL2511_REG_VSYNC_CFG__osc_calib_mode__RESET 0
#define TSL2511_REG_VSYNC_CFG__osc_calib_mode__MASK  3
#define TSL2511_REG_VSYNC_CFG__extclk_as_sysclk__WIDTH 1
#define TSL2511_REG_VSYNC_CFG__extclk_as_sysclk__SHIFT 5
#define TSL2511_REG_VSYNC_CFG__extclk_as_sysclk__RESET 0
#define TSL2511_REG_VSYNC_CFG__extclk_as_sysclk__MASK  1
#define TSL2511_REG_VSYNC_CFG__osc_cal_setup__WIDTH 2
#define TSL2511_REG_VSYNC_CFG__osc_cal_setup__SHIFT 3
#define TSL2511_REG_VSYNC_CFG__osc_cal_setup__RESET 0
#define TSL2511_REG_VSYNC_CFG__osc_cal_setup__MASK  3
#define TSL2511_REG_VSYNC_CFG__vsync_mode__WIDTH 2
#define TSL2511_REG_VSYNC_CFG__vsync_mode__SHIFT 1
#define TSL2511_REG_VSYNC_CFG__vsync_mode__RESET 0
#define TSL2511_REG_VSYNC_CFG__vsync_mode__MASK 3
#define TSL2511_REG_VSYNC_CFG__vsync_invert__WIDTH 1
#define TSL2511_REG_VSYNC_CFG__vsync_invert__SHIFT 0
#define TSL2511_REG_VSYNC_CFG__vsync_invert__RESET 0
#define TSL2511_REG_VSYNC_CFG__vsync_invert__MASK  1

#define TSL2511_HW_SYNC_MODE    0
#define TSL2511_SW_SYNC_MODE    1
#define TSL2511_EXT_CLK_MODE    3
#define TSL2511_HW_SW_SYNC_CALIB_DISABLE    0
#define TSL2511_HW_SW_SYNC_CALIB_RUN_ONCE   1
#define TSL2511_HW_SW_SYNC_CALIB_RUN_ALWAYS 2
#define TSL2511_EXT_SYNC_CALIB_DISABLE      0
#define TSL2511_EXT_SYNC_CALIB_RUN_TWICE    1
#define TSL2511_EXT_SYNC_CALIB_RUN_ONCE     2
#define TSL2511_EXT_SYNC_CALIB_NO_AUTORUN   3

#define TSL2511_OSC_CAL_SETUP_0             0
#define TSL2511_OSC_CAL_SETUP_1             1
#define TSL2511_OSC_CAL_SETUP_2             2
#define TSL2511_OSC_CAL_SETUP_3             3


#define TSL2511_REG_IR_CALIB__ir_calib_valid__WIDTH  1
#define TSL2511_REG_IR_CALIB__ir_calib_valid__SHIFT  7
#define TSL2511_REG_IR_CALIB__ir_calib__WIDTH        7
#define TSL2511_REG_IR_CALIB__ir_calib__SHIFT        0

#define TSL2511_REG_UV_CALIB__uv_calib_valid__WIDTH  1
#define TSL2511_REG_UV_CALIB__uv_calib_valid__SHIFT  7
#define TSL2511_REG_UV_CALIB__uv_calib__WIDTH        7
#define TSL2511_REG_UV_CALIB__uv_calib__SHIFT        0


#define TSL2511_SIEN_VSYNC_SHIFT 0
#define TSL2511_MASK_SIEN_VSYNC (0x01 << TSL2511_SIEN_VSYNC_SHIFT)

#define TSL2511_SIEN_MEASUREMENT_SEQUENCER_SHIFT 1
#define TSL2511_MASK_SIEN_MEASUREMENT_SEQUENCER (0x01 << TSL2511_SIEN_MEASUREMENT_SEQUENCER_SHIFT)

#define TSL2511_REG_CFG4__sint_per_step__SHIFT          0x4
#define TSL2511_REG_CFG4__sint_per_step__MASK           (1 << TSL2511_REG_CFG4__sint_per_step__SHIFT)

#define TSL2511_REG_STATUS2__MOD0_ASAT__SHIFT           0
#define TSL2511_REG_STATUS2__MOD1_ASAT__SHIFT           1
#define TSL2511_REG_STATUS2__MOD2_ASAT__SHIFT           2
#define TSL2511_REG_STATUS2__MOD0_ASAT__MASK            (1 << TSL2511_REG_STATUS2__MOD0_ASAT__SHIFT)
#define TSL2511_REG_STATUS2__MOD1_ASAT__MASK            (1 << TSL2511_REG_STATUS2__MOD1_ASAT__SHIFT)
#define TSL2511_REG_STATUS2__MOD2_ASAT__MASK            (1 << TSL2511_REG_STATUS2__MOD2_ASAT__SHIFT)

typedef struct {
	uint8_t deviceId;
	uint8_t deviceIdMask;
	uint8_t deviceRef;
	uint8_t deviceRefMask;
	ams_deviceIdentifier_e device;
} ams_deviceIdentifier_t;

typedef struct _fifo {
	uint32_t AdcClear;
	uint32_t AdcWb;
	uint32_t AdcUv;
	uint32_t AdcBK;
} adcDataSet_t;

#define AMS_PORT_LOG_CRGB_W(dataset) \
	ALS_info("%s - C = %u, WB = %u\n", __func__ \
			, dataset.AdcClear \
			, dataset.AdcWb	\
			)

static ams_deviceIdentifier_t deviceIdentifier[] = {
	{ AMS_DEVICE_ID, AMS_DEVICE_ID_MASK, AMD_REV_ID_2511, AMS_REV_ID_MASK, AMS_TSL2511 },
	{ 0, 0, 0, 0, AMS_LAST_DEVICE }
};
#define coef_a 61 //  0.06061 * 1000 , scaled
#define coef_b 45 //  0.04537 * 1000 , scaled

deviceRegisterTable_t deviceRegisterDefinition[DEVREG_REG_MAX]={
	{0x04, 0x00},
	{0x05, 0x00},
	{0x07, 0x00},
	{0x40, 0x00},
	{0x7f, 0x00},
	{0x80, 0x00},
	{0x81, 0x04},
	{0x82, 0x0C},
	{0x83, 0xB3},
	{0x84, 0x00},
	{0x85, 0x00},
	{0x86, 0x00},
	{0x87, 0x00},
	{0x88, 0x00},
	{0x89, 0x00},
	{0x8A, 0x00},
	{0x8B, 0x00},
	{0x8C, 0x00},
	{0x8D, 0x00},
	{0x8E, 0x00},
	{0x8F, 0x00},
	{0x90, 0x00},
	{0x91, AMD_REV_ID_2511},
	{0x92, AMS_DEVICE_ID},
	{0x93, 0x00},
	{0x94, 0x00},
	{0x95, 0x00},
	{0x96, 0x00},
	{0x97, 0x00},
	{0x98, 0x00},
	{0x99, 0x00},
	{0x9A, 0x00},
	{0x9B, 0x00},
	{0x9C, 0x00},
	{0x9D, 0x00},
	{0x9E, 0x08},
	{0x9F, 0x00},
	{0xA0, 0x00},
	{0xA1, 0x08},
	{0xA2, 0x00},
	{0xA3, 0x01},
	{0xA4, 0x00},
	{0xA5, 0x00},
	{0xA6, 0x00},
	{0xA7, 0x03},
	{0xA8, 0x01},
	{0xA9, 0xC4},
	{0xAA, 0x00},
	{0xAC, 0x00},
	{0xAD, 0x00},
	{0xAE, 0x00},
	{0xB1, 0x00},
	{0xBA, 0x00},
	{0xBB, 0x00},
	{0xCE, 0x80},
	{0xCF, 0x01},
	{0xD0, 0x01},
	{0xD1, 0x01},
	{0xD2, 0xFF},
	{0xD3, 0x1F},
	{0xD4, 0x88},
	{0xD5, 0x08},
	{0xD6, 0x88},
	{0xD7, 0x08},
	{0xD8, 0x88},
	{0xDA, 0x08},
	{0xDC, 0xDB},
	{0xDE, 0xDB},
	{0xDF, 0xF0},
	{0xE0, 0x1B},
	{0xE1, 0xF0},
	{0xE2, 0x18},
	{0xE4, 0xFF},
	{0xE6, 0xD3},
	{0xEB, 0x00},
	{0xF0, 0x00},
	{0xF1, 0x00},
	{0xF2, 0x00},
	{0xF3, 0x00},
	{0xF4, 0x00},
	{0xF5, 0x00},
	{0xF6, 0x00},
	{0xF7, 0x00},
	{0xF8, 0x02},
	{0xF9, 0x8F},
	{0xFA, 0x8F},
	{0xFB, 0x8F},
	{0xFC, 0x7F},
	{0xFD, 0x00},
	{0xFE, 0x00},
	{0xFF, 0x00},
};

/* Gain x2 */
uint32_t alsGain_conversion[] = {
	500,
	1 * 1000,
	2 * 1000,
	4 * 1000,
	8 * 1000,
	16 * 1000,
	32 * 1000,
	64 * 1000,
	128 * 1000,
	256 * 1000,
	512 * 1000,
	1024 * 1000,
	2048 * 1000,
	4096 * 1000,
};

uint16_t tsl2511_gain_conversion[] = {
	1, /* == 0.5x */
	2,
	4,
	8,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048,
	4096,
	8192,
};

uint16_t fdGain_conversion[] = {
	1,
	2,
	4,
	8,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048,
	4096,
	8192,
};

uint32_t tsl2511_gain_predict[] = {
	1,      /* 0 */
	2,      /* 1 */
	4,      /* 2 */
	8,      /* 3 */
	16,     /* 4 */
	32,     /* 5 */
	64,     /* 6 */
	128,    /* 7 */
	256,    /* 8 */
	512,    /* 9 */
	1024,   /* 10 */
	2048,   /* 11 */
	4096    /* 12 */
};


#define MAX_FFT_LEN 2048
#define MODIFIER(x) (MAX_FFT_LEN/x)


// sec_hamming : 0~65535, Q16
static const int32_t hamming[2048] = {
	5243,  5243,  5243,  5244,  5245,  5246,  5248,  5250,  5252,  5254,  5257,  5260,  5263,  5267,  5271,  5275,  5279,  5284,  5289,  5294,  5300,  5305, 5312,  5318,  5325,  5332,  5339,  5346,  5354,  5362,  5370,  5379,  5388,  5397,  5407,  5417,  5427,  5437,  5448,  5458,  5470,  5481,  5493,  5505, 5517,  5530,  5543,  5556,  5569,  5583,  5597,  5611,  5626,  5641,  5656,  5671,  5687,  5703,  5719,  5735,  5752,  5769,  5787,  5804,  5822,  5840, 5859,  5878,  5897,  5916,  5935,  5955,  5975,  5996,  6016,  6037,  6059,  6080,  6102,  6124,  6146,  6169,  6192,  6215,  6238,  6262,  6286,  6310,
	6335,  6360,  6385,  6410,  6436,  6462,  6488,  6514,  6541,  6568,  6595,  6623,  6651,  6679,  6707,  6736,  6764,  6794,  6823,  6853,  6883,  6913, 6943,  6974,  7005,  7036,  7068,  7100,  7132,  7164,  7197,  7230,  7263,  7296,  7330,  7364,  7398,  7433,  7467,  7502,  7538,  7573,  7609,  7645, 7681,  7718,  7755,  7792,  7829,  7867,  7905,  7943,  7981,  8020,  8059,  8098,  8137,  8177,  8217,  8257,  8297,  8338,  8379,  8420,  8462,  8504, 8545,  8588,  8630,  8673,  8716,  8759,  8803,  8846,  8890,  8934,  8979,  9024,  9069,  9114,  9159,  9205,  9251,  9297,  9344,  9390,  9437,  9484,
	9532,  9580,  9627,  9676,  9724,  9773,  9822,  9871,  9920,  9970,  10019, 10070, 10120, 10170, 10221, 10272, 10323, 10375, 10427, 10479, 10531, 10583, 10636, 10689, 10742, 10795, 10849, 10903, 10957, 11011, 11066, 11121, 11175, 11231, 11286, 11342, 11398, 11454, 11510, 11567, 11624, 11681, 11738, 11795, 11853, 11911, 11969, 12027, 12086, 12145, 12204, 12263, 12322, 12382, 12442, 12502, 12562, 12623, 12683, 12744, 12806, 12867, 12929, 12990, 13052, 13115, 13177, 13240, 13302, 13365, 13429, 13492, 13556, 13620, 13684, 13748, 13813, 13877, 13942, 14007, 14073, 14138, 14204, 14270, 14336, 14402, 14469, 14535,
	14602, 14669, 14737, 14804, 14872, 14940, 15008, 15076, 15144, 15213, 15282, 15351, 15420, 15489, 15559, 15629, 15699, 15769, 15839, 15909, 15980, 16051, 16122, 16193, 16265, 16336, 16408, 16480, 16552, 16624, 16697, 16769, 16842, 16915, 16988, 17062, 17135, 17209, 17283, 17357, 17431, 17506, 17580, 17655, 17730, 17805, 17880, 17955, 18031, 18107, 18182, 18258, 18335, 18411, 18487, 18564, 18641, 18718, 18795, 18872, 18950, 19027, 19105, 19183, 19261, 19339, 19418, 19496, 19575, 19654, 19733, 19812, 19891, 19970, 20050, 20130, 20209, 20289, 20370, 20450, 20530, 20611, 20691, 20772, 20853, 20934, 21016, 21097,
	21178, 21260, 21342, 21424, 21506, 21588, 21670, 21753, 21835, 21918, 22001, 22084, 22167, 22250, 22333, 22417, 22500, 22584, 22668, 22751, 22836, 22920, 23004, 23088, 23173, 23257, 23342, 23427, 23512, 23597, 23682, 23767, 23853, 23938, 24024, 24110, 24196, 24281, 24367, 24454, 24540, 24626, 24713, 24799, 24886, 24973, 25059, 25146, 25233, 25320, 25408, 25495, 25582, 25670, 25758, 25845, 25933, 26021, 26109, 26197, 26285, 26373, 26462, 26550, 26638, 26727, 26816, 26904, 26993, 27082, 27171, 27260, 27349, 27438, 27527, 27617, 27706, 27796, 27885, 27975, 28064, 28154, 28244, 28334, 28424, 28514, 28604, 28694,
	28784, 28875, 28965, 29055, 29146, 29236, 29327, 29417, 29508, 29599, 29690, 29781, 29871, 29962, 30053, 30144, 30236, 30327, 30418, 30509, 30600, 30692, 30783, 30875, 30966, 31058, 31149, 31241, 31332, 31424, 31516, 31607, 31699, 31791, 31883, 31975, 32067, 32159, 32251, 32343, 32435, 32527, 32619, 32711, 32803, 32895, 32987, 33079, 33172, 33264, 33356, 33449, 33541, 33633, 33725, 33818, 33910, 34003, 34095, 34187, 34280, 34372, 34465, 34557, 34650, 34742, 34835, 34927, 35019, 35112, 35204, 35297, 35389, 35482, 35574, 35667, 35759, 35852, 35944, 36037, 36129, 36222, 36314, 36407, 36499, 36591, 36684, 36776,
	36869, 36961, 37053, 37146, 37238, 37330, 37423, 37515, 37607, 37699, 37792, 37884, 37976, 38068, 38160, 38252, 38344, 38436, 38528, 38620, 38712, 38804, 38896, 38988, 39080, 39171, 39263, 39355, 39447, 39538, 39630, 39721, 39813, 39904, 39996, 40087, 40178, 40270, 40361, 40452, 40543, 40634, 40726, 40817, 40907, 40998, 41089, 41180, 41271, 41361, 41452, 41543, 41633, 41724, 41814, 41904, 41995, 42085, 42175, 42265, 42355, 42445, 42535, 42625, 42714, 42804, 42894, 42983, 43073, 43162, 43251, 43341, 43430, 43519, 43608, 43697, 43786, 43875, 43963, 44052, 44141, 44229, 44317, 44406, 44494, 44582, 44670, 44758,
	44846, 44934, 45021, 45109, 45196, 45284, 45371, 45458, 45546, 45633, 45719, 45806, 45893, 45980, 46066, 46153, 46239, 46325, 46411, 46497, 46583, 46669, 46755, 46841, 46926, 47011, 47097, 47182, 47267, 47352, 47437, 47521, 47606, 47691, 47775, 47859, 47943, 48027, 48111, 48195, 48279, 48362, 48446, 48529, 48612, 48695, 48778, 48861, 48944, 49026, 49109, 49191, 49273, 49355, 49437, 49519, 49600, 49682, 49763, 49845, 49926, 50007, 50087, 50168, 50249, 50329, 50409, 50489, 50569, 50649, 50729, 50808, 50888, 50967, 51046, 51125, 51204, 51283, 51361, 51440, 51518, 51596, 51674, 51752, 51829, 51907, 51984, 52061,
	52138, 52215, 52291, 52368, 52444, 52520, 52597, 52672, 52748, 52824, 52899, 52974, 53049, 53124, 53199, 53273, 53348, 53422, 53496, 53570, 53644, 53717, 53790, 53864, 53937, 54009, 54082, 54155, 54227, 54299, 54371, 54443, 54514, 54586, 54657, 54728, 54799, 54869, 54940, 55010, 55080, 55150, 55220, 55290, 55359, 55428, 55497, 55566, 55635, 55703, 55771, 55839, 55907, 55975, 56042, 56110, 56177, 56244, 56310, 56377, 56443, 56509, 56575, 56641, 56706, 56772, 56837, 56902, 56966, 57031, 57095, 57159, 57223, 57287, 57350, 57413, 57476, 57539, 57602, 57664, 57727, 57789, 57850, 57912, 57973, 58034, 58095, 58156,
	58217, 58277, 58337, 58397, 58457, 58516, 58575, 58634, 58693, 58752, 58810, 58868, 58926, 58984, 59041, 59098, 59155, 59212, 59269, 59325, 59381, 59437, 59493, 59548, 59603, 59658, 59713, 59768, 59822, 59876, 59930, 59983, 60037, 60090, 60143, 60196, 60248, 60300, 60352, 60404, 60455, 60507, 60558, 60608, 60659, 60709, 60759, 60809, 60859, 60908, 60957, 61006, 61055, 61103, 61151, 61199, 61247, 61294, 61342, 61389, 61435, 61482, 61528, 61574, 61620, 61665, 61710, 61755, 61800, 61844, 61889, 61933, 61976, 62020, 62063, 62106, 62149, 62191, 62233, 62275, 62317, 62359, 62400, 62441, 62481, 62522, 62562, 62602,
	62642, 62681, 62720, 62759, 62798, 62836, 62874, 62912, 62950, 62987, 63024, 63061, 63098, 63134, 63170, 63206, 63241, 63276, 63311, 63346, 63381, 63415, 63449, 63483, 63516, 63549, 63582, 63615, 63647, 63679, 63711, 63742, 63774, 63805, 63836, 63866, 63896, 63926, 63956, 63985, 64014, 64043, 64072, 64100, 64128, 64156, 64184, 64211, 64238, 64265, 64291, 64317, 64343, 64369, 64394, 64419, 64444, 64469, 64493, 64517, 64540, 64564, 64587, 64610, 64633, 64655, 64677, 64699, 64720, 64741, 64762, 64783, 64804, 64824, 64843, 64863, 64882, 64901, 64920, 64939, 64957, 64975, 64992, 65010, 65027, 65043, 65060, 65076,
	65092, 65108, 65123, 65138, 65153, 65168, 65182, 65196, 65210, 65223, 65236, 65249, 65262, 65274, 65286, 65298, 65309, 65320, 65331, 65342, 65352, 65362, 65372, 65382, 65391, 65400, 65408, 65417, 65425, 65433, 65440, 65447, 65454, 65461, 65467, 65473, 65479, 65485, 65490, 65495, 65500, 65504, 65508, 65512, 65516, 65519, 65522, 65525, 65527, 65529, 65531, 65532, 65534, 65535, 65535, 65536, 65536, 65536, 65535, 65535, 65534, 65532, 65531, 65529, 65527, 65525, 65522, 65519, 65516, 65512, 65508, 65504, 65500, 65495, 65490, 65485, 65479, 65473, 65467, 65461, 65454, 65447, 65440, 65433, 65425, 65417, 65408, 65400,
	65391, 65382, 65372, 65362, 65352, 65342, 65331, 65320, 65309, 65298, 65286, 65274, 65262, 65249, 65236, 65223, 65210, 65196, 65182, 65168, 65153, 65138, 65123, 65108, 65092, 65076, 65060, 65043, 65027, 65010, 64992, 64975, 64957, 64939, 64920, 64901, 64882, 64863, 64843, 64824, 64804, 64783, 64762, 64741, 64720, 64699, 64677, 64655, 64633, 64610, 64587, 64564, 64540, 64517, 64493, 64469, 64444, 64419, 64394, 64369, 64343, 64317, 64291, 64265, 64238, 64211, 64184, 64156, 64128, 64100, 64072, 64043, 64014, 63985, 63956, 63926, 63896, 63866, 63836, 63805, 63774, 63742, 63711, 63679, 63647, 63615, 63582, 63549,
	63516, 63483, 63449, 63415, 63381, 63346, 63311, 63276, 63241, 63206, 63170, 63134, 63098, 63061, 63024, 62987, 62950, 62912, 62874, 62836, 62798, 62759, 62720, 62681, 62642, 62602, 62562, 62522, 62481, 62441, 62400, 62359, 62317, 62275, 62233, 62191, 62149, 62106, 62063, 62020, 61976, 61933, 61889, 61844, 61800, 61755, 61710, 61665, 61620, 61574, 61528, 61482, 61435, 61389, 61342, 61294, 61247, 61199, 61151, 61103, 61055, 61006, 60957, 60908, 60859, 60809, 60759, 60709, 60659, 60608, 60558, 60507, 60455, 60404, 60352, 60300, 60248, 60196, 60143, 60090, 60037, 59983, 59930, 59876, 59822, 59768, 59713, 59658,
	59603, 59548, 59493, 59437, 59381, 59325, 59269, 59212, 59155, 59098, 59041, 58984, 58926, 58868, 58810, 58752, 58693, 58634, 58575, 58516, 58457, 58397, 58337, 58277, 58217, 58156, 58095, 58034, 57973, 57912, 57850, 57789, 57727, 57664, 57602, 57539, 57476, 57413, 57350, 57287, 57223, 57159, 57095, 57031, 56966, 56902, 56837, 56772, 56706, 56641, 56575, 56509, 56443, 56377, 56310, 56244, 56177, 56110, 56042, 55975, 55907, 55839, 55771, 55703, 55635, 55566, 55497, 55428, 55359, 55290, 55220, 55150, 55080, 55010, 54940, 54869, 54799, 54728, 54657, 54586, 54514, 54443, 54371, 54299, 54227, 54155, 54082, 54009,
	53937, 53864, 53790, 53717, 53644, 53570, 53496, 53422, 53348, 53273, 53199, 53124, 53049, 52974, 52899, 52824, 52748, 52672, 52597, 52520, 52444, 52368, 52291, 52215, 52138, 52061, 51984, 51907, 51829, 51752, 51674, 51596, 51518, 51440, 51361, 51283, 51204, 51125, 51046, 50967, 50888, 50808, 50729, 50649, 50569, 50489, 50409, 50329, 50249, 50168, 50087, 50007, 49926, 49845, 49763, 49682, 49600, 49519, 49437, 49355, 49273, 49191, 49109, 49026, 48944, 48861, 48778, 48695, 48612, 48529, 48446, 48362, 48279, 48195, 48111, 48027, 47943, 47859, 47775, 47691, 47606, 47521, 47437, 47352, 47267, 47182, 47097, 47011,
	46926, 46841, 46755, 46669, 46583, 46497, 46411, 46325, 46239, 46153, 46066, 45980, 45893, 45806, 45719, 45633, 45546, 45458, 45371, 45284, 45196, 45109, 45021, 44934, 44846, 44758, 44670, 44582, 44494, 44406, 44317, 44229, 44141, 44052, 43963, 43875, 43786, 43697, 43608, 43519, 43430, 43341, 43251, 43162, 43073, 42983, 42894, 42804, 42714, 42625, 42535, 42445, 42355, 42265, 42175, 42085, 41995, 41904, 41814, 41724, 41633, 41543, 41452, 41361, 41271, 41180, 41089, 40998, 40907, 40817, 40726, 40634, 40543, 40452, 40361, 40270, 40178, 40087, 39996, 39904, 39813, 39721, 39630, 39538, 39447, 39355, 39263, 39171,
	39080, 38988, 38896, 38804, 38712, 38620, 38528, 38436, 38344, 38252, 38160, 38068, 37976, 37884, 37792, 37699, 37607, 37515, 37423, 37330, 37238, 37146, 37053, 36961, 36869, 36776, 36684, 36591, 36499, 36407, 36314, 36222, 36129, 36037, 35944, 35852, 35759, 35667, 35574, 35482, 35389, 35297, 35204, 35112, 35019, 34927, 34835, 34742, 34650, 34557, 34465, 34372, 34280, 34187, 34095, 34003, 33910, 33818, 33725, 33633, 33541, 33449, 33356, 33264, 33172, 33079, 32987, 32895, 32803, 32711, 32619, 32527, 32435, 32343, 32251, 32159, 32067, 31975, 31883, 31791, 31699, 31607, 31516, 31424, 31332, 31241, 31149, 31058,
	30966, 30875, 30783, 30692, 30600, 30509, 30418, 30327, 30236, 30144, 30053, 29962, 29871, 29781, 29690, 29599, 29508, 29417, 29327, 29236, 29146, 29055, 28965, 28875, 28784, 28694, 28604, 28514, 28424, 28334, 28244, 28154, 28064, 27975, 27885, 27796, 27706, 27617, 27527, 27438, 27349, 27260, 27171, 27082, 26993, 26904, 26816, 26727, 26638, 26550, 26462, 26373, 26285, 26197, 26109, 26021, 25933, 25845, 25758, 25670, 25582, 25495, 25408, 25320, 25233, 25146, 25059, 24973, 24886, 24799, 24713, 24626, 24540, 24454, 24367, 24281, 24196, 24110, 24024, 23938, 23853, 23767, 23682, 23597, 23512, 23427, 23342, 23257,
	23173, 23088, 23004, 22920, 22836, 22751, 22668, 22584, 22500, 22417, 22333, 22250, 22167, 22084, 22001, 21918, 21835, 21753, 21670, 21588, 21506, 21424, 21342, 21260, 21178, 21097, 21016, 20934, 20853, 20772, 20691, 20611, 20530, 20450, 20370, 20289, 20209, 20130, 20050, 19970, 19891, 19812, 19733, 19654, 19575, 19496, 19418, 19339, 19261, 19183, 19105, 19027, 18950, 18872, 18795, 18718, 18641, 18564, 18487, 18411, 18335, 18258, 18182, 18107, 18031, 17955, 17880, 17805, 17730, 17655, 17580, 17506, 17431, 17357, 17283, 17209, 17135, 17062, 16988, 16915, 16842, 16769, 16697, 16624, 16552, 16480, 16408, 16336,
	16265, 16193, 16122, 16051, 15980, 15909, 15839, 15769, 15699, 15629, 15559, 15489, 15420, 15351, 15282, 15213, 15144, 15076, 15008, 14940, 14872, 14804, 14737, 14669, 14602, 14535, 14469, 14402, 14336, 14270, 14204, 14138, 14073, 14007, 13942, 13877, 13813, 13748, 13684, 13620, 13556, 13492, 13429, 13365, 13302, 13240, 13177, 13115, 13052, 12990, 12929, 12867, 12806, 12744, 12683, 12623, 12562, 12502, 12442, 12382, 12322, 12263, 12204, 12145, 12086, 12027, 11969, 11911, 11853, 11795, 11738, 11681, 11624, 11567, 11510, 11454, 11398, 11342, 11286, 11231, 11175, 11121, 11066, 11011, 10957, 10903, 10849, 10795,
	10742, 10689, 10636, 10583, 10531, 10479, 10427, 10375, 10323, 10272, 10221, 10170, 10120, 10070, 10019, 9970,  9920,  9871,  9822,  9773,  9724,  9676, 9627,  9580,  9532,  9484,  9437,  9390,  9344,  9297,  9251,  9205,  9159, 9114,  9069,  9024,  8979,  8934,  8890,  8846,  8803,  8759,  8716,  8673, 8630,  8588,  8545,  8504,  8462,  8420,  8379,  8338,  8297,  8257,  8217, 8177,  8137,  8098,  8059,  8020,  7981,  7943,  7905,  7867,  7829,  7792, 7755,  7718,  7681,  7645,  7609,  7573,  7538,  7502,  7467,  7433,  7398, 7364,  7330,  7296,  7263,  7230,  7197,  7164,  7132,  7100,  7068,  7036,
	7005,  6974,  6943,  6913,  6883,  6853,  6823,  6794,  6764,  6736,  6707, 6679,  6651,  6623,  6595,  6568,  6541,  6514,  6488,  6462,  6436,  6410, 6385,  6360,  6335,  6310,  6286,  6262,  6238,  6215,  6192,  6169,  6146, 6124,  6102,  6080,  6059,  6037,  6016,  5996,  5975,  5955,  5935,  5916, 5897,  5878,  5859,  5840,  5822,  5804,  5787,  5769,  5752,  5735,  5719, 5703,  5687,  5671,  5656,  5641,  5626,  5611,  5597,  5583,  5569,  5556, 5543,  5530,  5517,  5505,  5493,  5481,  5470,  5458,  5448,  5437,  5427, 5417,  5407,  5397,  5388,  5379,  5370,  5362,  5354,  5346,  5339,  5332,
	5325,  5318,  5312,  5305,  5300,  5294,  5289,  5284,  5279,  5275,  5271, 5267,  5263,  5260,  5257,  5254,  5252,  5250,  5248,  5246,  5245,  5244, 5243,  5243,
};

// sec_sin, sec_cos : -65536~65536
static const int32_t sin[1024] = {
	0,         205886,    411764,    617627,    823467,    1029276,   1235045,
	1440769,   1646438,   1852045,   2057582,   2263042,   2468417,   2673699,
	2878880,   3083953,   3288909,   3493742,   3698444,   3903006,   4107421,
	4311681,   4515779,   4719707,   4923458,   5127023,   5330395,   5533566,
	5736529,   5939276,   6141799,   6344092,   6546145,   6747952,   6949505,
	7150796,   7351818,   7552563,   7753024,   7953192,   8153062,   8352624,
	8551872,   8750798,   8949395,   9147655,   9345570,   9543133,   9740337,
	9937175,   10133638,  10329720,  10525413,  10720709,  10915602,  11110084,
	11304148,  11497786,  11690991,  11883756,  12076074,  12267936,  12459338,
	12650270,  12840725,  13030697,  13220179,  13409163,  13597642,  13785609,
	13973057,  14159979,  14346368,  14532217,  14717519,  14902266,  15086453,
	15270071,  15453115,  15635577,  15817450,  15998727,  16179403,  16359469,
	16538919,  16717746,  16895944,  17073506,  17250426,  17426695,  17602309,
	17777260,  17951541,  18125147,  18298070,  18470305,  18641844,  18812681,
	18982810,  19152224,  19320917,  19488882,  19656114,  19822606,  19988352,
	20153345,  20317579,  20481048,  20643747,  20805668,  20966805,  21127153,
	21286706,  21445458,  21603402,  21760532,  21916844,  22072330,  22226985,
	22380804,  22533779,  22685907,  22837180,  22987593,  23137141,  23285818,
	23433618,  23580536,  23726566,  23871703,  24015941,  24159275,  24301699,
	24443209,  24583798,  24723461,  24862194,  24999991,  25136846,  25272755,
	25407713,  25541714,  25674753,  25806826,  25937927,  26068051,  26197194,
	26325351,  26452517,  26578686,  26703855,  26828019,  26951172,  27073311,
	27194431,  27314527,  27433594,  27551629,  27668626,  27784581,  27899491,
	28013350,  28126154,  28237899,  28348582,  28458196,  28566740,  28674208,
	28780596,  28885901,  28990118,  29093244,  29195275,  29296206,  29396034,
	29494756,  29592367,  29688864,  29784243,  29878501,  29971634,  30063639,
	30154511,  30244249,  30332847,  30420304,  30506615,  30591778,  30675789,
	30758645,  30840343,  30920880,  31000253,  31078459,  31155494,  31231357,
	31306043,  31379551,  31451878,  31523021,  31592976,  31661743,  31729317,
	31795696,  31860879,  31924862,  31987643,  32049219,  32109589,  32168751,
	32226701,  32283437,  32338958,  32393262,  32446346,  32498209,  32548848,
	32598261,  32646447,  32693405,  32739131,  32783624,  32826884,  32868907,
	32909693,  32949240,  32987546,  33024611,  33060432,  33095008,  33128338,
	33160421,  33191256,  33220841,  33249175,  33276257,  33302087,  33326663,
	33349984,  33372049,  33392858,  33412410,  33430704,  33447739,  33463515,
	33478031,  33491286,  33503281,  33514014,  33523486,  33531695,  33538642,
	33544326,  33548747,  33551905,  33553800,  33554432,  33553800,  33551905,
	33548747,  33544326,  33538642,  33531695,  33523486,  33514014,  33503281,
	33491286,  33478031,  33463515,  33447739,  33430704,  33412410,  33392858,
	33372049,  33349984,  33326663,  33302087,  33276257,  33249175,  33220841,
	33191256,  33160421,  33128338,  33095008,  33060432,  33024611,  32987546,
	32949240,  32909693,  32868907,  32826884,  32783624,  32739131,  32693405,
	32646447,  32598261,  32548848,  32498209,  32446346,  32393262,  32338958,
	32283437,  32226701,  32168751,  32109589,  32049219,  31987643,  31924862,
	31860879,  31795696,  31729317,  31661743,  31592976,  31523021,  31451878,
	31379551,  31306043,  31231357,  31155494,  31078459,  31000253,  30920880,
	30840343,  30758645,  30675789,  30591778,  30506615,  30420304,  30332847,
	30244249,  30154511,  30063639,  29971634,  29878501,  29784243,  29688864,
	29592367,  29494756,  29396034,  29296206,  29195275,  29093244,  28990118,
	28885901,  28780596,  28674208,  28566740,  28458196,  28348582,  28237899,
	28126154,  28013350,  27899491,  27784581,  27668626,  27551629,  27433594,
	27314527,  27194431,  27073311,  26951172,  26828019,  26703855,  26578686,
	26452517,  26325351,  26197194,  26068051,  25937927,  25806826,  25674753,
	25541714,  25407713,  25272755,  25136846,  24999991,  24862194,  24723461,
	24583798,  24443209,  24301699,  24159275,  24015941,  23871703,  23726566,
	23580536,  23433618,  23285818,  23137141,  22987593,  22837180,  22685907,
	22533779,  22380804,  22226985,  22072330,  21916844,  21760532,  21603402,
	21445458,  21286706,  21127153,  20966805,  20805668,  20643747,  20481048,
	20317579,  20153345,  19988352,  19822606,  19656114,  19488882,  19320917,
	19152224,  18982810,  18812681,  18641844,  18470305,  18298070,  18125147,
	17951541,  17777260,  17602309,  17426695,  17250426,  17073506,  16895944,
	16717746,  16538919,  16359469,  16179403,  15998727,  15817450,  15635577,
	15453115,  15270071,  15086453,  14902266,  14717519,  14532217,  14346368,
	14159979,  13973057,  13785609,  13597642,  13409163,  13220179,  13030697,
	12840725,  12650270,  12459338,  12267936,  12076074,  11883756,  11690991,
	11497786,  11304148,  11110084,  10915602,  10720709,  10525413,  10329720,
	10133638,  9937175,   9740337,   9543133,   9345570,   9147655,   8949395,
	8750798,   8551872,   8352624,   8153062,   7953192,   7753024,   7552563,
	7351818,   7150796,   6949505,   6747952,   6546145,   6344092,   6141799,
	5939276,   5736529,   5533566,   5330395,   5127023,   4923458,   4719707,
	4515779,   4311681,   4107421,   3903006,   3698444,   3493742,   3288909,
	3083953,   2878880,   2673699,   2468417,   2263042,   2057582,   1852045,
	1646438,   1440769,   1235045,   1029276,   823467,    617627,    411764,
	205886,    0,         -205886,   -411764,   -617627,   -823467,   -1029276,
	-1235045,  -1440769,  -1646438,  -1852045,  -2057582,  -2263042,  -2468417,
	-2673699,  -2878880,  -3083953,  -3288909,  -3493742,  -3698444,  -3903006,
	-4107421,  -4311681,  -4515779,  -4719707,  -4923458,  -5127023,  -5330395,
	-5533566,  -5736529,  -5939276,  -6141799,  -6344092,  -6546145,  -6747952,
	-6949505,  -7150796,  -7351818,  -7552563,  -7753024,  -7953192,  -8153062,
	-8352624,  -8551872,  -8750798,  -8949395,  -9147655,  -9345570,  -9543133,
	-9740337,  -9937175,  -10133638, -10329720, -10525413, -10720709, -10915602,
	-11110084, -11304148, -11497786, -11690991, -11883756, -12076074, -12267936,
	-12459338, -12650270, -12840725, -13030697, -13220179, -13409163, -13597642,
	-13785609, -13973057, -14159979, -14346368, -14532217, -14717519, -14902266,
	-15086453, -15270071, -15453115, -15635577, -15817450, -15998727, -16179403,
	-16359469, -16538919, -16717746, -16895944, -17073506, -17250426, -17426695,
	-17602309, -17777260, -17951541, -18125147, -18298070, -18470305, -18641844,
	-18812681, -18982810, -19152224, -19320917, -19488882, -19656114, -19822606,
	-19988352, -20153345, -20317579, -20481048, -20643747, -20805668, -20966805,
	-21127153, -21286706, -21445458, -21603402, -21760532, -21916844, -22072330,
	-22226985, -22380804, -22533779, -22685907, -22837180, -22987593, -23137141,
	-23285818, -23433618, -23580536, -23726566, -23871703, -24015941, -24159275,
	-24301699, -24443209, -24583798, -24723461, -24862194, -24999991, -25136846,
	-25272755, -25407713, -25541714, -25674753, -25806826, -25937927, -26068051,
	-26197194, -26325351, -26452517, -26578686, -26703855, -26828019, -26951172,
	-27073311, -27194431, -27314527, -27433594, -27551629, -27668626, -27784581,
	-27899491, -28013350, -28126154, -28237899, -28348582, -28458196, -28566740,
	-28674208, -28780596, -28885901, -28990118, -29093244, -29195275, -29296206,
	-29396034, -29494756, -29592367, -29688864, -29784243, -29878501, -29971634,
	-30063639, -30154511, -30244249, -30332847, -30420304, -30506615, -30591778,
	-30675789, -30758645, -30840343, -30920880, -31000253, -31078459, -31155494,
	-31231357, -31306043, -31379551, -31451878, -31523021, -31592976, -31661743,
	-31729317, -31795696, -31860879, -31924862, -31987643, -32049219, -32109589,
	-32168751, -32226701, -32283437, -32338958, -32393262, -32446346, -32498209,
	-32548848, -32598261, -32646447, -32693405, -32739131, -32783624, -32826884,
	-32868907, -32909693, -32949240, -32987546, -33024611, -33060432, -33095008,
	-33128338, -33160421, -33191256, -33220841, -33249175, -33276257, -33302087,
	-33326663, -33349984, -33372049, -33392858, -33412410, -33430704, -33447739,
	-33463515, -33478031, -33491286, -33503281, -33514014, -33523486, -33531695,
	-33538642, -33544326, -33548747, -33551905, -33553800, -33554432, -33553800,
	-33551905, -33548747, -33544326, -33538642, -33531695, -33523486, -33514014,
	-33503281, -33491286, -33478031, -33463515, -33447739, -33430704, -33412410,
	-33392858, -33372049, -33349984, -33326663, -33302087, -33276257, -33249175,
	-33220841, -33191256, -33160421, -33128338, -33095008, -33060432, -33024611,
	-32987546, -32949240, -32909693, -32868907, -32826884, -32783624, -32739131,
	-32693405, -32646447, -32598261, -32548848, -32498209, -32446346, -32393262,
	-32338958, -32283437, -32226701, -32168751, -32109589, -32049219, -31987643,
	-31924862, -31860879, -31795696, -31729317, -31661743, -31592976, -31523021,
	-31451878, -31379551, -31306043, -31231357, -31155494, -31078459, -31000253,
	-30920880, -30840343, -30758645, -30675789, -30591778, -30506615, -30420304,
	-30332847, -30244249, -30154511, -30063639, -29971634, -29878501, -29784243,
	-29688864, -29592367, -29494756, -29396034, -29296206, -29195275, -29093244,
	-28990118, -28885901, -28780596, -28674208, -28566740, -28458196, -28348582,
	-28237899, -28126154, -28013350, -27899491, -27784581, -27668626, -27551629,
	-27433594, -27314527, -27194431, -27073311, -26951172, -26828019, -26703855,
	-26578686, -26452517, -26325351, -26197194, -26068051, -25937927, -25806826,
	-25674753, -25541714, -25407713, -25272755, -25136846, -24999991, -24862194,
	-24723461, -24583798, -24443209, -24301699, -24159275, -24015941, -23871703,
	-23726566, -23580536, -23433618, -23285818, -23137141, -22987593, -22837180,
	-22685907, -22533779, -22380804, -22226985, -22072330, -21916844, -21760532,
	-21603402, -21445458, -21286706, -21127153, -20966805, -20805668, -20643747,
	-20481048, -20317579, -20153345, -19988352, -19822606, -19656114, -19488882,
	-19320917, -19152224, -18982810, -18812681, -18641844, -18470305, -18298070,
	-18125147, -17951541, -17777260, -17602309, -17426695, -17250426, -17073506,
	-16895944, -16717746, -16538919, -16359469, -16179403, -15998727, -15817450,
	-15635577, -15453115, -15270071, -15086453, -14902266, -14717519, -14532217,
	-14346368, -14159979, -13973057, -13785609, -13597642, -13409163, -13220179,
	-13030697, -12840725, -12650270, -12459338, -12267936, -12076074, -11883756,
	-11690991, -11497786, -11304148, -11110084, -10915602, -10720709, -10525413,
	-10329720, -10133638, -9937175,  -9740337,  -9543133,  -9345570,  -9147655,
	-8949395,  -8750798,  -8551872,  -8352624,  -8153062,  -7953192,  -7753024,
	-7552563,  -7351818,  -7150796,  -6949505,  -6747952,  -6546145,  -6344092,
	-6141799,  -5939276,  -5736529,  -5533566,  -5330395,  -5127023,  -4923458,
	-4719707,  -4515779,  -4311681,  -4107421,  -3903006,  -3698444,  -3493742,
	-3288909,  -3083953,  -2878880,  -2673699,  -2468417,  -2263042,  -2057582,
	-1852045,  -1646438,  -1440769,  -1235045,  -1029276,  -823467,   -617627,
	-411764,   -205886
};

static const int32_t cos[1024] = {
	33554432,  33553800,  33551905,  33548747,  33544326,  33538642,  33531695,
	33523486,  33514014,  33503281,  33491286,  33478031,  33463515,  33447739,
	33430704,  33412410,  33392858,  33372049,  33349984,  33326663,  33302087,
	33276257,  33249175,  33220841,  33191256,  33160421,  33128338,  33095008,
	33060432,  33024611,  32987546,  32949240,  32909693,  32868907,  32826884,
	32783624,  32739131,  32693405,  32646447,  32598261,  32548848,  32498209,
	32446346,  32393262,  32338958,  32283437,  32226701,  32168751,  32109589,
	32049219,  31987643,  31924862,  31860879,  31795696,  31729317,  31661743,
	31592976,  31523021,  31451878,  31379551,  31306043,  31231357,  31155494,
	31078459,  31000253,  30920880,  30840343,  30758645,  30675789,  30591778,
	30506615,  30420304,  30332847,  30244249,  30154511,  30063639,  29971634,
	29878501,  29784243,  29688864,  29592367,  29494756,  29396034,  29296206,
	29195275,  29093244,  28990118,  28885901,  28780596,  28674208,  28566740,
	28458196,  28348582,  28237899,  28126154,  28013350,  27899491,  27784581,
	27668626,  27551629,  27433594,  27314527,  27194431,  27073311,  26951172,
	26828019,  26703855,  26578686,  26452517,  26325351,  26197194,  26068051,
	25937927,  25806826,  25674753,  25541714,  25407713,  25272755,  25136846,
	24999991,  24862194,  24723461,  24583798,  24443209,  24301699,  24159275,
	24015941,  23871703,  23726566,  23580536,  23433618,  23285818,  23137141,
	22987593,  22837180,  22685907,  22533779,  22380804,  22226985,  22072330,
	21916844,  21760532,  21603402,  21445458,  21286706,  21127153,  20966805,
	20805668,  20643747,  20481048,  20317579,  20153345,  19988352,  19822606,
	19656114,  19488882,  19320917,  19152224,  18982810,  18812681,  18641844,
	18470305,  18298070,  18125147,  17951541,  17777260,  17602309,  17426695,
	17250426,  17073506,  16895944,  16717746,  16538919,  16359469,  16179403,
	15998727,  15817450,  15635577,  15453115,  15270071,  15086453,  14902266,
	14717519,  14532217,  14346368,  14159979,  13973057,  13785609,  13597642,
	13409163,  13220179,  13030697,  12840725,  12650270,  12459338,  12267936,
	12076074,  11883756,  11690991,  11497786,  11304148,  11110084,  10915602,
	10720709,  10525413,  10329720,  10133638,  9937175,   9740337,   9543133,
	9345570,   9147655,   8949395,   8750798,   8551872,   8352624,   8153062,
	7953192,   7753024,   7552563,   7351818,   7150796,   6949505,   6747952,
	6546145,   6344092,   6141799,   5939276,   5736529,   5533566,   5330395,
	5127023,   4923458,   4719707,   4515779,   4311681,   4107421,   3903006,
	3698444,   3493742,   3288909,   3083953,   2878880,   2673699,   2468417,
	2263042,   2057582,   1852045,   1646438,   1440769,   1235045,   1029276,
	823467,    617627,    411764,    205886,    0,         -205886,   -411764,
	-617627,   -823467,   -1029276,  -1235045,  -1440769,  -1646438,  -1852045,
	-2057582,  -2263042,  -2468417,  -2673699,  -2878880,  -3083953,  -3288909,
	-3493742,  -3698444,  -3903006,  -4107421,  -4311681,  -4515779,  -4719707,
	-4923458,  -5127023,  -5330395,  -5533566,  -5736529,  -5939276,  -6141799,
	-6344092,  -6546145,  -6747952,  -6949505,  -7150796,  -7351818,  -7552563,
	-7753024,  -7953192,  -8153062,  -8352624,  -8551872,  -8750798,  -8949395,
	-9147655,  -9345570,  -9543133,  -9740337,  -9937175,  -10133638, -10329720,
	-10525413, -10720709, -10915602, -11110084, -11304148, -11497786, -11690991,
	-11883756, -12076074, -12267936, -12459338, -12650270, -12840725, -13030697,
	-13220179, -13409163, -13597642, -13785609, -13973057, -14159979, -14346368,
	-14532217, -14717519, -14902266, -15086453, -15270071, -15453115, -15635577,
	-15817450, -15998727, -16179403, -16359469, -16538919, -16717746, -16895944,
	-17073506, -17250426, -17426695, -17602309, -17777260, -17951541, -18125147,
	-18298070, -18470305, -18641844, -18812681, -18982810, -19152224, -19320917,
	-19488882, -19656114, -19822606, -19988352, -20153345, -20317579, -20481048,
	-20643747, -20805668, -20966805, -21127153, -21286706, -21445458, -21603402,
	-21760532, -21916844, -22072330, -22226985, -22380804, -22533779, -22685907,
	-22837180, -22987593, -23137141, -23285818, -23433618, -23580536, -23726566,
	-23871703, -24015941, -24159275, -24301699, -24443209, -24583798, -24723461,
	-24862194, -24999991, -25136846, -25272755, -25407713, -25541714, -25674753,
	-25806826, -25937927, -26068051, -26197194, -26325351, -26452517, -26578686,
	-26703855, -26828019, -26951172, -27073311, -27194431, -27314527, -27433594,
	-27551629, -27668626, -27784581, -27899491, -28013350, -28126154, -28237899,
	-28348582, -28458196, -28566740, -28674208, -28780596, -28885901, -28990118,
	-29093244, -29195275, -29296206, -29396034, -29494756, -29592367, -29688864,
	-29784243, -29878501, -29971634, -30063639, -30154511, -30244249, -30332847,
	-30420304, -30506615, -30591778, -30675789, -30758645, -30840343, -30920880,
	-31000253, -31078459, -31155494, -31231357, -31306043, -31379551, -31451878,
	-31523021, -31592976, -31661743, -31729317, -31795696, -31860879, -31924862,
	-31987643, -32049219, -32109589, -32168751, -32226701, -32283437, -32338958,
	-32393262, -32446346, -32498209, -32548848, -32598261, -32646447, -32693405,
	-32739131, -32783624, -32826884, -32868907, -32909693, -32949240, -32987546,
	-33024611, -33060432, -33095008, -33128338, -33160421, -33191256, -33220841,
	-33249175, -33276257, -33302087, -33326663, -33349984, -33372049, -33392858,
	-33412410, -33430704, -33447739, -33463515, -33478031, -33491286, -33503281,
	-33514014, -33523486, -33531695, -33538642, -33544326, -33548747, -33551905,
	-33553800, -33554432, -33553800, -33551905, -33548747, -33544326, -33538642,
	-33531695, -33523486, -33514014, -33503281, -33491286, -33478031, -33463515,
	-33447739, -33430704, -33412410, -33392858, -33372049, -33349984, -33326663,
	-33302087, -33276257, -33249175, -33220841, -33191256, -33160421, -33128338,
	-33095008, -33060432, -33024611, -32987546, -32949240, -32909693, -32868907,
	-32826884, -32783624, -32739131, -32693405, -32646447, -32598261, -32548848,
	-32498209, -32446346, -32393262, -32338958, -32283437, -32226701, -32168751,
	-32109589, -32049219, -31987643, -31924862, -31860879, -31795696, -31729317,
	-31661743, -31592976, -31523021, -31451878, -31379551, -31306043, -31231357,
	-31155494, -31078459, -31000253, -30920880, -30840343, -30758645, -30675789,
	-30591778, -30506615, -30420304, -30332847, -30244249, -30154511, -30063639,
	-29971634, -29878501, -29784243, -29688864, -29592367, -29494756, -29396034,
	-29296206, -29195275, -29093244, -28990118, -28885901, -28780596, -28674208,
	-28566740, -28458196, -28348582, -28237899, -28126154, -28013350, -27899491,
	-27784581, -27668626, -27551629, -27433594, -27314527, -27194431, -27073311,
	-26951172, -26828019, -26703855, -26578686, -26452517, -26325351, -26197194,
	-26068051, -25937927, -25806826, -25674753, -25541714, -25407713, -25272755,
	-25136846, -24999991, -24862194, -24723461, -24583798, -24443209, -24301699,
	-24159275, -24015941, -23871703, -23726566, -23580536, -23433618, -23285818,
	-23137141, -22987593, -22837180, -22685907, -22533779, -22380804, -22226985,
	-22072330, -21916844, -21760532, -21603402, -21445458, -21286706, -21127153,
	-20966805, -20805668, -20643747, -20481048, -20317579, -20153345, -19988352,
	-19822606, -19656114, -19488882, -19320917, -19152224, -18982810, -18812681,
	-18641844, -18470305, -18298070, -18125147, -17951541, -17777260, -17602309,
	-17426695, -17250426, -17073506, -16895944, -16717746, -16538919, -16359469,
	-16179403, -15998727, -15817450, -15635577, -15453115, -15270071, -15086453,
	-14902266, -14717519, -14532217, -14346368, -14159979, -13973057, -13785609,
	-13597642, -13409163, -13220179, -13030697, -12840725, -12650270, -12459338,
	-12267936, -12076074, -11883756, -11690991, -11497786, -11304148, -11110084,
	-10915602, -10720709, -10525413, -10329720, -10133638, -9937175,  -9740337,
	-9543133,  -9345570,  -9147655,  -8949395,  -8750798,  -8551872,  -8352624,
	-8153062,  -7953192,  -7753024,  -7552563,  -7351818,  -7150796,  -6949505,
	-6747952,  -6546145,  -6344092,  -6141799,  -5939276,  -5736529,  -5533566,
	-5330395,  -5127023,  -4923458,  -4719707,  -4515779,  -4311681,  -4107421,
	-3903006,  -3698444,  -3493742,  -3288909,  -3083953,  -2878880,  -2673699,
	-2468417,  -2263042,  -2057582,  -1852045,  -1646438,  -1440769,  -1235045,
	-1029276,  -823467,   -617627,   -411764,   -205886,   0,         205886,
	411764,    617627,    823467,    1029276,   1235045,   1440769,   1646438,
	1852045,   2057582,   2263042,   2468417,   2673699,   2878880,   3083953,
	3288909,   3493742,   3698444,   3903006,   4107421,   4311681,   4515779,
	4719707,   4923458,   5127023,   5330395,   5533566,   5736529,   5939276,
	6141799,   6344092,   6546145,   6747952,   6949505,   7150796,   7351818,
	7552563,   7753024,   7953192,   8153062,   8352624,   8551872,   8750798,
	8949395,   9147655,   9345570,   9543133,   9740337,   9937175,   10133638,
	10329720,  10525413,  10720709,  10915602,  11110084,  11304148,  11497786,
	11690991,  11883756,  12076074,  12267936,  12459338,  12650270,  12840725,
	13030697,  13220179,  13409163,  13597642,  13785609,  13973057,  14159979,
	14346368,  14532217,  14717519,  14902266,  15086453,  15270071,  15453115,
	15635577,  15817450,  15998727,  16179403,  16359469,  16538919,  16717746,
	16895944,  17073506,  17250426,  17426695,  17602309,  17777260,  17951541,
	18125147,  18298070,  18470305,  18641844,  18812681,  18982810,  19152224,
	19320917,  19488882,  19656114,  19822606,  19988352,  20153345,  20317579,
	20481048,  20643747,  20805668,  20966805,  21127153,  21286706,  21445458,
	21603402,  21760532,  21916844,  22072330,  22226985,  22380804,  22533779,
	22685907,  22837180,  22987593,  23137141,  23285818,  23433618,  23580536,
	23726566,  23871703,  24015941,  24159275,  24301699,  24443209,  24583798,
	24723461,  24862194,  24999991,  25136846,  25272755,  25407713,  25541714,
	25674753,  25806826,  25937927,  26068051,  26197194,  26325351,  26452517,
	26578686,  26703855,  26828019,  26951172,  27073311,  27194431,  27314527,
	27433594,  27551629,  27668626,  27784581,  27899491,  28013350,  28126154,
	28237899,  28348582,  28458196,  28566740,  28674208,  28780596,  28885901,
	28990118,  29093244,  29195275,  29296206,  29396034,  29494756,  29592367,
	29688864,  29784243,  29878501,  29971634,  30063639,  30154511,  30244249,
	30332847,  30420304,  30506615,  30591778,  30675789,  30758645,  30840343,
	30920880,  31000253,  31078459,  31155494,  31231357,  31306043,  31379551,
	31451878,  31523021,  31592976,  31661743,  31729317,  31795696,  31860879,
	31924862,  31987643,  32049219,  32109589,  32168751,  32226701,  32283437,
	32338958,  32393262,  32446346,  32498209,  32548848,  32598261,  32646447,
	32693405,  32739131,  32783624,  32826884,  32868907,  32909693,  32949240,
	32987546,  33024611,  33060432,  33095008,  33128338,  33160421,  33191256,
	33220841,  33249175,  33276257,  33302087,  33326663,  33349984,  33372049,
	33392858,  33412410,  33430704,  33447739,  33463515,  33478031,  33491286,
	33503281,  33514014,  33523486,  33531695,  33538642,  33544326,  33548747,
	33551905,  33553800
};

static const int32_t fft_mask[512] = {
	1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
	1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
	1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1018, 1013, 1008,
	1003, 998, 993, 988, 983, 978, 973, 968, 964, 959, 954, 950, 945, 941, 936,
	932, 927, 923, 919, 915, 910, 906, 902, 898, 894, 890, 886, 882, 878, 874,
	870, 867, 863, 859, 855, 852, 848, 844, 841, 837, 834, 830, 827, 823, 820,
	816, 813, 810, 806, 803, 800, 797, 794, 790, 787, 784, 781, 778, 775, 772,
	769, 766, 763, 760, 757, 754, 751, 748, 746, 743, 740, 737, 735, 732, 729,
	726, 724, 721, 719, 716, 713, 711, 708, 706, 703, 701, 698, 696, 693, 691,
	688, 686, 684, 681, 679, 677, 674, 672, 670, 668, 665, 663, 661, 659, 656,
	654, 652, 650, 648, 646, 644, 642, 639, 637, 635, 633, 631, 629, 627, 625,
	623, 621, 619, 618, 616, 614, 612, 610, 608, 606, 604, 602, 601, 599, 597,
	595, 593, 592, 590, 588, 586, 585, 583, 581, 579, 578, 576, 574, 573, 571,
	569, 568, 566, 565, 563, 561, 560, 558, 557, 555, 554, 552, 550, 549, 547,
	546, 544, 543, 541, 540, 538, 537, 536, 534, 533, 531, 530, 528, 527, 526,
	524, 523, 521, 520, 519, 517, 516, 515, 513, 512, 511, 509, 508, 507, 505,
	504, 503, 502, 500, 499, 498, 497, 495, 494, 493, 492, 490, 489, 488, 487,
	486, 484, 483, 482, 481, 480, 478, 477, 476, 475, 474, 473, 472, 470, 469,
	468, 467, 466, 465, 464, 463, 462, 461, 460, 458, 457, 456, 455, 454, 453,
	452, 451, 450, 449, 448, 447, 446, 445, 444, 443, 442, 441, 440, 439, 438,
	437, 436, 435, 434, 433, 432, 431, 430, 430, 429, 428, 427, 426, 425, 424,
	423, 422, 421, 420, 420, 419, 418, 417, 416, 415, 414, 413, 413, 412, 411,
	410, 409, 408, 407, 407, 406, 405, 404, 403, 402, 402, 401, 400, 399, 398,
	398, 397, 396, 395, 394, 394, 393, 392, 391, 390, 390, 389, 388, 387, 387,
	386, 385, 384, 384, 383, 382, 381, 381, 380, 379, 379, 378, 377, 376, 376,
	375, 374, 374, 373, 372, 371, 371, 370, 369, 369, 368, 367, 367, 366, 365,
	365, 364, 363, 363, 362, 361, 361, 360, 359, 359, 358, 357, 357, 356, 355,
	355, 354, 353, 353, 352, 352, 351, 350, 350, 349, 348, 348, 347, 347, 346,
	345, 345, 344, 344, 343, 342, 342, 341, 341, 340, 339, 339, 338, 338, 337,
	337, 336, 335, 335, 334, 334, 333, 333, 332, 331, 331, 330, 330, 329, 329,
	328, 328, 327, 327, 326, 325, 325, 324, 324, 323, 323, 322, 322, 321, 321,
	320, 320, 319, 319, 318, 318, 317, 317, 316, 316, 315, 315, 314, 314, 313,
	313, 312, 312, 311, 311, 310, 310, 309, 309, 308, 308, 307, 307, 306, 306,
	305, 305, 304, 304, 303, 303, 303, 302, 302, 301, 301, 300, 300, 299, 299,
	298, 298, 298, 297, 297, 296, 296, 295
};

static int tsl2511_set_sampling_time(struct tsl2511_device_data *data , u16 time);

static uint64_t ams_isqrt(uint64_t x)
{
	register uint64_t result, tmp;

	result = 0;
	tmp = (1LL << 62);  // second-to-top bit set
	while (tmp > x) {
		tmp >>= 2;
	}
	while (tmp != 0) {
		if (x >= (result + tmp)) {
			x -= result + tmp;
			result += 2 * tmp;  // <-- faster than 2 * one
		}
		result >>= 1;
		tmp >>= 2;
	}
	return result;
}

static uint64_t SEC_sqrt(uint64_t x)
{
	register uint64_t result, tmp;

	result = 0;
	tmp = (1LL << 62);  // second-to-top bit set
	while (tmp > x) {
		tmp >>= 2;
	}
	while (tmp != 0) {
		if (x >= (result + tmp)) {
			x -= result + tmp;
			result += 2 * tmp;  // <-- faster than 2 * one
		}
		result >>= 1;
		tmp >>= 2;
	}
	return result;
}

void ams_get_magnitude(int64_t* data_r, int64_t* data_i, int32_t* buffer, int size)
	// data : 41~50 bits
{   //data must be twice as long as size
	int i;

	for (i = 0; i < size; ++i) {
		//sqrt(real^2 + imaginary^2)
		uint64_t square = 0;
		int64_t t_r = data_r[i];
		int64_t t_i = data_i[i];

		square = ((t_r * t_r) >> 1) + ((t_i * t_i) >> 1); // 60bit
		buffer[i] = (int32_t)SEC_sqrt(square); 		      // 30bit
	}
}

// n is a power of 2
int _log2n(int n)
{
	//int len = sizeof(int) * 8;
	int len = 32, i;
	for (i = 0; i < len; i++)
	{
		if ((n&1) == 1)
			return i;
		else
			n >>= 1;
	}
	return -1;
}

// Utility function for reversing the bits
// of given index x
unsigned int bitReverse(unsigned int x, int log2n)
{
	int n = 0, i;
	for (i = 0; i < log2n; i++)
	{
		n <<= 1;
		n |= (x & 1);
		x >>= 1;
	}
	return n;
}

void _fft(int32_t* a_r, int32_t* a_i, int64_t* A_r, int64_t* A_i, int n)
{
	int log2n = _log2n(n), s, k, j;
	unsigned int i;
	// bit reversal of the given array
	for (i = 0; i < n; ++i) {
		int rev = bitReverse(i, log2n);
		A_r[i] = a_r[rev]; // 28 (29 with sign)
		A_i[i] = a_i[rev]; // 28 (29 with sign)
	}
	for (s = 1; s <= log2n; s++) {
		int m = 1 << s;
		int m_2 = m >> 1;
		int64_t wm_r = (int64_t)cos[1024 >> s];	 // wm_r = cos(2 pi / m)    Q25
		int64_t wm_i = -(int64_t)sin[1024 >> s]; // wm_i = -sin(2 pi / m)    Q25

		for (k = 0; k < n; k += m)
		{
			int64_t w_r = 1LL << 25; // Q25 (33554432)
			int64_t w_i = 0;		 // Q25

			for (j = 0; j < m_2; j++) {
				int i1 = k + j;
				int i2 = i1 + m_2;
				int64_t t_r = w_r * A_r[i2] -
							  w_i * A_i[i2]; // 28+25+0~10=53~63 (64 with sign)
				int64_t t_i = w_r * A_i[i2] +
							  w_i * A_r[i2]; // 28+25+0~10=53~63 (64 with sign)
				int64_t u_r = A_r[i1];		 // 37~47
				int64_t u_i = A_i[i1];		 // 37~47
				int64_t w2_r = w_r * wm_r - w_i * wm_i; // Q25*Q25,  26+25=51
				int64_t w2_i = w_r * wm_i + w_i * wm_r; // Q25*Q25
				t_r >>= 25;								// Q25
				t_i >>= 25;								// Q25
				A_r[i1] = u_r + t_r;					// 28+0~10 = 28~38
				A_i[i1] = u_i + t_i;
				A_r[i2] = u_r - t_r;
				A_i[i2] = u_i - t_i;
				w_r = w2_r >> 25; // Q25
				w_i = w2_i >> 25; // Q25
			}
		}
	}
}

	int32_t buf_r[AMS_FFT_SIZE] = {0};
	int32_t buf_i[AMS_FFT_SIZE] = {0};
	int64_t out_r[AMS_FFT_SIZE] = {0};
	int64_t out_i[AMS_FFT_SIZE] = {0};

void FFT(int32_t* data, enum fft_size size)
	// buf_r <= 16bits data
{
	static int log_cnt;
	int i, hamming_step = 2048 / size;

	if (size > AMS_FFT_SIZE || (size & 0x7f) != 0) {
		//FFT size : multiply of 128
		//@TODO add return codes so we know it failed
		return;
	}

	for (i = 0; i < size; i++) {
		// if (!alps_data->saturation && data[i] >= '''saturation value(int)''') {
		//     ALS_err("DEBUG_FLICKER saturation\n");
		//     alps_data->saturation = true;
		// }

		buf_r[i] = ((int64_t)data[i] * (int64_t)hamming[i * hamming_step]) >> 4; // 16+16-4=28

		if (log_cnt > 30) // print debug log
			ALS_info("DEBUG_FLICKER data[%d] => %d buf[%d] => %lld\n", i,
					 data[i], i, buf_r[i]);
	}
	_fft(buf_r, buf_i, out_r, out_i, size); // output 38 (39 sign)

	for (i = 0; i < AMS_FFT_SIZE; i++) {
		out_r[i] >>= 8;
		out_i[i] >>= 8;
	}
	ams_get_magnitude(out_r, out_i, data, size);

	if (log_cnt > 30)
		log_cnt = 0;
	else
		log_cnt++;
}

// AMS FFT END

static const struct of_device_id tsl2511_match_table[] = {
	{.compatible = "ams,tsl2511",},
	{},
};

static int ams_deviceGetFlickerData(ams_deviceCtx_t *ctx, void *exportData)
{
	ams_flicker_ctx_t *flickerCtx = (ams_flicker_ctx_t *)&ctx->flickerCtx;
	memcpy((uint16_t*)&exportData[0], &flickerCtx->flicker_data[0], sizeof(uint16_t)*AMS_FFT_SIZE);
	return AMS_FFT_SIZE;
}

static long tsl2511_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	void __user *argp = (void __user *)arg;
	int ret = 0;
	//int i = 0;
	int data_length = 0;
	struct tsl2511_device_data *data = container_of(file->private_data, struct tsl2511_device_data, miscdev);

	ALS_dbg("%s - ioctl start, %d\n", __func__, cmd);
	mutex_lock(&data->flickerdatalock);

	switch (cmd) {
		case TSL2511_IOCTL_READ_FLICKER:

			data_length = ams_deviceGetFlickerData(data->deviceCtx, (void*)&data->flicker_data[0]);
			ALS_dbg("%s - TSL2511_IOCTL_READ_FLICKER = %d\n", __func__, data->flicker_data[0]);

			//for(i=0 ; i < data_length; i++)
			//    ALS_dbg("%s flicker_data[%d] = %d\n", __func__, i,data->flicker_data[i]);
			if(data_length != 0)
			{
				ret = copy_to_user(argp,
						data->flicker_data,
						sizeof(int16_t)*data_length);
				if (unlikely(ret))
					goto ioctl_error;

			}

			break;

		default:
			ALS_err("%s - invalid cmd\n", __func__);
			break;
	}

	mutex_unlock(&data->flickerdatalock);
	return ret;

ioctl_error:
	mutex_unlock(&data->flickerdatalock);
	ALS_err("%s - read flicker data err(%d)\n", __func__, ret);
	return -ret;
}

static const struct file_operations tsl2511_fops = {
	.owner = THIS_MODULE,
	.open = nonseekable_open,
	.unlocked_ioctl = tsl2511_ioctl,
};

static uint8_t alsGainToReg(uint32_t x)
{
	int i;

	for (i = sizeof(alsGain_conversion) / sizeof(uint32_t) - 1; i != 0; i--) {
		if (x >= alsGain_conversion[i])
			break;
	}
	return (i << 0);
}

static uint16_t alsSampleTimeUsToReg(uint32_t x)
{
	uint16_t regValue;

	regValue = (x * 1000) / AMS_USEC_PER_TICK;

	return regValue;
}

static uint16_t alsTimeUsToReg(uint32_t x, AMS_PORT_portHndl *portHndl)
{
	uint16_t regValue;
	uint16_t sample_time;

	if (portHndl) {
		ams_getWord(portHndl, DEVREG_SAMPLE_TIME0, &regValue);
		ALS_dbg("===== %s regValue =%x =====\n", __func__, regValue);
		regValue = regValue & MASK_ALS_SAMPLE_TIME;

		sample_time = ((regValue + 1) * AMS_USEC_PER_TICK) / 1000;

		ALS_dbg("===== %s Sameple time =%d =====\n", __func__, sample_time);
	} else {
		sample_time = 250; // default 250usec
	}

	regValue = (x / sample_time) - 1;

	return regValue;
}

static void tsl2511_debug_var(struct tsl2511_device_data *data)
{
	ALS_dbg("===== %s =====\n", __func__);
	ALS_dbg("%s client %p slave_addr 0x%x\n", __func__,
			data->client, data->client->addr);
	ALS_dbg("%s dev %p\n", __func__, data->dev);
	ALS_dbg("%s als_input_dev %p\n", __func__, data->als_input_dev);
	ALS_dbg("%s als_pinctrl %p\n", __func__, data->als_pinctrl);
	ALS_dbg("%s pins_sleep %p\n", __func__, data->pins_sleep);
	ALS_dbg("%s pins_active %p\n", __func__, data->pins_active);
	ALS_dbg("%s als_enabled %d\n", __func__, data->enabled);
	ALS_dbg("%s als_sampling_rate %d\n", __func__, data->sampling_period_ns);
	ALS_dbg("%s regulator_state %d\n", __func__, data->regulator_state);
	ALS_dbg("%s als_irq %d\n", __func__, data->dev_irq);
	ALS_dbg("%s irq_state %d\n", __func__, data->irq_state);
	ALS_dbg("===== %s =====\n", __func__);
}



static int tsl2511_write_reg_bulk(struct tsl2511_device_data *device, u8 reg_addr, u8* data, u8 length)
{
	int err = -1;
	int tries = 0;
	int num = 1;

	u8* buffer = NULL;

	struct i2c_msg msgs[] = {
		{
			.addr = device->client->addr,
			.flags = device->client->flags & I2C_M_TEN,
			.len = (length+1),
			.buf = buffer,
		},
	};

	buffer = devm_kzalloc(&device->client->dev, (length+1), GFP_KERNEL); // address + data
	if (buffer == NULL) {
		ALS_err("%s - couldn't allocate buffer data memory\n", __func__);
		return -ENOMEM;
	}

	buffer[0] = reg_addr;
	memcpy(&buffer[1] , &data[0], length);

	if (!device->pm_state || device->regulator_state == 0) {
		ALS_err("%s - write error, pm suspend or reg_state %d\n",
				__func__, device->regulator_state);
		err = -EFAULT;
		return err;
	}

	mutex_lock(&device->suspendlock);

	do {
		err = i2c_transfer(device->client->adapter, msgs, num);
		if (err != num)
			msleep_interruptible(AMSDRIVER_I2C_RETRY_DELAY);
		if (err < 0)
			ALS_err("%s - i2c_transfer error = %d\n", __func__, err);
	} while ((err != num) && (++tries < AMSDRIVER_I2C_MAX_RETRIES));

	mutex_unlock(&device->suspendlock);

	if (err != num) {
		ALS_err("%s -write transfer error:%d\n", __func__, err);
		err = -EIO;
		device->i2c_err_cnt++;
		return err;
	}
	//devm_kfree(&device->client->dev, buffer);
	//buffer = 0;

	return 0;
}

static int tsl2511_write_reg(struct tsl2511_device_data *device,
		u8 reg_addr, u8 data)
{
	int err = -1;
	int tries = 0;
	int num = 1;
	u8 buffer[2] = { reg_addr, data };
	struct i2c_msg msgs[] = {
		{
			.addr = device->client->addr,
			.flags = device->client->flags & I2C_M_TEN,
			.len = 2,
			.buf = buffer,
		},
	};

	if (!device->pm_state || device->regulator_state == 0) {
		ALS_err("%s - write error, pm suspend or reg_state %d\n",
				__func__, device->regulator_state);
		err = -EFAULT;
		return err;
	}

	mutex_lock(&device->suspendlock);

	do {
		err = i2c_transfer(device->client->adapter, msgs, num);
		if (err != num)
			msleep_interruptible(AMSDRIVER_I2C_RETRY_DELAY);
		if (err < 0)
			ALS_err("%s - i2c_transfer error = %d\n", __func__, err);
	} while ((err != num) && (++tries < AMSDRIVER_I2C_MAX_RETRIES));

	mutex_unlock(&device->suspendlock);

	if (err != num) {
		ALS_err("%s -write transfer error:%d\n", __func__, err);
		err = -EIO;
		device->i2c_err_cnt++;
		return err;
	}

	return 0;
}

static int tsl2511_read_reg(struct tsl2511_device_data *device,
		u8 reg_addr, u8 *buffer, int length)
{
	int err = -1;
	int tries = 0; /* # of attempts to read the device */
	int num = 2;
	struct i2c_msg msgs[] = {
		{
			.addr = device->client->addr,
			.flags = device->client->flags & I2C_M_TEN,
			.len = 1,
			.buf = buffer,
		},
		{
			.addr = device->client->addr,
			.flags = (device->client->flags & I2C_M_TEN) | I2C_M_RD,
			.len = length,
			.buf = buffer,
		},
	};

	if (!device->pm_state || device->regulator_state == 0) {
		ALS_err("%s - read error, pm suspend or reg_state %d\n",
				__func__, device->regulator_state);
		err = -EFAULT;
		return err;
	}

	mutex_lock(&device->suspendlock);

	do {
		buffer[0] = reg_addr;
		err = i2c_transfer(device->client->adapter, msgs, num);
		if (err != num)
			msleep_interruptible(AMSDRIVER_I2C_RETRY_DELAY);
		if (err < 0)
			ALS_err("%s - i2c_transfer error = %d\n", __func__, err);
	} while ((err != num) && (++tries < AMSDRIVER_I2C_MAX_RETRIES));

	mutex_unlock(&device->suspendlock);

	if (err != num) {
		ALS_err("%s -read transfer error:%d\n", __func__, err);
		err = -EIO;
		device->i2c_err_cnt++;
	} else
		err = 0;

	return err;
}

static int ams_getByte(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint8_t *readData)
{
	struct tsl2511_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;
	uint8_t length = 1;

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2511_read_reg(data, deviceRegisterDefinition[reg].address, readData, length);

	return err;
}

static int ams_setByte(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint8_t setData)
{
	struct tsl2511_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2511_write_reg(data, deviceRegisterDefinition[reg].address, setData);

	return err;
}

static int ams_getBuf(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint8_t *readData, uint8_t length)
{
	struct tsl2511_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2511_read_reg(data, deviceRegisterDefinition[reg].address, readData, length);

	return err;
}

int ams_setBuf(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint8_t *setData, uint8_t length)
{
	struct tsl2511_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2511_write_reg_bulk(data, deviceRegisterDefinition[reg].address, setData, length);
	return err;
}

static int ams_getWord(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint16_t *readData)
{
	struct tsl2511_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;
	uint8_t length = sizeof(uint16_t);
	uint8_t buffer[sizeof(uint16_t)];

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2511_read_reg(data, deviceRegisterDefinition[reg].address, buffer, length);

	*readData = ((buffer[0] << AMS_ENDIAN_1) + (buffer[1] << AMS_ENDIAN_2));

	return err;
}

static int ams_setWord(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint16_t setData)
{
	struct tsl2511_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;
	uint8_t buffer[sizeof(uint16_t)];

	/* Sanity check input param */
	if (reg >= (DEVREG_REG_MAX - 1))
		return 0;

	buffer[0] = ((setData >> AMS_ENDIAN_1) & 0xff);
	buffer[1] = ((setData >> AMS_ENDIAN_2) & 0xff);

	err = tsl2511_write_reg(data, deviceRegisterDefinition[reg].address, buffer[0]);
	err = tsl2511_write_reg(data, deviceRegisterDefinition[reg + 1].address, buffer[1]);

	return err;
}

int ams_getField(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint8_t *setData, ams_regMask_t mask)
{
	struct tsl2511_device_data *data = i2c_get_clientdata(portHndl);
	int err = 0;
	uint8_t length = 1;

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2511_read_reg(data, deviceRegisterDefinition[reg].address, setData, length);

	*setData &= mask;

	return err;
}

static int ams_setField(AMS_PORT_portHndl *portHndl, ams_deviceRegister_t reg, uint8_t setData, ams_regMask_t mask)
{
	struct tsl2511_device_data *data = i2c_get_clientdata(portHndl);
	int err = 1;
	uint8_t length = 1;
	uint8_t original_data;
	uint8_t new_data;

	/* Sanity check input param */
	if (reg >= DEVREG_REG_MAX)
		return 0;

	err = tsl2511_read_reg(data, deviceRegisterDefinition[reg].address, &original_data, length);
	if (err < 0)
		return err;

	new_data = original_data & ~mask;
	new_data |= (setData & mask);

	if (new_data != original_data)
		err = tsl2511_write_reg(data, deviceRegisterDefinition[reg].address, new_data);

	return err;
}

static void als_getDefaultCalibrationData(ams_ccb_als_calibration_t *data)
{
	if (data != NULL) {
		data->Time_base = AMS_ALS_TIMEBASE;
		data->thresholdLow = AMS_ALS_THRESHOLD_LOW;
		data->thresholdHigh = AMS_ALS_THRESHOLD_HIGH;
		data->calibrationFactor = 1000;
	}
}

static int amsAlg_als_processData(amsAlsContext_t *ctx, amsAlsDataSet_t *inputData)
{
	int64_t lux = 0;
	uint32_t CWRatio = 0;
	uint32_t tempWb = 0, tempClear = 0;

	//ALS_info("%s - raw: %d, %d, %d\n", __func__, inputData->datasetArray->clearADC, inputData->datasetArray->widebandADC,inputData->datasetArray->uvADC);

	/* apply coefficient here */
	if (inputData->status & ALS_STATUS_RDY) {
		ctx->results.rawClear = inputData->datasetArray->clearADC;
		ctx->results.rawWideband = inputData->datasetArray->widebandADC;
		ctx->results.rawUv = inputData->datasetArray->uvADC;
		ctx->results.rawBK = inputData->datasetArray->bkADC;
	}

	return 0;
}

static bool ams_getMode(ams_deviceCtx_t *ctx, ams_mode_t *mode)
{
	*mode = ctx->mode;

	return false;
}

uint32_t ams_getResult(ams_deviceCtx_t *ctx)
{
	uint32_t returnValue = ctx->updateAvailable;

	ctx->updateAvailable = 0;

	return returnValue;
}

static int amsAlg_als_initAlg(amsAlsContext_t *ctx, amsAlsInitData_t *initData);
static int amsAlg_als_getAlgInfo(amsAlsAlgoInfo_t *info);
static int amsAlg_als_processData(amsAlsContext_t *ctx, amsAlsDataSet_t *inputData);
//static int ams_smux_set(ams_deviceCtx_t *ctx);

static int ccb_alsInit(void *dcbCtx, ams_ccb_als_init_t *initData)
{
	ams_deviceCtx_t *ctx = (ams_deviceCtx_t *)dcbCtx;
	ams_ccb_als_ctx_t *ccbCtx = &ctx->ccbAlsCtx;
	amsAlsInitData_t initAlsData;
	amsAlsAlgoInfo_t infoAls;
	int ret = 0;

	ALS_dbg("%s - ccb_alsInit\n", __func__);

	if (initData)
		memcpy(&ccbCtx->initData, initData, sizeof(ams_ccb_als_init_t));
	else
		ccbCtx->initData.calibrate = false;

	initAlsData.adaptive = false;
	initAlsData.irRejection = false;
	initAlsData.gain = ccbCtx->initData.configData.gain;
	initAlsData.time_us = ccbCtx->initData.configData.uSecTime;
	initAlsData.calibration.adcMaxCount = ccbCtx->initData.calibrationData.adcMaxCount;
	initAlsData.calibration.calibrationFactor = ccbCtx->initData.calibrationData.calibrationFactor;
	initAlsData.calibration.Time_base = ccbCtx->initData.calibrationData.Time_base;
	initAlsData.calibration.thresholdLow = ccbCtx->initData.calibrationData.thresholdLow;
	initAlsData.calibration.thresholdHigh = ccbCtx->initData.calibrationData.thresholdHigh;
	//initAlsData.calibration.calibrationFactor = ccbCtx->initData.calibrationData.calibrationFactor;
	amsAlg_als_getAlgInfo(&infoAls);

	amsAlg_als_initAlg(&ccbCtx->ctxAlgAls, &initAlsData);

	AMS_SET_ALS_TIME(ccbCtx->initData.configData.uSecTime, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_TIME\n", __func__);
		return ret;
	}

	if( ctx->sensor_mode == 1) { //ambient mode : als only
		AMS_SET_ALS_PERS(0x00, ret);
	} else { //camera mode : als + flicker
		AMS_SET_ALS_PERS(0x01, ret);
	}
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_PERS\n", __func__);
		return ret;
	}
	ccbCtx->shadowAiltReg = 0x00ffffff;
	ccbCtx->shadowAihtReg = 0;

	AMS_SET_ALS_THRS_LOW(ccbCtx->shadowAiltReg, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_THRS_LOW\n", __func__);
		return ret;
	}

	AMS_SET_ALS_THRS_HIGH(ccbCtx->shadowAihtReg, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_THRS_HIGH\n", __func__);
		return ret;
	}

	AMS_SET_STEP0_ALS_GAIN0(ctx->ccbAlsCtx.initData.configData.gain, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_GAIN\n", __func__);
		return ret;
	}

	AMS_SET_STEP0_ALS_GAIN1(ctx->ccbAlsCtx.initData.configData.gain, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_GAIN\n", __func__);
		return ret;
	}

	AMS_SET_STEP1_ALS_GAIN0(ctx->ccbAlsCtx.initData.configData.gain, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_GAIN\n", __func__);
		return ret;
	}

	AMS_SET_STEP1_ALS_GAIN1(ctx->ccbAlsCtx.initData.configData.gain, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_GAIN\n", __func__);
		return ret;
	}

	if( ctx->sensor_mode == 0) { //camera mode
		AMS_SET_ALS_AINT_DIRECT(HIGH, ret);
		if (ret < 0) {
			ALS_err("%s - failed to AMS_SET_ALS_AINT_DIRECT\n", __func__);
			return ret;
		}
	}
	ccbCtx->state = AMS_CCB_ALS_RGB;

	return ret;
}

static int AMS_SET_FIFO_MAP(ams_deviceCtx_t *ctx);
static int AMS_SET_FIFO_MAP(ams_deviceCtx_t *ctx)
{
	int ret = 0;
	//ret = ams_setField(ctx->portHndl, DEVREG_MOD_FIFO_DATA_CFG0, 0x0f, MASK_MOD_ALS_FIFO_DATA0_WRITE_ENABLE);
	ret = ams_setByte(ctx->portHndl, DEVREG_MOD_FIFO_DATA_CFG0, 0x0f); //disable to write ALS data 0 to FIFO
	if (ret < 0) {
		ALS_err("%s - failed to MASK_MOD_ALS_FIFO_DATA0_WRITE_ENABLE\n", __func__);
		return ret;
	}

	//ret = ams_setField(ctx->portHndl, DEVREG_MOD_FIFO_DATA_CFG1, 0x0f, MASK_MOD_ALS_FIFO_DATA1_WRITE_ENABLE);
	ret = ams_setByte(ctx->portHndl, DEVREG_MOD_FIFO_DATA_CFG1, 0x0f); //disable to write ALS data 0 to FIFO
	if (ret < 0) {
		ALS_err("%s - failed to MASK_MOD_ALS_FIFO_DATA1_WRITE_ENABLE\n", __func__);
		return ret;
	}

	//ret = ams_setField(ctx->portHndl, DEVREG_MOD_FIFO_DATA_CFG2, 0x0f, MASK_MOD_ALS_FIFO_DATA2_WRITE_ENABLE);
	ret = ams_setByte(ctx->portHndl, DEVREG_MOD_FIFO_DATA_CFG2, 0x0f); //disable to write ALS data 0 to FIFO
	if (ret < 0) {
		ALS_err("%s - failed to MASK_MOD_ALS_FIFO_DATA2_WRITE_ENABLE\n", __func__);
		return ret;
	}


	return ret;
}

static void tsl2511_sequencer_init(ams_deviceCtx_t *ctx)
{
	ALS_dbg("%s \n",__func__) ;

	/* Assign Flicker to sequencer step0 ,  step1 */

	//pd0 = clear , pd1= uv, pd2=bk , pd3 = IR

	ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_PHDX_SMUX, 0x8D);//SMUX step 0, mod1=pd3|xxx=pd2| mod2=pd1| mod0=pd0
	ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP1_MOD_PHDX_SMUX, 0x2D);//SMUX step 1, xxx=pd3|mod1=pd2| mod2=pd1| mod0=pd0

	/* Assign modulator 2 to flicker */
#if 0
	ams_setField(ctx->portHndl,
			DEVREG_MEAS_SEQR_ALS_FD_1,
			0x30,
			TSL2511_MASK_MEASUREMENT_SEQUENCER_MOD2_FD_PATTERN );
#endif
	ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_ALS_FD_1 , 0x30);

	/* Assign modulator 0 to flicker */
	ams_setField(ctx->portHndl,
			DEVREG_MEAS_SEQR_FD_0,
			0x03,
			TSL2511_MASK_MEASUREMENT_SEQUENCER_MOD0_FD_PATTERN );

	/* Assign modulator 1 to flicker */
	ams_setField(ctx->portHndl,
			DEVREG_MEAS_SEQR_FD_0,
			0x30,
			TSL2511_MASK_MEASUREMENT_SEQUENCER_MOD1_FD_PATTERN );


}

static void tsl2511_fifo_format_init(ams_deviceCtx_t *ctx)
{
	/*ams_setByte(ctx->portHndl,
			DEVREG_MEAS_MODE1,
			0Xa8);*/
	ams_setByte(ctx->portHndl,
			DEVREG_MEAS_MODE1,
			0X08); //turn off end marker in fifo

	ctx->has_fifo_fd_end_marker = true;
	ctx->has_fifo_fd_gain = true;
	ALS_dbg("%s \n",__func__) ;

}

	/*        -----------------Sequence Round----------------- */
	/*            step0       step1       step2       step3    */
	/*             ALS       FLICKER      UNUSED      UNUSED   */
	/*        -------------------------------------------------*/
	/*        |           |           |           |           |*/
	/*  mod0  |     y     |     y     |    n/a    |    n/a    |*/
	/*        |           |           |           |           |*/
	/*        -------------------------------------------------*/
	/*        |           |           |           |           |*/
	/*  mod1  |    ir     |   uvwh    |    n/a    |    n/a    |*/
	/*        |           |           |           |           |*/
	/*        -------------------------------------------------*/
	/*        |           |           |           |           |*/
	/*  mod2  |    uv     |     uv    |    n/a    |    n/a    |*/
	/*        |           |           |           |           |*/
	/*        -------------------------------------------------*/
	/**/

#define FIFO_END_MARKER_SIZE                    3
#define FIFO_FD_GAIN_SIZE                       2
#define FIFO_CHAN_NUM                           3
int ccb_intclk_resume(void *dcbCtx)
{
	int ret = 0;
	ams_deviceCtx_t *ctx = (ams_deviceCtx_t *)dcbCtx;
	uint8_t vsync_cfg = 0;

	ALS_info("%s", __func__);

	/*Internal_CLK select*/
	ret = ams_setByte(ctx->portHndl, DEVREG_ENABLE, 0x00);
	//usleep_range(1000, 1100);

	ams_setByte(ctx->portHndl, DEVREG_CFG7, MOD_DIV_SEL_1); // 1/12  , internal clock 720khz

	/* vsync_lost occurred, set configuration and reset FIFO */
	/* set to HW_SYNC_MODE */
	vsync_cfg &= ~(TSL2511_REG_VSYNC_CFG__osc_calib_mode__MASK<<TSL2511_REG_VSYNC_CFG__osc_calib_mode__SHIFT);
	vsync_cfg &= ~(TSL2511_REG_VSYNC_CFG__extclk_as_sysclk__MASK<<TSL2511_REG_VSYNC_CFG__extclk_as_sysclk__SHIFT);
	vsync_cfg &= ~(TSL2511_REG_VSYNC_CFG__vsync_mode__MASK<<TSL2511_REG_VSYNC_CFG__vsync_mode__SHIFT);
	vsync_cfg |= (TSL2511_HW_SYNC_MODE<<TSL2511_REG_VSYNC_CFG__vsync_mode__SHIFT);
	ams_setByte(ctx->portHndl, DEVREG_VSYNC_CFG, vsync_cfg);
	ams_setByte(ctx->portHndl, DEVREG_CFG4, TSL2511_REG_CFG4__sint_per_step__MASK);
	ret = ams_setByte(ctx->portHndl, DEVREG_ENABLE, PON);
	//usleep_range(3000, 3300);
	mdelay(3);
	return ret;
}

int ccb_extclk_resume(void *dcbCtx)
{
	int ret = 0;
	ams_deviceCtx_t *ctx = (ams_deviceCtx_t *)dcbCtx;

	ALS_info("%s ", __func__);

	/*EXT_CLK select*/
	ret = ams_setByte(ctx->portHndl, DEVREG_ENABLE, 0x00);
	if (ret < 0) {
		ALS_err("%s - failed to set DEVREG_ENABLE\n", __func__);
		return ret;
	}

	ret = ams_setByte(ctx->portHndl, DEVREG_OSCEN, 0x01); // force osc on
	if (ret < 0) {
		ALS_err("%s - failed to set DEVREG_ENABLE\n", __func__);
		return ret;
	}
	ams_setByte(ctx->portHndl, DEVREG_CFG7, MOD_DIV_SEL_0); // 1/6 = 1600khz mod clock
	ams_setByte(ctx->portHndl, DEVREG_VSYNC_GPIO_INT, 0x20); // INT_IN_EN = 1
	ams_setByte(ctx->portHndl, DEVREG_VSYNC_PERIOD_TARGET_L, 0x33);
	ams_setByte(ctx->portHndl, DEVREG_VSYNC_PERIOD_TARGET_H, 0xAB);
	//if sync_mode ==3
	ams_setByte(ctx->portHndl, DEVREG_VSYNC_CFG, 0x76);//ext_clk auto run after pon + ext_clk_mode + div(8192) + SYNC/INT pin used EXT_CLK

	/* set interrupt as per step */
	ams_setByte(ctx->portHndl, DEVREG_CFG4, TSL2511_REG_CFG4__sint_per_step__MASK);

	ret = ams_setByte(ctx->portHndl, DEVREG_ENABLE, PON);
	mdelay(3);

	return ret;
}

int ccb_flickerInit(void *dcbCtx/*, ams_ccb_als_init_t *initData*/)
{
	ams_deviceCtx_t *ctx = (ams_deviceCtx_t *)dcbCtx;
	ams_flicker_ctx_t *ccbCtx = (ams_flicker_ctx_t *)&ctx->flickerCtx;
	struct tsl2511_device_data *data = i2c_get_clientdata(ctx->portHndl);

	int ret = 0;
	int num_bytes_1_cycle = 0;

	ctx->Step_Samples = STEP_SAMPLES;
	ctx->Flicker_Channels = 3; //pho , uv , (bk/ir)
	ctx->Data_bytes = 2;//2byte
	ctx->Gain_Bytes = 2;//last 2byte
	ctx->mod1_step_counter = 0;
	//ctx->fifo_end_size = FIFO_END_MARKER_SIZE+FIFO_FD_GAIN_SIZE;
	ctx->fifo_end_size = 0; //no hw agc


	//MOD_CALIB_NTH_ITERATION = 16 /* set to 16 for 1024 samples */
	//MOD_CALIB_NTH_ITERATION = 32 /* set to 32 for 2048 samples */

	printk(KERN_INFO "FIFO size: %u\n", kfifo_size(&ams_fifo));

	if(AMS_FFT_SIZE == 1024){
		ams_setByte(ctx->portHndl, DEVREG_MOD_CALIB_CFG0, 0x10); //1024 samples
		ALS_info("%s - 1024 sample cycle 16  \n", __func__);
	}else if(AMS_FFT_SIZE == 2048){
		ams_setByte(ctx->portHndl, DEVREG_MOD_CALIB_CFG0, 0x20); //2048 samples
		ALS_info("%s - 2048 sample cycle 32  \n", __func__);
	}

	num_bytes_1_cycle = (ctx->Step_Samples * ctx->Flicker_Channels* ctx->Data_bytes + ctx->fifo_end_size) * AMS_FFT_SIZE / (ctx->Step_Samples+1);   // (2bytes/sample, 3 channels)
	ctx->flicker_num_samples = num_bytes_1_cycle;
	ctx->flicker_1_frame = (ctx->Step_Samples * ctx->Flicker_Channels* ctx->Data_bytes + ctx->fifo_end_size);//step0 188byte , step1 188byte

	ALS_info("%s - num_bytes_1_cycle %d\n", __func__, num_bytes_1_cycle);

	ams_setByte(ctx->portHndl, DEVREG_TRIGGER_MODE, 0x03); //wait time set fast
	ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_RESIDUAL_0, 0x00); //m0, m1 residual disable
	ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_RESIDUAL_1_AND_WAIT, 0x30); //m2 residual disable and wait for the Step 0 and 1


	tsl2511_set_sampling_time( data,AMS_SAMPLING_TIME);
	//AMS_SET_SAMPLE_TIME(AMS_SAMPLING_TIME, ret);
	ALS_info("%s - AMS_SAMPLING_TIME %d\n", __func__,AMS_SAMPLING_TIME);
	if (ret < 0) {
		ALS_err("%s - failed to Sample time \n", __func__);
		return ret;
	}

	AMS_SET_FLICKER_NUM_SAMPLES(STEP_SAMPLES, ret); //31Samples
	ALS_info("%s - AMS_FLICKER_NUM_SAMPLES %d\n", __func__, AMS_FLICKER_NUM_SAMPLES);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_FLICKER_NUM_SAMPLES\n", __func__);
		return ret;
	}

	AMS_SET_ALS_TIME(0x00, ret);//ALS NR samples "0"
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_ALS_TIME\n", __func__);
		return ret;
	}

	AMS_SET_FIFO_THR(AMS_FLICKER_THR_LVL, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_FLICKER_THR_LVL\n", __func__);
		return ret;
	}

	ret = AMS_SET_FIFO_MAP(ctx);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_FIFO_MAP\n", __func__);
		return ret;
	}

#if defined(CONFIG_AMS_ADD_MARKER_AND_GAIN_FIFO)
	AMS_FD_GAIN_TO_FIFO(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_FD_GAIN_TO_FIFO\n", __func__);
		return ret;
	}

	AMS_FD_END_MARKER_TO_FIFO(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_FD_END_MARKER_TO_FIFO\n", __func__);
		return ret;
	}
#endif
	tsl2511_sequencer_init(ctx);
	tsl2511_fifo_format_init(ctx);

	/*FIFO , kfifo Clear*/
	AMS_FIFO_CLEAR(ret);
	if (ret < 0) {
		ALS_err("%s - failed to FIFO CLEAR\n", __func__);
		return ret;
	}
	kfifo_reset(&ams_fifo);
	/*FIFO , kfifo Clear*/

#if 0
	ams_setByte(ctx->portHndl, DEVREG_MOD_CALIB_CFG2,   0x60);
	//AMS_AGC_AZ_MODE(MASK_MOD_CALIB_NTH_ITERATION_AZ_ENABLE | MASK_MOD_CALIB_NTH_ITERATION_AGC_ENABLE,ret); //agc az enable
	//if (ret < 0) {
	//	ALS_err("%s - failed to set AGC ENABLE\n", __func__);
	//	return ret;
	//}

	// AGC ASAT MODE
	//AMS_AGC_ASAT_MODE(0x00, ret);
	AMS_AGC_ASAT_MODE(0x30, ret);
	if (ret < 0) {
		ALS_err("%s - failed to set AGC ASAT MODE\n", __func__);
		return ret;
	}
	// AGC PREDIC  MODE
	//AMS_AGC_PREDICT_MODE(0x00, ret);
	AMS_AGC_PREDICT_MODE(0x30, ret);
	if (ret < 0) {
		ALS_err("%s - failed to set AGC PREDIC  MODE\n", __func__);
		return ret;
	}
#else
	ams_setByte(ctx->portHndl, DEVREG_MOD_CALIB_CFG2,   0x03); //agc off , run s/w agc
	AMS_AGC_ASAT_MODE(0x00, ret);
	if (ret < 0) {
		ALS_err("%s - failed to set AGC ASAT MODE\n", __func__);
		return ret;
	}
	// AGC PREDIC  MODE
	//AMS_AGC_PREDICT_MODE(0x00, ret);
	AMS_AGC_PREDICT_MODE(0x00, ret);
	if (ret < 0) {
		ALS_err("%s - failed to set AGC PREDIC  MODE\n", __func__);
		return ret;
	}

#endif
	/*gain set*/
	AMS_SET_STEP0_ALS_GAIN0(128000, ret);
	AMS_SET_STEP0_ALS_GAIN1(128000, ret);
	AMS_SET_STEP0_ALS_GAIN2(128000, ret);
	AMS_SET_STEP1_ALS_GAIN0(128000, ret);
	AMS_SET_STEP1_ALS_GAIN1(128000, ret);
	AMS_SET_STEP1_ALS_GAIN2(128000, ret);

	// SET AGC MAX GAIN
	AMS_SET_AGC_MAX_GAIN(AMS_AGC_MAX_GAIN, ret);
	if (ret < 0) {
		ALS_err("%s - failed to set SET AGC MAX GAIN\n", __func__);
		return ret;
	}

	// AGC Number of samples
	AMS_SET_AGC_NR_SAMPLES(0, ret);//agc off
	if (ret < 0) {
		ALS_err("%s - failed to set AGC Number of samples\n", __func__);
		return ret;
	}
	//ams_setByte(ctx->portHndl, DEVREG_AGC_NR_SAMPLES_LO, 0x13);

	/* ams_setField(ctx->portHndl,
	 *DEVREG_MEAS_MODE0,
	 *HIGH,
	 *0x20);
	 */

	ams_setField(ctx->portHndl,
			DEVREG_SIEN,
			HIGH,
			TSL2511_MASK_SIEN_MEASUREMENT_SEQUENCER | TSL2511_MASK_SIEN_VSYNC);

	//ctx->adc_max = (AMS_SAMPLING_TIME+1)*16*32;                             /*sw_agc*/
	ctx->adc_max = (AMS_SAMPLING_TIME+1)*16; //12544
	ctx->adc_max_high_thresh = (ctx->adc_max*AMS_TSL2511_ADC_HIGH_THRESH)/100;    /*sw_agc*/
	ctx->adc_max_near_high_thresh = (ctx->adc_max*AMS_TSL2511_ADC_NEAR_HIGH_THRESH)/100;
	ctx->adc_max_low_thresh = (ctx->adc_max*AMS_TSL2511_ADC_LOW_THRESH)/100;      /*sw_agc*/
	ctx->adc_max_mid_thresh = (ctx->adc_max*AMS_TSL2511_ADC_MID_THRESH)/100;      /*sw_agc*/

	ccbCtx->flicker_data_cnt = 0;
	ctx->hamming_status = true;
	memset(&ccbCtx->flicker_data[0], 0, (sizeof(uint16_t)*AMS_FFT_SIZE));
	ccbCtx->data_ready = 0;
	ccbCtx->gain = 0;
	ctx->internal_clock_once = false;
	ctx->flickerCtx.max_samples.y_max =0;
	ctx->flickerCtx.max_samples.ir_max =0;
	ctx->flickerCtx.max_samples.uva_max =0;
	ctx->flickerCtx.max_samples.bk_max =0;
	return ret;
}

static void ccb_alsInfo(ams_ccb_als_info_t *infoData)
{
	if (infoData != NULL) {
		infoData->algName = "ALS";
		infoData->contextMemSize = sizeof(ams_ccb_als_ctx_t);
		infoData->scratchMemSize = 0;
		infoData->defaultCalibrationData.calibrationFactor = 1000;
		als_getDefaultCalibrationData(&infoData->defaultCalibrationData);
	}
}

static void ccb_alsSetConfig(void *dcbCtx, ams_ccb_als_config_t *configData)
{
	ams_ccb_als_ctx_t *ccbCtx = &((ams_deviceCtx_t *)dcbCtx)->ccbAlsCtx;

	ccbCtx->initData.configData.threshold = configData->threshold;
}

#define MAX_FIFO_LEN (1024)
#define SIGMA 3

//static uint16_t flicker_data[AMS_FFT_SIZE];
static uint8_t fifodata[MAX_FIFO_LEN];
static uint16_t fifo_chan_0_buf[AMS_FLICKER_NUM_SAMPLES<<1];
static uint16_t fifo_chan_1_buf[AMS_FLICKER_NUM_SAMPLES<<1];
static uint16_t fifo_chan_2_buf[AMS_FLICKER_NUM_SAMPLES<<1];

#define NUM_SAMPLE_BYTES (AMS_FFT_SIZE*2)

static uint32_t calc_average(uint32_t *buffer, int count)
{
	uint32_t sum = 0;
	int i;
	uint16_t average = 0;

	if ((NULL != buffer) && (count > 0))
	{
		for (i = 0; i < count; i++)
		{
			sum += buffer[i];
		}
		average = sum / count;
	}
	return average;
}

#define TSL2511_THD_CLEAR      1800LL    /* 1.8 * 1000 */
#define TSL2511_THD_RATIO      3LL       /* 0.003 * 1000 */
#define TSL2511_GAIN_MAX       4096LL    /* 4096 */
#define TSL2511_THD_RATIO_AUTO 1000LL       /*  */

#define MAX_NUM_FLICKER_SAMPLE_BYTES (12032) //bytes
#define MAX_NUM_FLICKER_TOTAL_SAMPLES (MAX_NUM_FLICKER_SAMPLE_BYTES/2)

#define MAX_GAIN_SAMPLES (31 * 2)

static uint64_t calc_thd(uint16_t clear_avg_fifo, uint32_t clear_avg, uint32_t *fft_out_data)
{
	uint64_t threshold;
	uint64_t ratio_fixed;
	uint64_t ratio_final;

	if (clear_avg_fifo <= 1) {
		ratio_fixed = (TSL2511_THD_CLEAR * TSL2511_GAIN_MAX);
	} else {
		if (clear_avg){
#ifndef AMS_BUILD
			ratio_fixed = (TSL2511_THD_CLEAR << 7)/ clear_avg; // clear_avg left-shifted 7.
#else
			ratio_fixed = div_u64((TSL2511_THD_CLEAR << 7), clear_avg); // clear_avg left-shifted 7.
#endif
		} else {
			ratio_fixed = (TSL2511_THD_CLEAR << 7); // clear_avg left-shifted 7.
		}
	}

	if ((TSL2511_THD_RATIO_AUTO) > ratio_fixed) {
		ratio_final = TSL2511_THD_RATIO_AUTO;
	} else {
		ratio_final = ratio_fixed;
	}
#ifndef AMS_BUILD
	threshold = ((uint64_t)fft_out_data[0] * ratio_final * TSL2511_THD_RATIO)/1000000;
#else
    threshold = div_u64((uint64_t)fft_out_data[0] * ratio_final * TSL2511_THD_RATIO, 1000000);
#endif
	ALS_info("calc_thd threshold = %lld, fifoout[0] %d, ratio_final %lld \n", threshold, fft_out_data[0], ratio_final);
	return threshold;
}

static uint8_t fifo_out_data[AMS_FFT_SIZE*2]; //1024samsples 2bytes = 2048bytes or 2048samples * 2byte = 4096bytes

static void parse_fifo_end_data(ams_deviceCtx_t * ctx, int fifo_end_len, uint8_t *fifo_end_data)
{
	int gain_index = 0;
	int checksum_index = 0;
	uint16_t tmp;

	/* Determine the index for the various end data */
	if ((true == ctx->has_fifo_fd_end_marker) &&
		(true == ctx->has_fifo_fd_checksum) &&
		(true == ctx->has_fifo_fd_gain))
	{
		checksum_index = 3;
		gain_index = 5;
	}
	else if ((true == ctx->has_fifo_fd_end_marker) &&
		(false == ctx->has_fifo_fd_checksum) &&
		(true == ctx->has_fifo_fd_gain))
	{
		checksum_index = 0;
		gain_index = 3;
	}
	else if ((true == ctx->has_fifo_fd_end_marker) &&
		(true == ctx->has_fifo_fd_checksum) &&
		(false == ctx->has_fifo_fd_gain))
	{
		checksum_index = 3;
		gain_index = 0;
	}
	else if ((false == ctx->has_fifo_fd_end_marker) &&
		(true == ctx->has_fifo_fd_checksum) &&
		(true == ctx->has_fifo_fd_gain))
	{
		checksum_index = 0;
		gain_index = 2;
	}
	else if ((false == ctx->has_fifo_fd_end_marker) &&
		(false == ctx->has_fifo_fd_checksum) &&
		(true == ctx->has_fifo_fd_gain))
	{
		checksum_index = 0;
		gain_index = 0;
	}
	else if ((false == ctx->has_fifo_fd_end_marker) &&
		(true == ctx->has_fifo_fd_checksum) &&
		(false == ctx->has_fifo_fd_gain))
	{
		checksum_index = 0;
		gain_index = 0;
	}


	/* Parse the data */
	/* Data is written to the fifo in little endian, byte swap is required */
	if (true == ctx->has_fifo_fd_checksum)
	{
		tmp = ((fifo_end_data[checksum_index + 1] << 8) | fifo_end_data[checksum_index]);
		ctx->fifo_checksum = tmp;
	}

	if (true == ctx->has_fifo_fd_gain)
	{
		tmp = ((fifo_end_data[gain_index + 1] << 8) | fifo_end_data[gain_index]);

		/* After the byte swap the gain data is like so
		 *
		 *                       Bits
		 *      15-12       11-8        7-4          3-0
		 *  -------------------------------------------------
		 * |  not used | mod2 gain | mod1 gain  | mod0 gain  |
		 *  -------------------------------------------------
		 *
		 */
		ctx->fifo_mod0_gain = tmp & 0x0F;
		ctx->fifo_mod1_gain = (tmp >> 4) & 0x0F;
		ctx->fifo_mod2_gain = (tmp >> 8) & 0x0F;
	}
	ALS_info("gain 0 = 0x%x , 0x%x, 0x%x ",ctx->fifo_mod0_gain,ctx->fifo_mod1_gain,ctx->fifo_mod2_gain);
}

ssize_t read_fifo(ams_deviceCtx_t * ctx , uint16_t *buf, int size)
{
	int len;
	int kfifo_Len;
	int i =0,j =0 ;
	uint16_t tmp =0;

	memset(fifo_out_data, 0x0, sizeof(fifo_out_data));

	kfifo_Len =  kfifo_len(&ams_fifo);

	if(kfifo_Len >=size){ //512

		/*len = kfifo_out_peek(&ams_fifo,fifo_out_data,size);
		 *print_hex_dump_bytes("out_peek : ", DUMP_PREFIX_NONE, fifo_out_data, size);
		 *ALS_info("out_peek : \n\n");
		 */

		//memset(fifo_out_data, 0x0, sizeof(fifo_out_data));

		len = kfifo_out(&ams_fifo,fifo_out_data,size);
		/* byte swap flicker data*/
		for (i = 0, j = 0; i < size; i+=2, j++) {
			tmp = ((fifo_out_data[i + 1] << 8) | fifo_out_data[i]); //256
			buf[j] = tmp;
			//ALS_info("buf[%d]=%d ", j,buf[j]);
			//if((buf[j]==0) && (buf[j+1]==0) && (buf[j+2]==0) && (buf[j+3]==0) && (buf[j+4]==0) && (buf[j+5]==0)){
			//	ALS_info("BUG ON = %d , j=  %d",i,j);
			//BUG();
			//}

		}

		//print_hex_dump_bytes("out : ", DUMP_PREFIX_NONE, fifo_out_data, size);
		ALS_info("out : \n\n");

		//parse_fifo_end_data(ctx);

	} else {
		len = 0;
	}
	ALS_info("read_fifo read size  %d , kfifo_Len =%d\n",len,kfifo_Len);
	return len;
}


#define CHANEL 3 //(Photopic, IR, UVA)
#undef AMS_DEBUG
int get_fft(ams_deviceCtx_t * ctx , uint32_t *out)
{
	static uint16_t buffer[AMS_FFT_SIZE];
	static uint32_t clear_buffer[AMS_FFT_SIZE] = { 0 };
	uint16_t gain_buffer[MAX_GAIN_SAMPLES] = { 0 };
	ssize_t size = 0;
	int i ,j =0 ;
	uint16_t clear_gain , wideband_gain = 0;
	uint8_t fifo_gain0[1] = { 0 }, fifo_gain1[1] = { 0 };
	uint8_t fifo_gain2[1] = { 0 };
	uint16_t uv_gain;
	int ret = 0;
	uint16_t tmp_gain = 0;
	uint16_t idx = 0;
	uint16_t idx_new = 0;
	uint16_t k = 0;
	uint16_t idx_32 = 0;

	memset(clear_buffer, 0, sizeof(clear_buffer));
	memset(buffer,0, sizeof(buffer));

	//total samples, 1024samples for 6016 bytes or  2048 samples for 12032 bytes
	//size = read_fifo(ctx,buffer,ctx->flicker_num_samples);
	size = read_fifo(ctx, buffer, AMS_FFT_SIZE * 2); //total samples 2048 samples for 4096bytes

	kfifo_reset(&ams_fifo);
	AMS_FIFO_CLEAR(ret);
	ctx->mod1_step_counter = 0;
	/**************************copy kfifo to clear buffer for FFT******/

	for (j = 0; j < AMS_FFT_SIZE;  j++) {
		out[j] = clear_buffer[j] = buffer[j];
		ALS_info("clear[%d] = %d ", j, clear_buffer[j]);
	}

	FFT(out, AMS_FFT_SIZE);

	for (j = 0; j < 512; j++) { // 2048Hz SPL, 1024ea --> 512 valid data, for TSL2511
		out[j] = (uint32_t)(((uint64_t)out[j] * (uint64_t)fft_mask[j]) >> 10);
	}

/*****************************************************************/
	return 1;
}
uint8_t ams_tsl2511_predict_gain(uint32_t ratio, uint8_t pre_gain)
{
	int idx;
	uint8_t gain_inc = 0;

	for(idx = 12; idx > 0; idx--){
		if(ratio > tsl2511_gain_predict[idx]){
			gain_inc = pre_gain + idx;
			return gain_inc;
		}
	}
	return pre_gain;
}



#if 0
void ams_tsl2511_auto_gain(void * dcbCtx)
{
	ams_deviceCtx_t * ctx = (ams_deviceCtx_t*)dcbCtx;
	struct tsl2511_device_data *data = i2c_get_clientdata(ctx->portHndl);

	uint8_t  new_gain;
	uint32_t ratio;
	/* Y channel 0 data */
	bool update = false;

	ALS_info(  "%s: Y_raw_data %ld , gain 0x%x\n", __func__, ctx->flickerCtx.als_raw_data.y,ctx->flickerCtx.als_raw_data.y_gain);
	ALS_info(  "%s: ir_raw_data %ld , gain 0x%x\n", __func__, ctx->flickerCtx.als_raw_data.ir,ctx->flickerCtx.als_raw_data.ir_gain);
	ALS_info(  "%s: bk_raw_data %ld , gain 0x%x\n", __func__, ctx->flickerCtx.als_raw_data.bk,ctx->flickerCtx.als_raw_data.bk_gain);
	ALS_info(  "%s: uv_raw_data %ld , gain 0x%x\n", __func__, ctx->flickerCtx.als_raw_data.uva,ctx->flickerCtx.als_raw_data.uva_gain);

	ALS_info(  "%s: Y chip->adc_max_high_thresh %d\n", __func__, ctx->adc_max_high_thresh);
	ALS_info(  "%s: Y chip->adc_max_near_high_thresh %d\n", __func__, ctx->adc_max_near_high_thresh);
	ALS_info(  "%s: Y chip->adc_max_mid_thresh %d\n", __func__, ctx->adc_max_mid_thresh);
	ALS_info(  "%s: Y chip->adc_max_low_thresh %d\n", __func__, ctx->adc_max_low_thresh);
	ALS_info(  "%s: saturation %d \n\n", __func__, data->saturation);

	if ((ctx->shadowStatus2Reg & TSL2511_REG_STATUS2__MOD0_ASAT__MASK) || (data->saturation == true)) {
        update = false;
        if(ctx->flickerCtx.als_raw_data.y_gain > AMS_TSL2511_Y_MIN_GAIN){
			if(ctx->flickerCtx.als_raw_data.y_gain > AMS_TSL2511_Y_MIN_GAIN + STEP_DOWN){ // 13 > gain > 4 , step down 3
				new_gain = ctx->flickerCtx.als_raw_data.y_gain - STEP_DOWN; // 3 step down
			}else{ //3 > gain >=0 , step down 1
				new_gain = ctx->flickerCtx.als_raw_data.y_gain - 1;
			}
			update = true;
		} else {
				ALS_info( "%s: Y gain reach minimum\n", __func__);
		}

		if(update){
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, new_gain ,0xF );
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L, new_gain ,0xF );
			ALS_info( "%s: Y gain decrease to %d\n", __func__, new_gain);
		}
	}else if((ctx->flickerCtx.als_raw_data.y > ctx->adc_max_high_thresh) ) {
		if ((ctx->flickerCtx.als_raw_data.y_gain > AMS_TSL2511_Y_MIN_GAIN )) {
			if (ctx->flickerCtx.als_raw_data.y_gain > AMS_TSL2511_Y_MIN_GAIN + STEP_DOWN) { // 13 > gain > 4 , step down 3
				new_gain = ctx->flickerCtx.als_raw_data.y_gain - STEP_DOWN; // 3 step down
			} else { //3 > gain >=0 , step down 1
				new_gain = ctx->flickerCtx.als_raw_data.y_gain - 1;
			}
				ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, new_gain, 0xF);
				ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L, new_gain, 0xF);
				ALS_info( "%s: Y gain decrease , new_gain %d \n", __func__,new_gain);
	}else {
		ALS_info( "%s: Y gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.y_gain);
	}

	} else if(ctx->flickerCtx.als_raw_data.y< ctx->adc_max_low_thresh) {
		if (ctx->flickerCtx.als_raw_data.y_gain < AMS_TSL2511_Y_MAX_GAIN) {
			new_gain = ctx->flickerCtx.als_raw_data.y_gain + 1;

			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, new_gain, 0xF);
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L, new_gain, 0xF);
			ALS_info(  "%s: Y gain increase to %d\n", __func__, new_gain);
		}else{
			ALS_info(  "%s: Y gain already maximum\n", __func__);
		}
	}
	/* UVA channel 2 data */

	if ((ctx->shadowStatus2Reg  & TSL2511_REG_STATUS2__MOD2_ASAT__MASK)  || (data->saturation == true)) {
		update = false;
		if ((ctx->flickerCtx.als_raw_data.uva_gain > AMS_TSL2511_UVA_MIN_GAIN)) {
			if(ctx->flickerCtx.als_raw_data.uva_gain > AMS_TSL2511_UVA_MIN_GAIN + STEP_DOWN){ // 13 > gain > 4 , step down 3
				new_gain = ctx->flickerCtx.als_raw_data.uva_gain - STEP_DOWN; // 3 step down
			}else{ //3 > gain >=0 , step down 1
				new_gain = ctx->flickerCtx.als_raw_data.uva_gain - 1;
			}
			update = true;
		} else {
					ALS_info( "%s: UVA gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.uva_gain);
		}

		if (update) {
			ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_H, new_gain,0xF);
			ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_H, new_gain,0xF);
			ALS_info( "%s: UV gain decrease to %d\n", __func__, new_gain);
		}
	}
	else if(ctx->flickerCtx.als_raw_data.uva > ctx->adc_max_high_thresh) {
		if ((ctx->flickerCtx.als_raw_data.uva_gain > AMS_TSL2511_UVA_MIN_GAIN)) {
			if(ctx->flickerCtx.als_raw_data.uva_gain > AMS_TSL2511_UVA_MIN_GAIN + STEP_DOWN){ // 13 > gain > 4 , step down 3
				new_gain = ctx->flickerCtx.als_raw_data.uva_gain - STEP_DOWN; // 3 step down
			} else { //3 > gain >=0 , step down 1
				new_gain = ctx->flickerCtx.als_raw_data.uva_gain - 1;
			}
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_H, new_gain,0xF);
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_H, new_gain,0xF);
			ALS_info( "%s: UVA gain decrease , new_gain %d \n", __func__,new_gain);
		}else {
			ALS_info(  "%s: UVA gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.uva_gain);
		}
	} else if(ctx->flickerCtx.als_raw_data.uva < ctx->adc_max_low_thresh) {
		if(ctx->flickerCtx.als_raw_data.uva_gain < AMS_TSL2511_UVA_MAX_GAIN) {
			new_gain = ctx->flickerCtx.als_raw_data.uva_gain + 1;

			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_H, new_gain,0xF);
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_H, new_gain,0xF);
			ALS_info(  "%s: UV gain increase to %d\n", __func__, new_gain);
		} else {
			ALS_info(  "%s: UV gain already maximum\n", __func__);
		}

	}
	/* IR mod 1 step 0 */
	if ((ctx->shadowStatus2Reg  & TSL2511_REG_STATUS2__MOD1_ASAT__SHIFT) || (data->saturation == true)) {
		//if (ctx->flickerCtx.als_raw_data.ir > ctx->adc_max_near_high_thresh) {
			if (ctx->flickerCtx.als_raw_data.ir_gain > AMS_TSL2511_IR_MIN_GAIN ) {
				if(ctx->flickerCtx.als_raw_data.ir_gain > AMS_TSL2511_IR_MIN_GAIN + STEP_DOWN){ // 13 > gain > 4 , step down 3
					new_gain = ctx->flickerCtx.als_raw_data.ir_gain - STEP_DOWN; // 3 step down
				} else{ //3 > gain >=0 , step down 1
					new_gain = ctx->flickerCtx.als_raw_data.ir_gain - 1;
				}

				ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L,  new_gain<<4, 0xF0);
		ALS_info( "%s: IR gain decrease , new_gain %d \n", __func__,new_gain);
			}else {
				ALS_info(  "%s: IR gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.ir_gain);
			}
		//}
	} else if( ctx->flickerCtx.als_raw_data.ir > ctx->adc_max_high_thresh) {
		if((ctx->flickerCtx.als_raw_data.ir_gain > AMS_TSL2511_IR_MIN_GAIN)){
			if(ctx->flickerCtx.als_raw_data.ir_gain > AMS_TSL2511_IR_MIN_GAIN + STEP_DOWN){ // 13 > gain > 4 , step down 3
				new_gain = ctx->flickerCtx.als_raw_data.ir_gain - STEP_DOWN; // 3 step down
			}else{ //3 > gain >=0 , step down 1
				new_gain = ctx->flickerCtx.als_raw_data.ir_gain - 1;
			}
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L,  new_gain<<4,0xF0);
			ALS_info( "%s: IR gain decrease , new_gain %d \n", __func__,new_gain);
		} else {
			ALS_info(  "%s: IR gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.ir_gain);
		}
	} else if(ctx->flickerCtx.als_raw_data.ir < ctx->adc_max_low_thresh) {
		if(ctx->flickerCtx.als_raw_data.ir_gain < AMS_TSL2511_IR_MAX_GAIN){
			new_gain = ctx->flickerCtx.als_raw_data.ir_gain + 1;

			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, new_gain<<4,0xF0);
			ALS_info(  "%s: IR gain increase to %d\n", __func__, new_gain);
		}else{
			ALS_info(  "%s: IR gain already maximum\n", __func__);
		}
	}

	/* bk mod 1 step 1 */
	if ((ctx->shadowStatus2Reg  & TSL2511_REG_STATUS2__MOD1_ASAT__SHIFT)  || (data->saturation == true)) {
		//if (ctx->flickerCtx.als_raw_data.bk > ctx->adc_max_near_high_thresh) {
			if ((ctx->flickerCtx.als_raw_data.bk_gain > AMS_TSL2511_BK_MIN_GAIN)) {
			 if (ctx->flickerCtx.als_raw_data.bk_gain > AMS_TSL2511_BK_MIN_GAIN + 3) { // 13 > gain > 4 , step down 3
					new_gain = ctx->flickerCtx.als_raw_data.bk_gain - STEP_DOWN;
				} else { //3 > gain >=0 , step down 1
					new_gain = ctx->flickerCtx.als_raw_data.bk_gain - 1;
				}
				ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L, new_gain<<4,0xF0);
				ALS_info( "%s: BK gain decrease , new_gain %d \n", __func__,new_gain);
			} else {
				ALS_info(  "%s: BK gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.bk_gain);
			}
		//}
	} else  if(ctx->flickerCtx.als_raw_data.bk > ctx->adc_max_high_thresh) {
		if ((ctx->flickerCtx.als_raw_data.bk_gain > AMS_TSL2511_BK_MIN_GAIN)) {
			if (ctx->flickerCtx.als_raw_data.bk_gain > AMS_TSL2511_BK_MIN_GAIN + 3){ // 13 > gain > 4 , step down 3
				new_gain = ctx->flickerCtx.als_raw_data.bk_gain - STEP_DOWN;
			} else { //3 > gain >=0 , step down 1
				new_gain = ctx->flickerCtx.als_raw_data.bk_gain - 1;
			}
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L, new_gain<<4,0xF0);
			ALS_info( "%s: BK gain decrease , new_gain %d \n", __func__,new_gain);
		} else {
			ALS_info(  "%s: BK gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.bk_gain);
		}

	} else if(ctx->flickerCtx.als_raw_data.bk < ctx->adc_max_low_thresh) {
		if(ctx->flickerCtx.als_raw_data.bk_gain < AMS_TSL2511_BK_MAX_GAIN){
		new_gain = ctx->flickerCtx.als_raw_data.bk_gain + 1;

		ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L,  new_gain<<4,0xF0);
		ALS_info(  "%s: BK gain increase to %d\n", __func__, new_gain);
	}else{
		ALS_info( "%s: BK gain already maximum\n", __func__);

	}
	ALS_info( "%s: \n", __func__);
	ALS_info( "%s: \n", __func__);

}

#else
bool ams_tsl2511_auto_gain_max_samples(void *dcbCtx)
{
	ams_deviceCtx_t * ctx = (ams_deviceCtx_t*)dcbCtx;
	struct tsl2511_device_data *data = i2c_get_clientdata(ctx->portHndl);

	uint8_t  new_gain;
	uint32_t ratio;
	/* Y channel 0 data */
	bool update = true;

	if (data->eol_enabled == true) {
		update = false;
		ALS_info("%s:No update = %d  during eol \n", __func__, update);
		return update;
	}

	ALS_info(  "%s: Y_raw_data %ld , gain 0x%x\n", __func__, ctx->flickerCtx.max_samples.y_max,ctx->flickerCtx.als_raw_data.y_gain);
	ALS_info(  "%s: ir_raw_data %ld , gain 0x%x\n", __func__, ctx->flickerCtx.max_samples.ir_max,ctx->flickerCtx.als_raw_data.ir_gain);
	ALS_info(  "%s: bk_raw_data %ld , gain 0x%x\n", __func__, ctx->flickerCtx.max_samples.bk_max,ctx->flickerCtx.als_raw_data.bk_gain);
	ALS_info(  "%s: uv_raw_data %ld , gain 0x%x\n", __func__, ctx->flickerCtx.max_samples.uva_max,ctx->flickerCtx.als_raw_data.uva_gain);

	ALS_info(  "%s: Y chip->adc_max_high_thresh %d\n", __func__, ctx->adc_max_high_thresh);
	ALS_info(  "%s: Y chip->adc_max_near_high_thresh %d\n", __func__, ctx->adc_max_near_high_thresh);
	ALS_info(  "%s: Y chip->adc_max_mid_thresh %d\n", __func__, ctx->adc_max_mid_thresh);
	ALS_info(  "%s: Y chip->adc_max_low_thresh %d\n", __func__, ctx->adc_max_low_thresh);
	ALS_info(  "%s: saturation %d \n\n", __func__, data->saturation);
#if 0 //don't need to check data->saturation
	if((ctx->shadowStatus2Reg & TSL2511_REG_STATUS2__MOD0_ASAT__MASK) || (data->saturation == true)){
	update = false;
	if(ctx->flickerCtx.als_raw_data.y_gain > AMS_TSL2511_Y_MIN_GAIN){
			if(ctx->flickerCtx.als_raw_data.y_gain > AMS_TSL2511_Y_MIN_GAIN + STEP_DOWN){ // 13 > gain > 4 , step down 3
				new_gain = ctx->flickerCtx.als_raw_data.y_gain - STEP_DOWN; // 3 step down
			}else{ //3 > gain >=0 , step down 1
				new_gain = ctx->flickerCtx.als_raw_data.y_gain - 1;
			}
			update = true;
		}else {
				ALS_info( "%s: Y gain reach minimum\n", __func__);
		}

		if(update){
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, new_gain ,0xF );
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L, new_gain ,0xF );
			ALS_info( "%s: Y gain decrease to %d\n", __func__, new_gain);
		}
	}else
#endif
	if ((ctx->flickerCtx.max_samples.y_max > ctx->adc_max_high_thresh)) {
		if ((ctx->flickerCtx.als_raw_data.y_gain > AMS_TSL2511_Y_MIN_GAIN )){
			if (ctx->flickerCtx.als_raw_data.y_gain > AMS_TSL2511_Y_MIN_GAIN + STEP_DOWN) { // 13 > gain > 4 , step down 3
				new_gain = ctx->flickerCtx.als_raw_data.y_gain - STEP_DOWN; // 3 step down
			} else{ //3 > gain >=0 , step down 1
				new_gain = ctx->flickerCtx.als_raw_data.y_gain - 1;
			}
				ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, new_gain, 0xF);
				ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L, new_gain, 0xF);
				ALS_info( "%s: Y gain decrease , new_gain %d \n", __func__,new_gain);
		} else {
			ALS_info( "%s: Y gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.y_gain);
		}

	} else if (ctx->flickerCtx.max_samples.y_max < ctx->adc_max_low_thresh) {
		if(ctx->flickerCtx.als_raw_data.y_gain < AMS_TSL2511_Y_MAX_GAIN){
			new_gain = ctx->flickerCtx.als_raw_data.y_gain + 1;

			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, new_gain, 0xF);
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L, new_gain, 0xF);
			ALS_info(  "%s: Y gain increase to %d\n", __func__, new_gain);
		} else {
			ALS_info(  "%s: Y gain already maximum\n", __func__);
		}
	}

/* UVA channel 2 data */
#if 0 //don't need to check data->saturation
if((ctx->shadowStatus2Reg  & TSL2511_REG_STATUS2__MOD2_ASAT__MASK)  || (data->saturation == true)) {
	update = false;
		if((ctx->flickerCtx.als_raw_data.uva_gain > AMS_TSL2511_UVA_MIN_GAIN) ){
			if(ctx->flickerCtx.als_raw_data.uva_gain > AMS_TSL2511_UVA_MIN_GAIN + STEP_DOWN){ // 13 > gain > 4 , step down 3
				new_gain = ctx->flickerCtx.als_raw_data.uva_gain - STEP_DOWN; // 3 step down
			}else{ //3 > gain >=0 , step down 1
				new_gain = ctx->flickerCtx.als_raw_data.uva_gain - 1;
			}
			update = true;
		}else{
					ALS_info( "%s: UVA gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.uva_gain);
		}

		if(update){
			ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_H, new_gain,0xF);
			ams_setField(ctx->portHndl, DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_H, new_gain,0xF);
			ALS_info( "%s: UV gain decrease to %d\n", __func__, new_gain);
		}
	}
	else
#endif
	if (ctx->flickerCtx.max_samples.uva_max > ctx->adc_max_high_thresh) {
	if ((ctx->flickerCtx.als_raw_data.uva_gain > AMS_TSL2511_UVA_MIN_GAIN)) {
			if(ctx->flickerCtx.als_raw_data.uva_gain > AMS_TSL2511_UVA_MIN_GAIN + STEP_DOWN){ // 13 > gain > 4 , step down 3
				new_gain = ctx->flickerCtx.als_raw_data.uva_gain - STEP_DOWN; // 3 step down
			} else { //3 > gain >=0 , step down 1
				new_gain = ctx->flickerCtx.als_raw_data.uva_gain - 1;
			}
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_H, new_gain,0xF);
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_H, new_gain,0xF);
			ALS_info( "%s: UVA gain decrease , new_gain %d \n", __func__,new_gain);
		} else {
			ALS_info(  "%s: UVA gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.uva_gain);
		}
	} else if(ctx->flickerCtx.max_samples.uva_max < ctx->adc_max_low_thresh) {
		if(ctx->flickerCtx.als_raw_data.uva_gain < AMS_TSL2511_UVA_MAX_GAIN){
			new_gain = ctx->flickerCtx.als_raw_data.uva_gain + 1;
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_H, new_gain,0xF);
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_H, new_gain,0xF);
			ALS_info(  "%s: UV gain increase to %d\n", __func__, new_gain);
		} else {
			ALS_info(  "%s: UV gain already maximum\n", __func__);
		}
	}
	/* IR mod 1 step 0 */
#if 0 //don't need to check data->saturation
	if((ctx->shadowStatus2Reg  & TSL2511_REG_STATUS2__MOD1_ASAT__SHIFT) || (data->saturation == true)) {
		//if(ctx->flickerCtx.als_raw_data.ir > ctx->adc_max_near_high_thresh){
			if(ctx->flickerCtx.als_raw_data.ir_gain > AMS_TSL2511_IR_MIN_GAIN ){
				if(ctx->flickerCtx.als_raw_data.ir_gain > AMS_TSL2511_IR_MIN_GAIN + STEP_DOWN){ // 13 > gain > 4 , step down 3
					new_gain = ctx->flickerCtx.als_raw_data.ir_gain - STEP_DOWN; // 3 step down
				}else{ //3 > gain >=0 , step down 1
					new_gain = ctx->flickerCtx.als_raw_data.ir_gain - 1;
				}

				ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L,  new_gain<<4, 0xF0);
		ALS_info( "%s: IR gain decrease , new_gain %d \n", __func__,new_gain);
			}else {
				ALS_info(  "%s: IR gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.ir_gain);
		}
		//}
	}else
#endif
	if( ctx->flickerCtx.max_samples.ir_max > ctx->adc_max_high_thresh) {
        if((ctx->flickerCtx.als_raw_data.ir_gain > AMS_TSL2511_IR_MIN_GAIN)){
			if(ctx->flickerCtx.als_raw_data.ir_gain > AMS_TSL2511_IR_MIN_GAIN + STEP_DOWN){ // 13 > gain > 4 , step down 3
				new_gain = ctx->flickerCtx.als_raw_data.ir_gain - STEP_DOWN; // 3 step down
			}else{ //3 > gain >=0 , step down 1
				new_gain = ctx->flickerCtx.als_raw_data.ir_gain - 1;
			}
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L,  new_gain<<4,0xF0);
			ALS_info( "%s: IR gain decrease , new_gain %d \n", __func__,new_gain);
		} else {
			ALS_info(  "%s: IR gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.ir_gain);
		}
	} else if(ctx->flickerCtx.max_samples.ir_max < ctx->adc_max_low_thresh) {
		if(ctx->flickerCtx.als_raw_data.ir_gain < AMS_TSL2511_IR_MAX_GAIN){
			new_gain = ctx->flickerCtx.als_raw_data.ir_gain + 1;
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, new_gain<<4,0xF0);
			ALS_info(  "%s: IR gain increase to %d\n", __func__, new_gain);
		}else{
			ALS_info(  "%s: IR gain already maximum\n", __func__);
		}
	}
	/* bk mod 1 step 1 */
#if 0 //don't need to check data->saturation
	if((ctx->shadowStatus2Reg  & TSL2511_REG_STATUS2__MOD1_ASAT__SHIFT)  || (data->saturation == true)) {
		//if(ctx->flickerCtx.als_raw_data.bk > ctx->adc_max_near_high_thresh){
			if((ctx->flickerCtx.als_raw_data.bk_gain > AMS_TSL2511_BK_MIN_GAIN)){
				if(ctx->flickerCtx.als_raw_data.bk_gain > AMS_TSL2511_BK_MIN_GAIN + STEP_DOWN){ // 13 > gain > 4 , step down 3
					new_gain = ctx->flickerCtx.als_raw_data.bk_gain - STEP_DOWN;
				}else { //3 > gain >=0 , step down 1
					new_gain = ctx->flickerCtx.als_raw_data.bk_gain - 1;
				}
				ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L, new_gain<<4,0xF0);
				ALS_info( "%s: BK gain decrease , new_gain %d \n", __func__,new_gain);
			}else {
				ALS_info(  "%s: BK gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.bk_gain);
			}
		//}
	}else
#endif
	if (ctx->flickerCtx.max_samples.bk_max > ctx->adc_max_high_thresh) {
		if ((ctx->flickerCtx.als_raw_data.bk_gain > AMS_TSL2511_BK_MIN_GAIN)) {
			if (ctx->flickerCtx.als_raw_data.bk_gain > AMS_TSL2511_BK_MIN_GAIN + STEP_DOWN){ // 13 > gain > 4 , step down 3
				new_gain = ctx->flickerCtx.als_raw_data.bk_gain - STEP_DOWN;
			} else { //3 > gain >=0 , step down 1
				new_gain = ctx->flickerCtx.als_raw_data.bk_gain - 1;
			}
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L, new_gain<<4,0xF0);
			ALS_info( "%s: BK gain decrease , new_gain %d \n", __func__,new_gain);
		} else {
			ALS_info(  "%s: BK gain reach minimum gain %d \n", __func__,ctx->flickerCtx.als_raw_data.bk_gain);
		}
	} else if(ctx->flickerCtx.max_samples.bk_max < ctx->adc_max_low_thresh) {
		if (ctx->flickerCtx.als_raw_data.bk_gain < AMS_TSL2511_BK_MAX_GAIN){
			new_gain = ctx->flickerCtx.als_raw_data.bk_gain + 1;
			ams_setField(ctx->portHndl,  DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L,  new_gain<<4,0xF0);
			ALS_info(  "%s: BK gain increase to %d\n", __func__, new_gain);
		} else {
			ALS_info( "%s: BK gain already maximum\n", __func__);

		}
		ALS_info( "%s: \n", __func__);
		ALS_info( "%s: \n", __func__);
	}
	return update;
}
#endif

bool  ccb_sw_bin4096_flicker_GetResult(void * dcbCtx);
bool  ccb_sw_bin4096_flicker_GetResult(void * dcbCtx)
{
	ams_deviceCtx_t * ctx = (ams_deviceCtx_t*)dcbCtx;
	static uint32_t buf[AMS_FFT_SIZE] = {0,};
	int max = -1;
	ams_flicker_ctx_t *ccbCtx = (ams_flicker_ctx_t *)&ctx->flickerCtx;
	//amsAlsDataSet_t inputData;
	//adcDataSet_t dataSet;
	//	int mean;
	//	int stdev;

	int i =0;
	uint16_t mHz = 9999;
	int sampling_freq;
	uint64_t thd =0;
	uint64_t average_thd = 0;
	uint64_t max_thd = 0;
	long long int ratio_thd = 0;
	uint resolution = DIV_ROUND_CLOSEST(1000000000, SAMPLING_TIME) / AMS_FFT_SIZE;
	uint min_freq = 70 / resolution;
	uint max_freq = 1000 / resolution;
	int imax = min_freq;
	uint64_t ratio_DC_max = 0;
	uint64_t ratio_max_avg = 0;
	//int  num_samples =ctx->flicker_num_samples;

	memset(buf,0,sizeof(buf));

	if(get_fft(ctx,buf)){
#if 1
		// get peak index
		for (i = min_freq; i <= max_freq; ++i) {	// 70~1000
			// ALS_err("ccb_sw_bin4096_flicker_GetResult: buf[%d]=%10u\n", i, buf[i]);
			if (buf[i] > buf[imax]) {
				imax = i;
			}
			average_thd += buf[i];	 // 29+10=39
		}
		average_thd /= (max_freq - min_freq + 1); // 29
		max_thd = buf[imax];   // 29
		ratio_thd = (uint32_t)((average_thd << 10) / max_thd);	 // 0+10-0, 0+10-29, 29+10-29

		ratio_DC_max = buf[0] / max_thd;
		ratio_max_avg = max_thd / average_thd;

		ALS_info("DEBUG_FLICKER DECISION_THD buf[%d]=%u, avg=%lld, max=%lld, DC=%lld, DC/max=%lld, max/avg=%lld", imax, buf[imax], average_thd, max_thd, buf[0], ratio_DC_max, ratio_max_avg);

		if (ratio_thd < FLICKER_AVGMAX_THD) {
			mHz = imax * resolution;
			ALS_info("flicker_freq %d\n", mHz);
		} else {
			mHz = 0;
			ALS_info("flicker_freq is zero\n");
		}

		ccbCtx->frequency = mHz;
#endif
		//ALS_info("flicker_freq is zero");
	}
	ctx->flickerCtx.data_ready = 0;

	return true;
}

#if 1

/*Recommendation value*/
#define K_coef 0
#define OFFSET 5
#define REF_GAIN 9 //2^9 = 512 gain
#define REF_GAIN_C_IR 5 //(2^4) gain
//#define REF_GAIN_BK_UV 2 //(2^7)  x  (2^2) = 2^9 = 512 gain

void get_als_data(ams_deviceCtx_t *ctx, uint32_t ch0_data, uint32_t ch1_data, uint32_t ch2_data ,uint16_t ch0_max, uint16_t ch1_max, uint16_t ch2_max)
{
	amsAlsContext_t *alsCtx = &(ctx->ccbAlsCtx.ctxAlgAls);
	struct tsl2511_device_data *data = i2c_get_clientdata(ctx->portHndl);

	adcDataSet_t dataSet;
	amsAlsDataSet_t inputData;
	bool als_data_process_en = false;
	uint64_t y_sum_norm = 0;
	uint64_t ir_sum_norm = 0;
	uint64_t uv_sum_norm = 0;
	uint64_t bk_sum_norm = 0;

	uint64_t sum_uv_minus_bk_bkCal = 0;
	uint64_t uv_sum_norm_uvCal = 0;
	uint64_t sum_bk_bkCal_uvCal = 0;

	uint64_t sum_ir_bkCal = 0;
	//int32_t uvmbk_bkCal = 0;
	uint64_t sum_bk_bkCal = 0;

	/* mod1 step 1 data --> bk, als named as UVWH,  */
	if (ctx->mod1_step_counter % 2) {
		ctx->flickerCtx.als_raw_data.y = ch0_data;
		ctx->flickerCtx.als_raw_data.y_max = ch0_max;
		//ctx->flickerCtx.als_raw_data.y_gain = ctx->fifo_mod0_gain;
		ctx->flickerCtx.als_raw_data.uva = ch2_data;
		ctx->flickerCtx.als_raw_data.uva_max = ch2_max;
		//ctx->flickerCtx.als_raw_data.uva_gain = ctx->fifo_mod2_gain;
		/* mod1 step 1 data --> bk, als named as UVWH,  */
		ctx->flickerCtx.als_raw_data.bk = ch1_data;
		ctx->flickerCtx.als_raw_data.bk_max = ch1_max;
		//ctx->flickerCtx.als_raw_data.bk_gain = ctx->fifo_mod1_gain;
		/* process als after one frame complete */
		if( ch0_max > ctx->flickerCtx.max_samples.y_max )
			ctx->flickerCtx.max_samples.y_max = ch0_max;

		if( ch2_max > ctx->flickerCtx.max_samples.uva_max )
			ctx->flickerCtx.max_samples.uva_max = ch2_max;

		if( ch1_max > ctx->flickerCtx.max_samples.bk_max )
			ctx->flickerCtx.max_samples.bk_max = ch1_max;
		als_data_process_en = true;
		ALS_info("%s: process_bk , c %d , bk %d, uv %d",__func__,ch0_data,ch1_data,ch2_data);
		ALS_info("%s: process_bk , c_max_1st %d, c_max_2nd %d, uv_max_1st %d , uv_max_2nd =%d ,bk_max_1st %d , bk_max_2nd =%d ",__func__,ctx->flickerCtx.max_samples.y_max,ch0_max,ctx->flickerCtx.max_samples.uva_max,ch2_max,ctx->flickerCtx.max_samples.bk_max ,ch1_max);
		ALS_info("%s: process_bk , gain0 0x%x ,gain1 0x%x, gain2 0x%x ",__func__,ctx->flickerCtx.als_raw_data.y_gain,ctx->flickerCtx.als_raw_data.bk_gain,ctx->flickerCtx.als_raw_data.uva_gain);
	}
	/* mod1 step 0 data --> IR */
	else {
		//ctx->flickerCtx.als_raw_data.y = ch0_data;
		//ctx->flickerCtx.als_raw_data.y_gain = ctx->fifo_mod0_gain;
		//ctx->flickerCtx.als_raw_data.uva = ch2_data;
		//ctx->flickerCtx.als_raw_data.uva_gain = ctx->fifo_mod2_gain;
		/* mod1 step 0 data --> IR */
		ctx->flickerCtx.als_raw_data.ir = ch1_data;
		ctx->flickerCtx.als_raw_data.y_max = ch0_max;
		ctx->flickerCtx.als_raw_data.ir_max = ch1_max;
		ctx->flickerCtx.als_raw_data.uva_max = ch2_max;
		//ctx->flickerCtx.als_raw_data.ir_gain = ctx->fifo_mod1_gain;

		if( ch0_max > ctx->flickerCtx.max_samples.y_max )
			ctx->flickerCtx.max_samples.y_max = ch0_max;

		if( ch2_max > ctx->flickerCtx.max_samples.uva_max )
			ctx->flickerCtx.max_samples.uva_max = ch2_max;

		if( ch1_max > ctx->flickerCtx.max_samples.ir_max )
			ctx->flickerCtx.max_samples.ir_max = ch1_max;

		ALS_info("%s: process_ir , c %d , ir %d, uv %d ,c_max %d, ir_max %d, uv_max %d",__func__,ch0_data,ch1_data,ch2_data,ch0_max,ch1_max,ch2_max);
		ALS_info("%s: process_ir , c_max_1st %d, c_max_2nd %d, uv_max_1st %d , uv_max_2nd =%d ,ir_max_1st %d , ir_max_2nd =%d ",__func__,ctx->flickerCtx.max_samples.y_max,ch0_max,ctx->flickerCtx.max_samples.uva_max,ch2_max,ctx->flickerCtx.max_samples.ir_max ,ch1_max);
		ALS_info("%s: process_ir , gain0 0x%x ,gain1 0x%x, gain2 0x%x ",__func__,ctx->flickerCtx.als_raw_data.y_gain,ctx->flickerCtx.als_raw_data.ir_gain,ctx->flickerCtx.als_raw_data.uva_gain);
	}
	ctx->mod1_step_counter++;
	if (als_data_process_en) {
		/* y */
		y_sum_norm  = ((uint64_t)(ctx->flickerCtx.als_raw_data.y) << REF_GAIN) >> ctx->flickerCtx.als_raw_data.y_gain;
		//y_sum_norm  = (ctx->flickerCtx.als_raw_data.y << REF_GAIN ) >> ctx->flickerCtx.als_raw_data.y_gain;
		//ALS_info("%s: y = %d, y_sum_norm = %d, MOD_CNT %d\n", __func__, ctx->flickerCtx.als_raw_data.y,y_sum_norm, ctx->mod1_step_counter);
		ALS_info("%s: before calibration ir = %d\n", __func__, ctx->flickerCtx.als_raw_data.ir);

		/* compenstate ir raw data */
		/* ir_calib_val_valid trimmed */
		if(ctx->ir_calib_val_valid){

			ir_sum_norm  = ((uint64_t)(ctx->flickerCtx.als_raw_data.ir) << REF_GAIN)  >> ctx->flickerCtx.als_raw_data.ir_gain;
			//ir_sum_norm  = (ctx->flickerCtx.als_raw_data.ir << REF_GAIN)  >> ctx->flickerCtx.als_raw_data.ir_gain;
			/*ir_corrected =ir_raw/(1-(IR_CALIB-63)/100)
			 * ==> 100*ir_raw / (100-(IR_CALIB-63))
			 * ==> 100*ir_raw /(163-IR_CALIB)
			 */
			sum_ir_bkCal = ((uint64_t)100*(uint64_t)ir_sum_norm)/(uint64_t)(163 - ctx->ir_calib_val);
			ALS_info("%s: after calibration ir = %d, ir_calib_val = %d\n",__func__, sum_ir_bkCal, ctx->ir_calib_val);
		}

		ALS_info("%s: before calibration bk(uvwh) = %d\n",
		__func__, ctx->flickerCtx.als_raw_data.bk);

		/* compenstate bk(uvwh) raw data */
		/* bk share the same flag as ir */
		if(ctx->ir_calib_val_valid){
			bk_sum_norm  = ((uint64_t)(ctx->flickerCtx.als_raw_data.bk) << REF_GAIN) >> ctx->flickerCtx.als_raw_data.bk_gain;
			//bk_sum_norm  = (ctx->flickerCtx.als_raw_data.bk << REF_GAIN) >> ctx->flickerCtx.als_raw_data.bk_gain;

			/*bk_corrected = bk_raw/(1-(((BK_CALIB-127) x k) + offset)/100)
			 * if k =0 , offset = 5 , bk_corrected = 100 * bk_raw / (100 - (0 + offset))
			 * ==> 100*bk_raw / (100-(5))
			 * ==> 100*bk_raw /(95)
			 */
			//cal_bk = (100*bk_sum_norm)/(227 - ctx->bk_calib_val);
			//sum_bk_bkCal = ((uint64_t)100 * (uint64_t)bk_sum_norm) / (uint64_t)(100 - (((ctx->bk_calib_val - 127) * K_coef ) + OFFSET));
		        sum_bk_bkCal = (100 * bk_sum_norm) / (100 - (((ctx->bk_calib_val - 127) * ctx->sum_bk_bkCal_kcoef ) + ctx->sum_bk_bkCal_offset  ));
			ALS_info("%s: after calibration bk(uvwh) = %d \n", __func__,  sum_bk_bkCal);
			ALS_info("%s: bk_calib_val =%d ,  offset = %d , k_coef =%d\n", __func__,  ctx->bk_calib_val, ctx->sum_bk_bkCal_offset, ctx->sum_bk_bkCal_kcoef);
		}

		/* uva */
		ALS_info("%s: before calibration uva = %d\n",
			__func__, ctx->flickerCtx.als_raw_data.uva);

		/* compenstate uv raw data */
		/* uva_calib_val 0 means untrimmed */
		if (ctx->uva_calib_val_valid) {
			uv_sum_norm  = ((uint64_t)(ctx->flickerCtx.als_raw_data.uva) << REF_GAIN) >> ctx->flickerCtx.als_raw_data.uva_gain;
			//uv_sum_norm  = (ctx->flickerCtx.als_raw_data.uva << REF_GAIN) >> ctx->flickerCtx.als_raw_data.uva_gain;
			/*uvmbk_bkCal = uv_sum_norm - sum_bk_bkCal;*/
			/*sum_uv_minus_bk_bkCal = (100*uvmbk_bkCal)/(163 - ctx->uva_calib_val);*/

			uv_sum_norm_uvCal = ((uint64_t)100 * (uint64_t)uv_sum_norm )/ (uint64_t)(163-ctx->uva_calib_val);
			sum_bk_bkCal_uvCal = ((uint64_t)100 * (uint64_t)sum_bk_bkCal) / (uint64_t)(163-ctx->uva_calib_val);

			if (uv_sum_norm_uvCal > sum_bk_bkCal_uvCal) {
				sum_uv_minus_bk_bkCal = uv_sum_norm_uvCal - sum_bk_bkCal_uvCal;
			} else {
				sum_uv_minus_bk_bkCal = 0;
			}

			/*uv_corrected =ir_raw/(1-(UV_CALIB-63)/100)
			 * ==> 100*uv_raw / (100-(UV_CALIB-63))
			 * ==> 100*uv_raw /(163-UV_CALIB)
			 */

			ALS_info("%s: after calibration uva = %d, uva_calib_val = %d\n",
			__func__, uv_sum_norm_uvCal, ctx->uva_calib_val);
		}
		/************************************************************************/
		//ratio_ir_y_bkCal = sum_ir_bkCal / sum_y_step0
		//ratio_uv_y_bkCal = sum_uv_minus_bk_bkCal / sum_y_step1
		//ratio_bk_ir_bkCal = sum_bk_bkCal/sum_ir_bkCal
		/************************************************************************/
		ALS_info("%s: y_sum_norm %ld, ir_sum_norm %ld, uv_sum_norm %ld, bk_sum_norm = %ld",
			__func__, y_sum_norm, ir_sum_norm, uv_sum_norm, bk_sum_norm);
		ALS_info("%s: sum_ir_bkCal %ld, sum_bk_bkCal %ld, uv_sum_norm_uvCal %ld, sum_bk_bkCal_uvCal %ld, sum_uv_minus_bk_bkCal %ld",
			__func__, sum_ir_bkCal, sum_bk_bkCal, uv_sum_norm_uvCal, sum_bk_bkCal_uvCal, sum_uv_minus_bk_bkCal);

		/*real UV data calcuation */
		/*UVmBK = UVtotal - BK
		 *   =  UVpure + UVir - BK
		 *   =  UVpure
		 */
		/* calcuatated in report_als */
		//ctx->flickerCtx.als_raw_data.uva = (ctx->flickerCtx.als_raw_data.uva /ctx->flickerCtx.als_raw_data.uva_gain) - (ctx->flickerCtx.als_raw_data.bk/ctx->flickerCtx.als_raw_data.bk_gain);

		/* NOTE: we don't calculate lux for now */
		//report_flicker(ctx, ALS_LUX_VALUE, ctx->flickerCtx.als_lux&0xFFFF);
		//report_als(data);

		//ctx->clear_average_fifo = ctx->flickerCtx.als_raw_data.y / (STEP_SAMPLES + 1); //photo 32 samples
		//ctx->uv_average_fifo = ctx->flickerCtx.als_raw_data.uva /  (STEP_SAMPLES + 1); //uv  32 samples
		//ctx->wideband_average_fifo = ctx->flickerCtx.als_raw_data.ir / (STEP_SAMPLES + 1); //ir 32 samples
		//ctx->wb_leak_average_fifo = ctx->flickerCtx.als_raw_data.bk / (STEP_SAMPLES + 1); //bk 32 samples

		ctx->clear_average_fifo = y_sum_norm; //photo 32 samples
		//ctx->uv_average_fifo = sum_uv_minus_bk_bkCal; //uv  32 samples
		ctx->uv_average_fifo = uv_sum_norm_uvCal; //real uv sending
		ctx->wideband_average_fifo = sum_ir_bkCal; //ir 32 samples
		ctx->wb_leak_average_fifo = sum_bk_bkCal; //bk 32 samples
		inputData.status = ALS_STATUS_RDY;
		inputData.datasetArray = (alsData_t *)&dataSet;

		//inputData.datasetArray->clearADC = ctx->clear_average_fifo ;
		//inputData.datasetArray->widebandADC = ctx->wideband_average_fifo ;
		//inputData.datasetArray->uvADC = ctx->uv_average_fifo ;
		//inputData.datasetArray->bkADC = ctx->wb_leak_average_fifo ;

		ctx->ccbAlsCtx.ctxAlgAls.results.rawClear  =  (ctx->clear_average_fifo >> REF_GAIN_C_IR);
		ctx->ccbAlsCtx.ctxAlgAls.results.rawUv   = (ctx->uv_average_fifo);
		ctx->ccbAlsCtx.ctxAlgAls.results.rawWideband    = (ctx->wideband_average_fifo >> REF_GAIN_C_IR);
		ctx->ccbAlsCtx.ctxAlgAls.results.rawBK   = (ctx->wb_leak_average_fifo);
		ctx->ccbAlsCtx.ctxAlgAls.results.subtracted_rawUv = (uint32_t)sum_uv_minus_bk_bkCal;

		/*ctx->ccbAlsCtx.ctxAlgAls.ClearGain = tsl2511_gain_conversion[ctx->flickerCtx.als_raw_data.y_gain];
		 *ctx->ccbAlsCtx.ctxAlgAls.WBGain = tsl2511_gain_conversion[ctx->flickerCtx.als_raw_data.ir_gain];
		 *ctx->ccbAlsCtx.ctxAlgAls.UVGain = tsl2511_gain_conversion[ctx->flickerCtx.als_raw_data.uva_gain];
		 *ctx->ccbAlsCtx.ctxAlgAls.BKGain = tsl2511_gain_conversion[ctx->flickerCtx.als_raw_data.bk_gain];
		 */

		ctx->ccbAlsCtx.ctxAlgAls.ClearGain = ctx->flickerCtx.als_raw_data.y_gain;
		ctx->ccbAlsCtx.ctxAlgAls.WBGain = ctx->flickerCtx.als_raw_data.ir_gain;
		ctx->ccbAlsCtx.ctxAlgAls.UVGain = ctx->flickerCtx.als_raw_data.uva_gain;
		ctx->ccbAlsCtx.ctxAlgAls.BKGain = ctx->flickerCtx.als_raw_data.bk_gain;

		/*ALS_dbg("%s: index c_gain %d, ir_gain %d, uv_gain %d, bk_gain %d\n",
		 *	__func__, ctx->flickerCtx.als_raw_data.y_gain, ctx->flickerCtx.als_raw_data.ir_gain,
		 *	ctx->flickerCtx.als_raw_data.uva_gain, ctx->flickerCtx.als_raw_data.bk_gain);
		 */

		ALS_info("%s: no_shift_c_avg %d, ir_avg %d, uv_avg %d, bk_avg %d,c_gain %d, ir_gain %d, uv_gain %d, bk_gain %d\n",
			__func__, ctx->clear_average_fifo, ctx->wideband_average_fifo,
			ctx->uv_average_fifo, ctx->wb_leak_average_fifo,
			ctx->ccbAlsCtx.ctxAlgAls.ClearGain, ctx->ccbAlsCtx.ctxAlgAls.WBGain,
			ctx->ccbAlsCtx.ctxAlgAls.UVGain, ctx->ccbAlsCtx.ctxAlgAls.BKGain);

		ALS_info("%s: shift_c_avg %d, ir_avg %d, uv_avg %d, bk_avg %d,c_gain %d, ir_gain %d, uv_gain %d, bk_gain %d\n",
			__func__, inputData.datasetArray->clearADC, inputData.datasetArray->widebandADC,
			inputData.datasetArray->uvADC, inputData.datasetArray->bkADC,
			ctx->ccbAlsCtx.ctxAlgAls.ClearGain, ctx->ccbAlsCtx.ctxAlgAls.WBGain,
			ctx->ccbAlsCtx.ctxAlgAls.UVGain, ctx->ccbAlsCtx.ctxAlgAls.BKGain);

		//amsAlg_als_processData(&ctx->ccbAlsCtx.ctxAlgAls, &inputData);
		ctx->updateAvailable |= (1 << AMS_AMBIENT_SENSOR);

		if( (ctx->flickerCtx.als_raw_data.y_max >= ctx->adc_max)
		|| (ctx->flickerCtx.als_raw_data.bk_max >= ctx->adc_max)
		|| (ctx->flickerCtx.als_raw_data.ir_max >= ctx->adc_max)
		|| (ctx->flickerCtx.als_raw_data.uva_max >= ctx->adc_max))
		{
				data->saturation = true;
				ALS_info("%s: max_c_sat %d, ir %d, bk %d, uva =%d ", __func__
				, ctx->flickerCtx.als_raw_data.y_max
				, ctx->flickerCtx.als_raw_data.ir_max
				, ctx->flickerCtx.als_raw_data.bk_max
				, ctx->flickerCtx.als_raw_data.uva_max
				);

		}
				//report_als(data);
	}
}
#endif

static bool ccb_FIFOEvent(void *dcbCtx)
{
	int len = 0;

	uint16_t fifo_stat = 0;
	uint16_t fifo_ov = 0;
	uint16_t fifo_uf = 0;
	uint16_t fifo_buf_pos = 0;
	int size = 0;
	uint16_t fifo_size = 0;
	uint16_t tmp = 0;
	int  num_samples = 0;

	int i , j=0;
	uint8_t tmp_buffer[MAX_FIFO_LEN];

	uint16_t fd_gain = 0;
	uint32_t als_0 = 0;
	uint32_t als_1 = 0;
	uint32_t als_2 = 0;
	int err, ret = 0 ;
	uint16_t max0 = 0  , max1 = 0 , max2 = 0;

	ams_deviceCtx_t *ctx = (ams_deviceCtx_t *)dcbCtx;
	ams_flicker_ctx_t *ccbCtx = (ams_flicker_ctx_t *)&ctx->flickerCtx;

	//ccbCtx->statusReg = ctx->shadowFIFOStatusReg;
	num_samples =ctx->flicker_num_samples;


	ams_getWord(ctx->portHndl, DEVREG_FIFO_STATUS0, &fifo_stat); //current fifo count
	ccbCtx->fifolvl = ((fifo_stat & 0xff) << 2) + ((fifo_stat & 0x0300) >> 8);
	fifo_ov |= (fifo_stat & 0x8000) != 0;  // Remember if there has been an overflow
	fifo_uf |= (fifo_stat & 0x4000) != 0;  // Remember if there has been an underflow

	ALS_info("%s - fifo_stat 0x%x , ov 0x%x , uf 0x%x \n", __func__, fifo_stat, fifo_ov, fifo_uf);

	ccbCtx->overflow += fifo_ov;
	if (fifo_ov > 0) {
		AMS_ENABLE_PON(err);
		if (err < 0) {
			ALS_err("%s - failed to AMS_ENABLE_PON\n", __func__);
		}

		AMS_FIFO_CLEAR(ret);
		if (ret < 0) {
			ALS_err("%s - failed to FIFO CLEAR\n", __func__);
			return ret;
		}
		ccbCtx->fifolvl = 0;
		ctx->flickerCtx.max_samples.y_max =0;
		ctx->flickerCtx.max_samples.ir_max =0;
		ctx->flickerCtx.max_samples.bk_max =0;
		ctx->flickerCtx.max_samples.uva_max =0;


		kfifo_reset(&ams_fifo);
		ctx->mod1_step_counter = 0;

		ALS_err("%s - fifo over flow [0x%x]\n", __func__, fifo_ov);

		ams_getWord(ctx->portHndl, DEVREG_FIFO_STATUS0, &fifo_stat); //current fifo count
		ccbCtx->fifolvl = ((fifo_stat & 0xff) << 2) + ((fifo_stat & 0x0300) >> 8);
		if (ccbCtx->fifolvl != 0) {
			ALS_err("%s fifo level not zero: [%d]\n", __func__,ccbCtx->fifolvl);
		}
		AMS_REENABLE_FD_PON(err);
		if (err < 0) {
				ALS_err("%s - failed to AMS_ENABLE_PON\n", __func__);
		}
		return false;
	}
	if (fifo_uf > 0) {
		ALS_err("%s - fifo under flow [0x%x]\n", __func__, fifo_uf);
	}

	fifo_size = ccbCtx->fifolvl;

	ALS_info("%s - FIFO LVL or FIFO size = %d , KFIFO_SIZE =%d\n ", __func__, ccbCtx->fifolvl ,kfifo_len(&ams_fifo));

	if(fifo_size < ctx->flicker_1_frame) {
		ALS_info("%s: less than num_bytes_per_step %d. return \n", __func__, ctx->flicker_1_frame);
		//ALS_info("%s - FIFO LVL or FIFO size = %d , KFIFO_SIZE =%d\n ", __func__, ccbCtx->fifolvl ,kfifo_len(&ams_fifo));
		return false;
	} else {
		/* read only one step data one time */
		fifo_size = ctx->flicker_1_frame;
	}

	memset(&tmp_buffer, 0x0, sizeof(tmp_buffer));

	while (fifo_size > 0) {
		if (fifo_size >= I2C_SMBUS_BLOCK_MAX) {
			size = I2C_SMBUS_BLOCK_MAX;
		}
		else {
			size = fifo_size;
		}
		memset(&fifodata, 0x0, sizeof(fifodata));

		//ALS_info("%s  - read size =%d  , i2c smubs max %d, ch0=%d ch1=%d ch=2%d \n",__func__, size,I2C_SMBUS_BLOCK_MAX);

		ams_getBuf(ctx->portHndl, DEVREG_FIFO_DATA, (uint8_t *)&fifodata, size);
		memcpy(&tmp_buffer[fifo_buf_pos],fifodata,size);

		fifo_size -= size;
		fifo_buf_pos += size;
	}

#if 1
	/***************************************STEP0/STEP1***********************************************/
	//for (i = 0, j = 0; i < ctx->flicker_1_frame - 2 ; i += 6, j++) {//188byte - 2byte (gain)
	for (i = 0, j = 0; i < ctx->flicker_1_frame - ctx->fifo_end_size ; i += 6, j++) {//188byte - 2byte (gain)
		tmp = ((tmp_buffer[i + 1] << 8) | tmp_buffer[i]);
		fifo_chan_0_buf[j] = tmp;
		kfifo_in(&ams_fifo, (uint8_t *)&tmp, 2);//copy to kfifo from ch0 only
		tmp = ((tmp_buffer[i + 3] << 8) | tmp_buffer[i+2]);
		fifo_chan_1_buf[j] = tmp;
		tmp = ((tmp_buffer[i + 5] << 8) | tmp_buffer[i+4]);
		fifo_chan_2_buf[j] = tmp;

		if (kfifo_is_full(&ams_fifo)) {
			kfifo_reset(&ams_fifo);
			ctx->mod1_step_counter = 0;
			ALS_err("%s - ams_fifo is full\n", __func__);
			return false;
		}
	}

	tmp = fifo_chan_0_buf[STEP_SAMPLES] = fifo_chan_0_buf[STEP_SAMPLES-1]; //ch0  last data interpolation

	kfifo_in(&ams_fifo, (uint8_t *)&tmp, 2);//interpolation copy to kfifo from ch0 only
	if (kfifo_is_full(&ams_fifo)) {
		kfifo_reset(&ams_fifo);
		ctx->mod1_step_counter = 0;
		ALS_err("%s - ams_fifo is full\n", __func__);
		return false;
	}

	fifo_chan_1_buf[STEP_SAMPLES] = fifo_chan_1_buf[STEP_SAMPLES-1];//ch1
	fifo_chan_2_buf[STEP_SAMPLES] = fifo_chan_2_buf[STEP_SAMPLES-1];//ch2

	fifo_buf_pos = fifo_size-ctx->fifo_end_size;
#if 0
	if(ctx->has_fifo_fd_end_marker){
		if((tmp_buffer[ctx->flicker_1_frame - ctx->fifo_end_size]==0) && (tmp_buffer[ctx->flicker_1_frame - ctx->fifo_end_size+1]==0) && (tmp_buffer[ctx->flicker_1_frame - ctx->fifo_end_size+2]==0)){
			ALS_info("found end marker!");
		} else {
			ALS_info("%s: exit no end marker\n", __func__);
			//fifo_reset(ctx);
			kfifo_reset(&ams_fifo);
			AMS_FIFO_CLEAR(ret);
			ctx->mod1_step_counter = 0;
			return 0;
		}
	}
#endif
	//ALS_info("%s  STEP0 %d ,interpolation , ch0=%d ch1=%d ch=2%d \n",__func__, j, fifo_chan_0_buf[STEP_SAMPLES], fifo_chan_1_buf[STEP_SAMPLES], fifo_chan_2_buf[STEP_SAMPLES]);
	//ALS_info("%s  gain , 0x%x \n",__func__,fd_gain);
	/***************************************STEP0/STEP1***********************************************/
#endif

	//if((len = kfifo_len(&ams_fifo)) >= (AMS_FFT_SIZE)) //waiting len = 768 byte for 384 sample level
	if ((len = kfifo_len(&ams_fifo)) >= (AMS_FFT_SIZE * 2)) //waiting len = 2048samples * 2byte = 4096byte
	//if((len = kfifo_len(&ams_fifo)) >= (num_sample_bytes)) // 512 SAMPLE * clear & wide
	{
		ctx->flickerCtx.data_ready = 1;
		//dev_info(&chip->client->dev, "Sample Rate: %ld Hz\n", sample_rate);
		ALS_info("%s FIFO now is full!!! ready  to calc freq   fifo size %d ",__func__,len);

	}

	als_0 = 0;
	als_1 = 0;
	als_2 = 0;
	for (i = 0; i <= STEP_SAMPLES; i++) {
		/* calculate als data */
		als_0 += fifo_chan_0_buf[i];
		als_1 += fifo_chan_1_buf[i];
		als_2 += fifo_chan_2_buf[i];

		if(fifo_chan_0_buf[i] > max0){
			max0 = fifo_chan_0_buf[i];
		}
		if(fifo_chan_1_buf[i] > max1){
			max1 = fifo_chan_1_buf[i];
		}
		if(fifo_chan_2_buf[i] > max2){
			max2 = fifo_chan_2_buf[i];
		}

		//ALS_info("%s: sum_count  %d, ch0 %ld ,ch1 %ld , ch2 %ld ,max0 %d , max1 %d , max2 %d ",__func__,i,als_0,als_1,als_2,max0,max1,max2);
	}
	get_als_data(ctx, als_0, als_1, als_2, max0, max1 ,max2); // STEP0 , STEP1 DATA report here

	return false;
}


static int ccb_alsHandle(void *dcbCtx, ams_ccb_als_dataSet_t *alsData)
{
	ams_deviceCtx_t *ctx = (ams_deviceCtx_t *)dcbCtx;
	ams_ccb_als_ctx_t *ccbCtx = &((ams_deviceCtx_t *)dcbCtx)->ccbAlsCtx;
	amsAlsDataSet_t inputDataAls;
	static adcDataSet_t adcData; /* QC - is this really needed? */
	uint8_t ADCs[4]; //Clear + WIDEBAND
	int ret = 0;

	/* get gain from HW register if so configured */
	if (ctx->ccbAlsCtx.initData.autoGain) {
		uint32_t scaledGain;
		uint32_t scaledGain1;

		uint8_t gain;

		AMS_GET_ALS_GAIN(scaledGain, scaledGain1, gain, ret);
		if (ret < 0) {
			ALS_err("%s - failed to AMS_GET_ALS_GAIN\n", __func__);
			return ret;
		}
		ctx->ccbAlsCtx.ctxAlgAls.ClearGain = scaledGain;
		ctx->ccbAlsCtx.ctxAlgAls.WBGain = scaledGain1;
	}

	switch (ccbCtx->state) {
		case AMS_CCB_ALS_RGB: /* state to measure RGB */
			if ((alsData->status2Reg & (ALS_DATA_VALID)) /*|| ctx->alwaysReadAls*/)
			{
				AMS_ALS_GET_ALS_DATA(&ADCs[0], ret);
				if (ret < 0) {
					ALS_err("%s - failed to AMS_ALS_GET_CRGB_W\n", __func__);
					return ret;
				}
				inputDataAls.status = ALS_STATUS_RDY;

				if ((alsData->alsstatusReg & 0x04) == 0)
					adcData.AdcClear = ((ADCs[1] << 8) | (ADCs[0] << 0)) << 4;
				else
					adcData.AdcClear = ((ADCs[1] << 8) | (ADCs[0] << 0));

				if ((alsData->alsstatusReg & 0x02) == 0)
					adcData.AdcWb = ((ADCs[3] << 8) | (ADCs[2] << 0)) << 4;
				else
					adcData.AdcWb = ((ADCs[3] << 8) | (ADCs[2] << 0));

				if ((alsData->alsstatus2Reg & 0x0F) == 0)
					adcData.AdcClear = (((adcData.AdcClear) << 1)); // 0.5x
				else
					adcData.AdcClear = (((adcData.AdcClear) >> ((alsData->alsstatus2Reg & 0x0F) - 1)));

				if (((alsData->alsstatus2Reg & 0xF0) >> 4) == 0)
					adcData.AdcWb = (((adcData.AdcWb) << 1)); // 0.5x
				else
					adcData.AdcWb = (((adcData.AdcWb) >> (((alsData->alsstatus2Reg & 0xF0) >> 4) - 1)));

				inputDataAls.datasetArray = (alsData_t *)&adcData;
				AMS_PORT_LOG_CRGB_W(adcData);
				ALS_info("Clear AGAIN = %d, WIDE AGAIN =%d\n", ctx->ccbAlsCtx.ctxAlgAls.ClearGain, ctx->ccbAlsCtx.ctxAlgAls.WBGain);

				amsAlg_als_processData(&ctx->ccbAlsCtx.ctxAlgAls, &inputDataAls);

				if (ctx->mode & MODE_ALS_LUX)
					ctx->updateAvailable |= (1 << AMS_AMBIENT_SENSOR);
				ccbCtx->state = AMS_CCB_ALS_RGB;
			}
			break;

		default:
			ccbCtx->state = AMS_CCB_ALS_RGB;
			break;
	}
	return false;
}

static void ccb_alsGetResult(void *dcbCtx, ams_ccb_als_result_t *exportData)
{
	ams_ccb_als_ctx_t *ccbCtx = &((ams_deviceCtx_t *)dcbCtx)->ccbAlsCtx;

	/* export data */
	exportData->rawClear = exportData->clear = ccbCtx->ctxAlgAls.results.rawClear;
	exportData->ir = ccbCtx->ctxAlgAls.results.IR;
	exportData->time_us = ccbCtx->ctxAlgAls.time_us;
	exportData->ClearGain = ccbCtx->ctxAlgAls.ClearGain;
	exportData->WBGain = ccbCtx->ctxAlgAls.WBGain;
	exportData->BKGain = ccbCtx->ctxAlgAls.BKGain;
	exportData->UVGain = ccbCtx->ctxAlgAls.UVGain;
	exportData->rawUv = ccbCtx->ctxAlgAls.results.rawUv;
	exportData->rawWideband = ccbCtx->ctxAlgAls.results.rawWideband;
	exportData->rawBK = ccbCtx->ctxAlgAls.results.rawBK;
	exportData->subtracted_rawUv = ccbCtx->ctxAlgAls.results.subtracted_rawUv;
}

static bool _2511_alsSetThreshold(ams_deviceCtx_t *ctx, int32_t threshold)
{
	ams_ccb_als_config_t configData;

	configData.threshold = threshold;
	ccb_alsSetConfig(ctx, &configData);

	return false;
}


static int ams_deviceSetConfig(ams_deviceCtx_t *ctx, ams_configureFeature_t feature, deviceConfigOptions_t option, uint32_t data)
{
	struct tsl2511_device_data *chip_data = i2c_get_clientdata(ctx->portHndl);

	int ret = 0;

	if (feature == AMS_CONFIG_ALS_LUX) {
		ALS_dbg("%s - ams_configureFeature_t AMS_CONFIG_ALS_LUX\n", __func__);
		switch (option) {
			case AMS_CONFIG_ENABLE: /* ON / OFF */
				ALS_info("%s - deviceConfigOptions_t AMS_CONFIG_ENABLE(%u)\n", __func__, data);
				ALS_info("%s - current mode %d\n", __func__, ctx->mode);
				if (data == 0) {
					if (ctx->mode == MODE_ALS_LUX) {
						/* if no other active features, turn off device */
						ctx->shadowEnableReg = 0;
						ctx->shadowIntenabReg = 0;
						ctx->mode = MODE_OFF;
					} else {
						if ((ctx->mode & MODE_ALS_ALL) == MODE_ALS_LUX) {
							ctx->shadowEnableReg &= ~MASK_AEN;
							ctx->shadowIntenabReg &= ~MASK_ALS_INT_ALL;
						}
						ctx->mode &= ~(MODE_ALS_LUX);
					}
				}
				else {
					if ((ctx->mode & MODE_ALS_ALL) == 0) {
						ret = ccb_alsInit(ctx, &ctx->ccbAlsCtx.initData);
						if (ret < 0) {
							ALS_err("%s - failed to ccb_alsInit\n", __func__);
							return ret;
						}

						ctx->shadowEnableReg |= (AEN | PON);
						//if( ctx->sensor_mode == 1)	{ //als need polling mode , 200msec
						//    ctx->shadowIntenabReg |= AIEN;
						//}
					} else {
						/* force interrupt */
						ret = ams_setWord(ctx->portHndl, DEVREG_AILT0, 0x00);

						if (ret < 0) {
							ALS_err("%s - failed to set DEVREG_AIHTL\n", __func__);
							return ret;
						}

						ret = ams_setByte(ctx->portHndl, DEVREG_AILT2, 0x00);

						if (ret < 0) {
							ALS_err("%s - failed to set DEVREG_AIHTL\n", __func__);
							return ret;
						}

					}
					ctx->mode |= MODE_ALS_LUX;
				}
				break;
			case AMS_CONFIG_THRESHOLD: /* set threshold */
				ALS_info("%s - deviceConfigOptions_t AMS_CONFIG_THRESHOLD\n", __func__);
				ALS_info("%s - data %d\n", __func__, data);
				_2511_alsSetThreshold(ctx, data);
				break;
			default:
				break;
		}
	}
#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
	if (feature == AMS_CONFIG_FLICKER) {
		ALS_dbg("%s - ams_configureFeature_t AMS_CONFIG_FLICKER\n", __func__);
		switch (option) {
			case AMS_CONFIG_ENABLE: /* power on */
				ALS_info("%s - deviceConfigOptions_t AMS_CONFIG_ENABLE(%u)\n", __func__, data);
				ALS_info("%s - current mode %d\n", __func__, ctx->mode);
				if (data == 0) {
					if (ret < 0) {
						ALS_err("%s - failed to set DEVREG_CFG9\n", __func__);
						return ret;
					}
					if (ctx->mode == MODE_FLICKER) {
						/* if no other active features, turn off device */
						ctx->shadowEnableReg = 0;
						ctx->shadowIntenabReg = 0;
						ctx->mode = MODE_OFF;
					}
					else {
						ctx->mode &= ~MODE_FLICKER;
						ctx->shadowEnableReg &= ~(FDEN);
					}

				}
				else {
					ctx->shadowEnableReg |= (PON | FDEN);
					ctx->shadowIntenabReg |= (SIEN|FIEN);
					ctx->mode |= MODE_FLICKER;
					if (chip_data->eol_enabled) {
						ccb_intclk_resume(ctx);
					} else {
						ccb_extclk_resume(ctx);
					}
					ccb_flickerInit(ctx /*,&ctx->ccbAlsCtx.initData*/);
				}
				break;
			case AMS_CONFIG_THRESHOLD: /* set threshold */
				ALS_info("%s - deviceConfigOptions_t AMS_CONFIG_THRESHOLD\n", __func__);
				/* TODO?:  set FD_COMPARE value? */
				break;
			default:
				break;
		}
	}
#endif
	/*ret = ams_setByte(ctx->portHndl, DEVREG_INTENAB, ctx->shadowIntenabReg);
	 *if (ret < 0) {
	 *	ALS_err("%s - failed to set DEVREG_INTENAB\n", __func__);
	 *	return ret;
	 *}
	 *usleep_range(1000, 1100);
	 */

	ret = ams_setByte(ctx->portHndl, DEVREG_ENABLE, ctx->shadowEnableReg);
	if (ret < 0) {
		ALS_err("%s - failed to set DEVREG_ENABLE\n", __func__);
		return ret;
	}

	usleep_range(1000, 1100);
	return 0;
}

#define STAR_ATIME  50 //50 msec
#define STAR_D_FACTOR  2266

static int amsAlg_als_setConfig(amsAlsContext_t *ctx, amsAlsConf_t *inputData)
{
	int ret = 0;

	if (inputData != NULL) {
		//ctx->gain = inputData->gain;
		ctx->time_us = inputData->time_us;
	}
	//als_update_statics(ctx);

	return ret;
}

/*
 * getConfig: is used to quarry the algorithm's configuration
 */
static int amsAlg_als_getConfig(amsAlsContext_t *ctx, amsAlsConf_t *outputData)
{
	int ret = 0;

	//outputData->gain = ctx->gain;
	outputData->time_us = ctx->time_us;

	return ret;
}

static int amsAlg_als_getResult(amsAlsContext_t *ctx, amsAlsResult_t *outData)
{
	int ret = 0;

	outData->rawClear = ctx->results.rawClear;
	outData->rawWideband = ctx->results.rawWideband;
	outData->irrClear = ctx->results.irrClear;
	outData->irrWideband = ctx->results.irrWideband;
	//outData->mLux_ave = ctx->results.mLux_ave / AMS_LUX_AVERAGE_COUNT;
	outData->IR = ctx->results.IR;
	//outData->CCT = ctx->results.CCT;
	outData->adaptive = ctx->results.adaptive;

	if (ctx->notStableMeasurement)
		ctx->notStableMeasurement = false;

	outData->mLux = ctx->results.mLux;

	return ret;
}

static int amsAlg_als_initAlg(amsAlsContext_t *ctx, amsAlsInitData_t *initData)
{
	int ret = 0;

	memset(ctx, 0, sizeof(amsAlsContext_t));

	if (initData != NULL) {
		ctx->calibration.Time_base = initData->calibration.Time_base;
		ctx->calibration.thresholdLow = initData->calibration.thresholdLow;
		ctx->calibration.thresholdHigh = initData->calibration.thresholdHigh;
		ctx->calibration.calibrationFactor = initData->calibration.calibrationFactor;
	}

	if (initData != NULL) {
		//ctx->gain = initData->gain;
		ctx->time_us = initData->time_us;
		ctx->adaptive = initData->adaptive;
	}
	else {
		ALS_dbg("error: initData == NULL\n");
	}

	//als_update_statics(ctx);
	return ret;
}

static int amsAlg_als_getAlgInfo(amsAlsAlgoInfo_t *info)
{
	int ret = 0;

	info->algName = "AMS_ALS";
	info->contextMemSize = sizeof(amsAlsContext_t);
	info->scratchMemSize = 0;

	info->initAlg = &amsAlg_als_initAlg;
	info->processData = &amsAlg_als_processData;
	info->getResult = &amsAlg_als_getResult;
	info->setConfig = &amsAlg_als_setConfig;
	info->getConfig = &amsAlg_als_getConfig;

	return ret;
}
void tsl2511_print_reg_status(void)
{
	int reg, err;
	u8 recvData;

	for (reg = 0; reg < DEVREG_REG_MAX; reg++) {
		err = tsl2511_read_reg(tsl2511_data, deviceRegisterDefinition[reg].address, &recvData, 1);
		if (err != 0) {
			ALS_err("%s - error reading 0x%02x err:%d\n",
					__func__, reg, err);
		}
		else {
			ALS_dbg("%s - 0x%02x = 0x%02x\n",
					__func__, deviceRegisterDefinition[reg].address, recvData);
		}
	}
}

static int tsl2511_set_sampling_rate(u32 sampling_period_ns)
{
	//ALS_dbg("%s - set_sampling_rate not support\n", __func__);

	return 0;
}


static int tsl2511_set_nr_sample(struct tsl2511_device_data *data , u16 fifo_thr)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;

	AMS_DISABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_DISABLE_FD\n", __func__);
		return ret;
	}
	AMS_SET_FLICKER_NUM_SAMPLES(fifo_thr, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_FLICKER_NUM_SAMPLES\n", __func__);
		return ret;
	}
	AMS_REENABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_REENABLE_FD\n", __func__);
		return ret;
	}
	return 1;
}

static int tsl2511_set_sampling_time(struct tsl2511_device_data *data , u16 time)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;

    //ctx->adc_max = (time+1)*16*32;                             /*sw_agc*/
	ctx->adc_max = (time+1)*16;
	ctx->adc_max_high_thresh = (ctx->adc_max*AMS_TSL2511_ADC_HIGH_THRESH)/100;    /*sw_agc*/
	ctx->adc_max_near_high_thresh = (ctx->adc_max*AMS_TSL2511_ADC_NEAR_HIGH_THRESH)/100;
	ctx->adc_max_low_thresh = (ctx->adc_max*AMS_TSL2511_ADC_LOW_THRESH)/100;      /*sw_agc*/
	ctx->adc_max_mid_thresh = (ctx->adc_max*AMS_TSL2511_ADC_MID_THRESH)/100;      /*sw_agc*/


	AMS_SET_SAMPLE_TIME(time, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_SAMPLE_TIME\n", __func__);
		return ret;
	}

	return 1;
}


static int tsl2511_hamming_status(struct tsl2511_device_data *data , bool on_off)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;

	AMS_DISABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_DISABLE_FD\n", __func__);
		return ret;
	}

	ctx->hamming_status = on_off;

	AMS_REENABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_REENABLE_FD\n", __func__);
		return ret;
	}
	return 1;
}


static int tsl2511_polling_enable(struct tsl2511_device_data *data , bool on_off)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;

	ALS_err("%s - timer en =%d , exist= %d ,active = %d\n", __func__, on_off, data->timer_is_exist,
		data->timer_is_active);
	if (on_off == true) {
		if(data->timer_is_exist) {
			if (data->timer_is_active) {
				ALS_dbg("%s - als_timer is already running\n", __func__);
			} else {
				hrtimer_start(&data->timer, data->light_poll_delay, HRTIMER_MODE_REL); /* polling start*/
				data->timer_is_active = true;
			}
		}
	} else {
		if(data->timer_is_exist) {
			if (data->timer_is_active) {
				hrtimer_cancel(&data->timer); /*polling stop*/
				drain_workqueue(data->wq);
				data->timer_is_active = false;
			} else {
				ALS_dbg("%s - als_timer is already stopped\n", __func__);
			}
		}
	}

	return 1;
}

static int tsl2511_pon_reenable(struct tsl2511_device_data *data , bool on_off)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;

	if(on_off) {
		AMS_ENABLE_PON(ret);
		if (ret < 0) {
			ALS_err("%s - failed to AMS_ENABLE_PON\n", __func__);
			return ret;
		}
	} else {
		AMS_REENABLE(ret);
		if (ret < 0) {
			ALS_err("%s - failed to AMS_REENABLE\n", __func__);
			return ret;
		}
	}
	return 1;
}

static int tsl2511_set_fifo_thr(struct tsl2511_device_data *data , u16 fifo_thr)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;

	AMS_DISABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_DISABLE_FD\n", __func__);
		return ret;
	}

	AMS_SET_FIFO_THR(fifo_thr, ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_SET_FIFO_THR\n", __func__);
		return ret;
	}

	AMS_REENABLE_FD(ret);
	if (ret < 0) {
		ALS_err("%s - failed to AMS_REENABLE_FD\n", __func__);
		return ret;
	}
	return 1;
}


static void tsl2511_irq_set_state(struct tsl2511_device_data *data, int irq_enable)
{
	ALS_dbg("%s - irq_enable : %d, irq_state : %d\n",
			__func__, irq_enable, data->irq_state);

	if (irq_enable) {
		if (data->irq_state++ == 0)
			enable_irq(data->dev_irq);
	}
	else {
		if (data->irq_state == 0)
			return;
		if (--data->irq_state <= 0) {
			disable_irq(data->dev_irq);
			data->irq_state = 0;
		}
	}
}

static int tsl2511_power_ctrl(struct tsl2511_device_data *data, int onoff)
{
	int rc = 0;

	ALS_dbg("%s - onoff : %d, state : %d\n", __func__, onoff, data->regulator_state);

	if (onoff == PWR_ON) {
		if (data->regulator_state != 0) {
			ALS_dbg("%s - duplicate regulator\n", __func__);
			data->regulator_state++;
			return 0;
		}

		if (data->regulator_vbus_1p8) {
			if(regulator_is_enabled(data->regulator_vbus_1p8)) {
				ALS_dbg("%s - vbus regulator already enabled", __func__);
			}
			else if(!data->vbus_1p8_enable) {
				rc = regulator_enable(data->regulator_vbus_1p8);
				if (rc) {
					ALS_err("%s - enable vbus_1p8 failed, rc=%d\n", __func__, rc);
					goto enable_vbus_1p8_failed;
				} else {
					data->vbus_1p8_enable = true;
					ALS_dbg("%s - enable vbus_1p8 done, rc=%d\n", __func__, rc);
				}
			} else {
				ALS_dbg("%s - vbus_1p8 already enabled, en=%d\n", __func__, data->vbus_1p8_enable);
			}
		}

		if (data->regulator_vdd_1p8) {
			if (!data->vdd_1p8_enable) {
				rc = regulator_enable(data->regulator_vdd_1p8);
				if (rc) {
					ALS_err("%s - enable vdd_1p8 failed, rc=%d\n", __func__, rc);
					goto enable_vdd_1p8_failed;
				} else {
					data->vdd_1p8_enable = true;
					ALS_dbg("%s - enable vdd_1p8 done, rc=%d\n", __func__, rc);
					msleep_interruptible(40);
				}
			} else {
				ALS_dbg("%s - vdd_1p8 already enabled, en=%d\n", __func__, data->vdd_1p8_enable);
			}
		}

		if (data->pin_flicker_1p8_en >= 0) {
			if (!data->vdd_1p8_enable) {
				rc = gpio_direction_output(data->pin_flicker_1p8_en, 1);
				if (rc) {
					ALS_err("%s - enable vdd_1p8 failed, rc=%d\n", __func__, rc);
					goto enable_vdd_1p8_failed;
				} else {
					data->vdd_1p8_enable = true;
					ALS_info("%s - enable vdd_1p8 done, rc=%d\n", __func__, rc);
					msleep_interruptible(40);
				}
			} else {
				ALS_info("%s - vdd_1p8 already enabled, en=%d\n", __func__, data->vdd_1p8_enable);
			}
		}

		data->regulator_state++;
		data->pm_state = PM_RESUME;
	} else {
		if (data->regulator_state == 0) {
			ALS_dbg("%s - already off the regulator\n", __func__);
			return 0;
		} else if (data->regulator_state != 1) {
			ALS_dbg("%s - duplicate regulator\n", __func__);
			data->regulator_state--;
			return 0;
		}
		data->regulator_state--;
#if !defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
		if (data->regulator_vdd_1p8) {
			if (data->vdd_1p8_enable) {
				rc = regulator_disable(data->regulator_vdd_1p8);
				if (rc) {
					ALS_err("%s - disable vdd_1p8 failed, rc=%d\n", __func__, rc);
				} else {
					data->vdd_1p8_enable = false;
					ALS_dbg("%s - disable vdd_1p8 done, rc=%d\n", __func__, rc);
				}
			} else {
				ALS_dbg("%s - vdd_1p8 already disabled, en=%d\n", __func__, data->vdd_1p8_enable);
			}
		}

		if (data->pin_flicker_1p8_en) {
			if (data->vdd_1p8_enable) {
				rc = gpio_direction_output(data->pin_flicker_1p8_en, 0);
				if (rc) {
					ALS_err("%s - disable vdd_1p8 failed, rc=%d\n", __func__, rc);
				} else {
					data->vdd_1p8_enable = false;
					ALS_info("%s - disable vdd_1p8 done, rc=%d\n", __func__, rc);
				}
			} else {
				ALS_info("%s - vdd_1p8 already disabled, en=%d\n", __func__, data->vdd_1p8_enable);
			}

		}

		if (data->regulator_vbus_1p8) {
			if (data->vbus_1p8_enable) {
				rc = regulator_disable(data->regulator_vbus_1p8);
				if (rc) {
					ALS_err("%s - disable vbus_1p8 failed, rc=%d\n", __func__, rc);
				} else {
					data->vbus_1p8_enable = false;
					ALS_dbg("%s - disable vbus_1p8 done, rc=%d\n", __func__, rc);
				}
			} else {
				ALS_dbg("%s - vbus_1p8 already disabled, en=%d\n", __func__, data->vbus_1p8_enable);
			}
		}
#endif
	}

	goto done;

enable_vdd_1p8_failed:
	if (data->regulator_vbus_1p8) {
		if (data->vbus_1p8_enable) {
			rc = regulator_disable(data->regulator_vbus_1p8);
			if (rc) {
				ALS_err("%s - disable vbus_1p8 failed, rc=%d\n", __func__, rc);
			} else {
				data->vbus_1p8_enable = false;
				ALS_dbg("%s - disable vbus_1p8 done, rc=%d\n", __func__, rc);
			}
		} else {
			ALS_dbg("%s - vbus_1p8 already disabled, en=%d\n", __func__, data->vbus_1p8_enable);
		}
	}
enable_vbus_1p8_failed:
done:
	//usleep_range(2000, 2100);
	return rc;
}

static bool ams_deviceGetAls(ams_deviceCtx_t *ctx, ams_apiAls_t *exportData);
static bool ams_deviceGetFlicker(ams_deviceCtx_t *ctx, ams_apiAlsFlicker_t *exportData);

static void report_als(struct tsl2511_device_data *chip)
{
	ams_apiAls_t outData;
	static unsigned int als_cnt;
	uint32_t temp_wb, temp_subtracted_uv, temp_uv = 0;
	uint32_t temp_clear, temp_bk = 0;
	uint32_t gain0 = 0, gain1 = 0, gain2 = 0, gain3 = 0;
	uint8_t gain0_inx = 0, gain1_inx = 0, gain2_inx = 0, gain3_inx = 0;

	if (chip->als_input_dev) {
		ams_deviceGetAls(chip->deviceCtx, &outData);

		if (chip->saturation) {
			temp_clear = temp_wb = temp_uv = temp_subtracted_uv = temp_bk = FLICKER_SENSOR_ERR_ID_SATURATION;
		} else {
			temp_wb = outData.rawWideband;
			temp_clear = outData.rawClear;
			temp_uv = outData.rawUv;
			temp_bk = outData.rawBK;
			temp_subtracted_uv = outData.subtracted_rawUv;
		}

		gain0_inx = (uint8_t)outData.ClearGain & 0x0F;//clear
		gain1_inx = (uint8_t)outData.WBGain & 0x0F;//wb
		gain2_inx = (uint8_t)outData.UVGain & 0x0F;//uv
		gain3_inx = (uint8_t)outData.BKGain & 0x0F;//bk

		//temp_clear = outData.rawClear >> gain0_inx; //raw data normalize
		//temp_wb = temp_wb >> gain1_inx; //raw data normalize
		//temp_uv = outData.rawUv >> gain2_inx; //raw data normalize
		//temp_bk = outData.rawBK >> gain3_inx; //raw data normalize

		//ratio_ir_y_bkCal = sum_ir_bkCal / sum_y_step0
		//ratio_uv_y_bkCal = sum_uv_minus_bk_bkCal / sum_y_step1
		//ratio_bk_ir_bkCal = sum_bk_bkCal/sum_ir_bkCal

		if(gain0_inx > 0x0d)
			gain0_inx = 0x0d;
		if(gain1_inx > 0x0d)
			gain1_inx = 0x0d;
		if(gain2_inx > 0x0d)
			gain2_inx = 0x0d;
		if(gain3_inx > 0x0d)
			gain3_inx = 0x0d;

		gain0 = tsl2511_gain_conversion[gain0_inx];//get gain from gain_index
		gain1 = tsl2511_gain_conversion[gain1_inx];
		gain2 = tsl2511_gain_conversion[gain2_inx];
		gain3 = tsl2511_gain_conversion[gain3_inx];

		input_report_rel(chip->als_input_dev, REL_X, temp_wb + 1);
		input_report_rel(chip->als_input_dev, REL_RY, temp_clear + 1);
		input_report_abs(chip->als_input_dev, ABS_X, temp_bk + 1);
		input_report_abs(chip->als_input_dev, ABS_Y, outData.ClearGain + 1);
		input_report_abs(chip->als_input_dev, ABS_Z, outData.WBGain + 1);
#ifdef CONFIG_AMS_OPTICAL_SENSOR_2511_UVA
		input_report_rel(chip->als_input_dev, REL_RX, temp_subtracted_uv + 1);
		//input_report_abs(chip->als_input_dev, REL_RZ, outData.UVGain + 1);
#endif
		input_sync(chip->als_input_dev);

		if (als_cnt++ > 10) {
#ifdef CONFIG_AMS_OPTICAL_SENSOR_2511_UVA
			ALS_dbg("%s - als_Cnt over10  saturation %d, Clear:%d, IR:%d, UV:%d, SUBTR_UV:%d, BK:%d, C_GAIN:%d IR_GAIN:%d, UV_GAIN:%d, BK_GAIN:%d\n",
				__func__, chip->saturation, temp_clear, temp_wb, temp_uv, temp_subtracted_uv, temp_bk, outData.ClearGain, outData.WBGain, outData.UVGain, outData.BKGain);
#endif
			als_cnt = 0;
		} else {
			ALS_info("%s - saturation %d, Clear:%d, IR:%d, UV:%d, SUBTR_UV:%d, BK:%d, C_GAIN:%d IR_GAIN:%d, UV_GAIN:%d, BK_GAIN:%d\n",
				__func__, chip->saturation, temp_clear, temp_wb, temp_uv, temp_subtracted_uv, temp_bk, gain0, gain1, gain2, gain3);
		}

		chip->user_ir_data = temp_wb;
#if IS_ENABLED(CONFIG_SENSORS_FLICKER_SELF_TEST)
		als_eol_update_als(outData.rawWideband, outData.clear, outData.rawWideband, outData.rawUv);
#endif
#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
		chip->als_updated = true;
#endif
	}
	chip->saturation = false;
}

static void report_flicker(struct tsl2511_device_data *chip)
{
	ams_apiAlsFlicker_t outData;
	uint flicker = 0;
	static unsigned int flicker_cnt;

	if (chip->als_input_dev) {
		ams_deviceGetFlicker(chip->deviceCtx, &outData);
		flicker = outData.mHz;
		input_report_rel(chip->als_input_dev, REL_RZ, flicker + 1);
		input_sync(chip->als_input_dev);

		if (flicker_cnt++ > 10) {
			ALS_dbg("%s - flicker = %d\n", __func__, flicker);
			flicker_cnt = 0;
		} else {
			ALS_info("%s - flicker = %d\n", __func__, flicker);
		}

		chip->user_flicker_data = flicker;
#if IS_ENABLED(CONFIG_SENSORS_FLICKER_SELF_TEST)
		als_eol_update_flicker(flicker);
#endif
	}
}

static ssize_t als_ir_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAls_t outData = {0};
	struct tsl2511_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetAls(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d\n", outData.ir);
}

static ssize_t als_red_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAls_t outData = {0};
	struct tsl2511_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetAls(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d\n", outData.red);
}

static ssize_t als_green_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAls_t outData = {0};
	struct tsl2511_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetAls(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d\n", outData.green);
}

static ssize_t als_blue_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAls_t outData = {0};
	struct tsl2511_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetAls(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d\n", outData.blue);
}

static ssize_t als_clear_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAls_t outData = {0};
	struct tsl2511_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetAls(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d\n", outData.clear);
}

static ssize_t als_wideband_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAls_t outData = {0};
	struct tsl2511_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetAls(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d\n", outData.rawWideband);
}

static ssize_t als_uv_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAls_t outData = {0};
	struct tsl2511_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetAls(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d\n", outData.rawUv);
}

static ssize_t als_raw_data_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAls_t outData = {0};
	struct tsl2511_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetAls(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d,%d,%d,%d,%d\n", outData.ir,
			outData.rawRed, outData.rawGreen, outData.rawBlue, outData.rawClear);
}

static size_t als_enable_set(struct tsl2511_device_data *chip, uint8_t valueToSet)
{
	int rc = 0;


	if(chip->sensor_mode == 0) { /*Camera(flicker) + als sensor*/

#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
		rc = ams_deviceSetConfig(chip->deviceCtx, AMS_CONFIG_FLICKER, AMS_CONFIG_ENABLE, valueToSet);
		if (rc < 0) {
			ALS_err("%s - ams_deviceSetConfig FLICKER fail, rc=%d\n", __func__, rc);
			return rc;
		}
#endif

	} else { /*ALS ONLY work, should be set PD ( 1 Clear ch , 1 Wide band ch)*/
#if defined(CONFIG_AMS_OPTICAL_SENSOR_ALS_CCB)
		rc = ams_deviceSetConfig(chip->deviceCtx, AMS_CONFIG_ALS_LUX, AMS_CONFIG_ENABLE, valueToSet);
		if (rc < 0) {
			ALS_err("%s - ams_deviceSetConfig ALS_LUX fail, rc=%d\n", __func__, rc);
			return rc;
		}
#endif
	}

	chip->enabled = (u8)valueToSet;
	return 0;
}

#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
static ssize_t flicker_data_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ams_apiAlsFlicker_t outData;
	struct tsl2511_device_data *chip = dev_get_drvdata(dev);

	ams_deviceGetFlicker(chip->deviceCtx, &outData);

	return snprintf(buf, PAGE_SIZE, "%d\n", outData.mHz);
}
#endif
/* als input enable/disable sysfs */
static ssize_t tsl2511_enable_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	ams_mode_t mode;

	ams_getMode(data->deviceCtx, &mode);

	if (mode & MODE_ALS_ALL)
		return snprintf(buf, PAGE_SIZE, "%d\n", 1);
	else
		return snprintf(buf, PAGE_SIZE, "%d\n", 0);
}

static int ams_deviceInit(ams_deviceCtx_t *ctx, AMS_PORT_portHndl *portHndl, ams_calibrationData_t *calibrationData, bool osc_cal);

int tsl2511_stop(struct tsl2511_device_data *data);
int tsl2511_start(struct tsl2511_device_data *data);

#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
static int ams_deviceSoftReset(ams_deviceCtx_t *ctx);

int tsl2511_als_init(struct tsl2511_device_data *data)
{
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int err = 0;
	uint8_t vsync_cfg = 0;

	ams_setByte(ctx->portHndl, DEVREG_ENABLE, 0);
	ams_setByte(ctx->portHndl, DEVREG_OSCEN, 0x01); /*force osc on*/

	ams_getByte(ctx->portHndl, DEVREG_VSYNC_CFG, &vsync_cfg);
	ams_setByte(ctx->portHndl, DEVREG_CFG7, MOD_DIV_SEL_1); /*1/12, internal clock 720khz*/
	ams_setByte(ctx->portHndl, DEVREG_VSYNC_PERIOD_TARGET_L, 0x33);
	ams_setByte(ctx->portHndl, DEVREG_VSYNC_PERIOD_TARGET_H, 0x2B);

	vsync_cfg &= ~(TSL2511_REG_VSYNC_CFG__osc_calib_mode__MASK << TSL2511_REG_VSYNC_CFG__osc_calib_mode__SHIFT);
	vsync_cfg &= ~(TSL2511_REG_VSYNC_CFG__extclk_as_sysclk__MASK << TSL2511_REG_VSYNC_CFG__extclk_as_sysclk__SHIFT);
	vsync_cfg &= ~(TSL2511_REG_VSYNC_CFG__vsync_mode__MASK << TSL2511_REG_VSYNC_CFG__vsync_mode__SHIFT);
	vsync_cfg |= (TSL2511_HW_SYNC_MODE << TSL2511_REG_VSYNC_CFG__vsync_mode__SHIFT);
	ams_setByte(ctx->portHndl, DEVREG_VSYNC_CFG, vsync_cfg);

	usleep_range(1000, 1100);

	err = ams_setByte(ctx->portHndl, DEVREG_ENABLE, PON);
	if (err < 0) {
		ALS_err("%s - failed to set DEVREG_ENABLE\n", __func__);
		return err;
	}

	usleep_range(1000, 1100);

	/*SMUX step 0, mod1=pd3|xxx=pd2| mod2=pd1| mod0=pd0*/
	ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_PHDX_SMUX, 0x8D);
	/*SMUX step 1, mod1=pd3|xxx=pd2| mod2=pd1| mod0=pd0*/
	ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP1_MOD_PHDX_SMUX, 0x8D);

	/*sequencer init , mod0(step0) : ALS , mod1: Flicker*/
	ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_FD_0, 0x01); /*no fifo mode*/
	ams_setByte(ctx->portHndl, DEVREG_MEAS_SEQR_ALS_FD_1, 0x02); /*als only step0*/

	/*FIFO MAP*/
	AMS_SET_FIFO_MAP(ctx);

	AMS_SET_FLICKER_NUM_SAMPLES(AMS_FLICKER_NUM_SAMPLES, err);
	if (err < 0) {
		ALS_err("%s - failed to AMS_SET_FLICKER_NUM_SAMPLES\n",
			__func__);
		return err;
	}

	AMS_SET_FIFO_THR(AMS_FLICKER_THR_LVL, err);
	ams_setByte(ctx->portHndl, DEVREG_MEAS_MODE1, 0Xa8);

	/*sampling time set depend on clock speed , (783+1) * 1.389 usec*/
	AMS_SET_SAMPLE_TIME(AMS_SAMPLING_TIME, err);
	if (err < 0) {
		ALS_err("%s - failed to Sample time\n", __func__);
		return err;
	}

	/*als integration time 20msec*/
	err = ams_setByte(ctx->portHndl, DEVREG_ALS_NR_SAMPLES0, 20);
	if (err < 0) {
		ALS_err("%s - failed to NR number of Sample time\n", __func__);
		return err;
	}

	AMS_SET_AGC_MAX_GAIN(AMS_AGC_MAX_GAIN, err);
	if (err < 0) {
		ALS_err("%s - failed to set SET AGC MAX GAIN\n", __func__);
		return err;
	}

	err = ams_setByte(ctx->portHndl, DEVREG_ALS_NR_SAMPLES1, 0);
	if (err < 0) {
		ALS_err("%s - failed to NR number of Sample time\n", __func__);
		return err;
	}

	/*agc enable*/
	AMS_AGC_AZ_MODE(MASK_MOD_CALIB_NTH_ITERATION_AGC_ENABLE, err);
	AMS_AGC_ASAT_MODE(0xf0, err);
	AMS_AGC_PREDICT_MODE(0xf0, err);
	ams_setByte(ctx->portHndl, DEVREG_MOD_CALIB_CFG0, 0x01);

	/*persist enable*/
	AMS_SET_ALS_PERS(0x00, err);

	/*gain set*/
	AMS_SET_STEP0_ALS_GAIN0(16000, err);
	AMS_SET_STEP0_ALS_GAIN1(16000, err);
	AMS_SET_STEP0_ALS_GAIN2(16000, err);
	AMS_SET_STEP1_ALS_GAIN0(16000, err);
	AMS_SET_STEP1_ALS_GAIN1(16000, err);
	AMS_SET_STEP1_ALS_GAIN2(16000, err);

	/*agc nr samples*/
	AMS_SET_AGC_NR_SAMPLES(5, err);

	udelay(100);
	ams_setByte(ctx->portHndl, DEVREG_INTENAB, AIEN);

	udelay(100);
	ams_setByte(ctx->portHndl, DEVREG_ENABLE, AEN | PON);

	ALS_dbg("%s - ok : sensor_mode : %u\n", __func__, data->sensor_mode);

	return 0;
}

int tsl2511_als_start(struct tsl2511_device_data *data)
{
	int err = 0;

	ALS_dbg("%s",__func__);
	mutex_lock(&data->activelock);

	err = tsl2511_power_ctrl(data, PWR_ON);
	if (err < 0) {
		ALS_err("%s - als_regulator_on fail err = %d\n", __func__, err);
		goto mutex_unlock;
	}

	if (data->regulator_state == 1 && data->enabled == 0) {
		tsl2511_als_init(data);
	} else {
		uint8_t reg;
		ams_deviceCtx_t *ctx = data->deviceCtx;

		ams_getByte(ctx->portHndl, DEVREG_ENABLE, &reg);
		ALS_dbg("%s: DEVREG_ENABLE = 0x%x", __func__, reg);
	}
mutex_unlock:
	mutex_unlock(&data->activelock);

	return err;
}

int tsl2511_als_stop(struct tsl2511_device_data *data)
{
	int err = 0;
	ams_deviceCtx_t *ctx = data->deviceCtx;

	ALS_dbg("%s", __func__);
	mutex_lock(&data->activelock);

	if (data->regulator_state == 0) {
		ALS_dbg("%s - already power off - disable skip\n", __func__);
		goto err_already_off;
	} else if (data->regulator_state == 1 && data->enabled == 0) {
		err = ams_setByte(ctx->portHndl, DEVREG_ENABLE, 0);
		if (err != 0)
			ALS_err("%s - disable err : %d\n", __func__, err);
	}

	err = tsl2511_power_ctrl(data, PWR_OFF);
	if (err < 0)
		ALS_err("%s - als_regulator_off fail err = %d\n",
			__func__, err);

err_already_off:
	mutex_unlock(&data->activelock);

	return err;
}

static ssize_t tsl2511_als_enable_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	bool value;

	if (strtobool(buf, &value))
		return -EINVAL;

	ALS_dbg("%s - en : %d, c : %d\n", __func__, value, data->enabled);
	if (data->als_flag == value)
		return count;

	data->als_flag = value;

	if (value)
		tsl2511_als_start(data);
	else
		tsl2511_als_stop(data);

	return count;
}

static ssize_t tsl2511_als_enable_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%u\n", data->als_flag);
}

static ssize_t tsl2511_als_data_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	ams_deviceCtx_t *ctx = data->deviceCtx;
	ams_ccb_als_dataSet_t ccbAlsData;
	static adcDataSet_t adcData = {0, 0};
	int ret;

	if (data->enabled) {
		ams_apiAls_t outData;

		ams_deviceGetAls(data->deviceCtx, &outData);

		/*784 x 1.389uSec x 20 = 21,178 usec : 490usec x 31 sample = 15,190usec*/
		adcData.AdcClear = outData.rawClear * 28 / 10;
		adcData.AdcWb = outData.rawWideband * 28 / 10;

		if (((ctx->shadowAlsStatusReg == 0) &&
			(ctx->shadowStatus1Reg == 0)) || !data->als_updated) {
			ALS_err("%s - S2:0x%x, data: %u, %u (%u)\n",
				__func__, ctx->shadowStatus2Reg,
				adcData.AdcClear, adcData.AdcWb,
				data->als_updated);
			return snprintf(buf, PAGE_SIZE, "-2, -2");
		}

		data->als_updated = false;

		if ((ctx->shadowAlsStatusReg & 0x20) ||
			(ctx->shadowAlsStatusReg & 0x10) ||
			(adcData.AdcClear >= 8000000) ||
			(adcData.AdcWb >= 8000000))
			return snprintf(buf, PAGE_SIZE, "-2, -2");
	} else if (data->als_flag) {
		uint8_t ADCs[4], gain0 = 0, gain1 = 0;

		ret = ams_getByte(ctx->portHndl, DEVREG_STATUS,
				&ctx->shadowStatus1Reg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_STATUS\n", __func__);
			return snprintf(buf, PAGE_SIZE, "-6, -6");
		}

		ret = ams_getByte(ctx->portHndl, DEVREG_STATUS2,
				&ctx->shadowStatus2Reg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_STATUS2\n", __func__);
			return snprintf(buf, PAGE_SIZE, "-6, -6");
		}

		ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS,
				&ctx->shadowAlsStatusReg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_ALS_STATUS\n",
				__func__);
			return snprintf(buf, PAGE_SIZE, "-6, -6");
		}
		ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS2,
				&ctx->shadowAlsStatus2Reg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_ALS_STATUS2\n",
				__func__);
			return snprintf(buf, PAGE_SIZE, "-6, -6");
		}

		ccbAlsData.alsstatusReg = ctx->shadowAlsStatusReg;
		ccbAlsData.alsstatus2Reg = ctx->shadowAlsStatus2Reg;

		gain0 = ccbAlsData.alsstatus2Reg & 0x0F;
		gain1 = (ccbAlsData.alsstatus2Reg >> 4) & 0x0F;

		ret = ams_getBuf(ctx->portHndl, DEVREG_ALS_DATAL0, ADCs, 4);
		if (ret < 0) {
			ALS_err("%s - failed to DEVREG_ALS_DATAL0\n", __func__);
			return snprintf(buf, PAGE_SIZE, "-6, -6");
		}

		if ((ccbAlsData.alsstatusReg & 0x04) == 0)
			adcData.AdcClear = ((ADCs[1] << 8) | ADCs[0]) << 4;
		else
			adcData.AdcClear = (ADCs[1] << 8) | ADCs[0];

		if ((ccbAlsData.alsstatusReg & 0x02) == 0)
			adcData.AdcWb = ((ADCs[3] << 8) | ADCs[2]) << 4;
		else
			adcData.AdcWb = ((ADCs[3] << 8) | ADCs[2]);

		adcData.AdcClear = adcData.AdcClear << 9;
		adcData.AdcWb = adcData.AdcWb << 9;

		adcData.AdcClear = adcData.AdcClear >> gain0;
		adcData.AdcWb = adcData.AdcWb >> gain1;

		if (!(ctx->shadowStatus2Reg & ALS_DATA_VALID)) {
			ALS_err("%s - S1 = 0x%x, S2 = 0x%x, data: %u, %u\n",
				__func__, ctx->shadowStatus1Reg,
				ctx->shadowStatus2Reg,
				adcData.AdcClear, adcData.AdcWb);
			return snprintf(buf, PAGE_SIZE, "-2, -2");
		} else if ((ctx->shadowAlsStatusReg & 0x20) ||
			(ctx->shadowAlsStatusReg & 0x10)) {
			return snprintf(buf, PAGE_SIZE, "-2, -2");
		}
	} else {
		return snprintf(buf, PAGE_SIZE, "-1, -1");
	}

	return snprintf(buf, PAGE_SIZE, "%u, %u\n",
			adcData.AdcClear, adcData.AdcWb);
}
#endif /* CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS */

static ssize_t tsl2511_enable_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	bool value;

	if (strtobool(buf, &value))
		return -EINVAL;

	ALS_dbg("%s - en : %d, c : %d\n", __func__, value, data->enabled);

	if (value)
		tsl2511_start(data);
	else
		tsl2511_stop(data);

	return count;
}

int tsl2511_start(struct tsl2511_device_data *data)
{
	int err = 0;

	ALS_dbg("%s",__func__);
	mutex_lock(&data->activelock);

	err = tsl2511_power_ctrl(data, PWR_ON);
	if (err < 0) {
		ALS_err("%s - als_regulator_on fail err = %d\n", __func__, err);
		goto mutex_unlock;
	}

#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
	{
#else
	if (data->regulator_state == 1) {
#endif
		/*sensor active first */
		err = als_enable_set(data, AMSDRIVER_ALS_ENABLE);
		if (err < 0) {
			input_report_rel(data->als_input_dev, REL_RZ, -5 + 1); /* F_ERR_I2C -5 detected i2c error */
			input_sync(data->als_input_dev);
			ALS_err("%s - enable error %d\n", __func__, err);
			goto err_device_init;
		}

		/*timer active */
		err = tsl2511_polling_enable(data, AMSDRIVER_ALS_ENABLE);
		if (err < 0) {
			ALS_err("%s - tsl2511_polling_enable  fail, rc=%d\n", __func__, err);
			goto err_device_init;
		}
	}

	data->mode_cnt.amb_cnt++;
	goto done;

err_device_init:
	tsl2511_power_ctrl(data, PWR_OFF);
mutex_unlock:
done:
	mutex_unlock(&data->activelock);

	return err;
}

int tsl2511_stop(struct tsl2511_device_data *data)
{
	int err = 0;

	ALS_dbg("%s",__func__);
	mutex_lock(&data->activelock);

	if (data->regulator_state == 0) {
		ALS_dbg("%s - already power off - disable skip\n",
				__func__);
		goto err_already_off;
#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
	} else if ((data->regulator_state == 1) ||
			(data->als_flag && data->regulator_state == 2)) {
#else
	} else if (data->regulator_state == 1) {
#endif

		/*timer deactive first*/
		err = tsl2511_polling_enable(data, AMSDRIVER_ALS_DISABLE);
		if (err < 0)
			ALS_err("%s - tsl2511_polling_enable  fail, rc=%d\n", __func__, err);

#if defined(CONFIG_AMS_OPTICAL_SENSOR_POLLING)
		if (data->wq)
			cancel_work_sync(&data->work_light);
#endif

		/*sensor deactive */
		err = als_enable_set(data, AMSDRIVER_ALS_DISABLE);
		if (err != 0)
			ALS_err("%s - disable err : %d\n", __func__, err);
	}

	err = tsl2511_power_ctrl(data, PWR_OFF);
	if (err < 0)
		ALS_err("%s - als_regulator_off fail err = %d\n",
				__func__, err);

#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
	if (data->regulator_state == 1 && data->als_flag)
		tsl2511_als_init(data);
#endif

err_already_off:
	mutex_unlock(&data->activelock);

	return err;
}

static ssize_t tsl2511_poll_delay_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->sampling_period_ns);
}

static ssize_t tsl2511_poll_delay_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	u32 sampling_period_ns = 0;
	int err = 0;

	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &sampling_period_ns);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}
	data->light_poll_delay = ns_to_ktime(sampling_period_ns);
	err = tsl2511_set_sampling_rate(sampling_period_ns);

	if (err > 0)
		data->sampling_period_ns = sampling_period_ns;

	ALS_dbg("%s - tsl2511_poll_delay_store  as %d\n", __func__, sampling_period_ns);

	mutex_unlock(&data->activelock);

	return size;
}

static ssize_t tsl2511_fifo_thr_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->fifo_thr);
}

static ssize_t tsl2511_fifo_thr_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	u32 fifo_thr = 0;
	int err = 0;

	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &fifo_thr);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}
	err = tsl2511_set_fifo_thr(data,fifo_thr);


	ALS_dbg("%s - tsl2511_fifo_thr_store  as %d\n", __func__, fifo_thr);

	mutex_unlock(&data->activelock);

	return size;
}

static ssize_t tsl2511_fd_nr_sample_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->fifo_thr);
}

static ssize_t tsl2511_fd_nr_sample_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	u32 fifo_thr = 0;
	int err = 0;

	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &fifo_thr);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}
	err = tsl2511_set_nr_sample(data,fifo_thr);

	ALS_dbg("%s - tsl2511_fd_nr_sample_store  as %d\n", __func__, fifo_thr);

	mutex_unlock(&data->activelock);

	return size;
}

static ssize_t tsl2511_sampling_time_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->fifo_thr);
}

static ssize_t tsl2511_sampling_time_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	u32 fifo_thr = 0;
	int err = 0;

	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &fifo_thr);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}
	err = tsl2511_set_sampling_time(data,fifo_thr);

	ALS_dbg("%s - tsl2511_set_sampling_time as %d\n", __func__, fifo_thr);

	mutex_unlock(&data->activelock);

	return size;
}


static ssize_t tsl2511_hamming_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->fifo_thr);
}

static ssize_t tsl2511_hamming_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	u32 hamming_on_ff = 0;
	int err = 0;

	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &hamming_on_ff);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}

	err = tsl2511_hamming_status(data,hamming_on_ff);

	ALS_dbg("%s - tsl2511_hamming_store %d \n", __func__, hamming_on_ff);

	mutex_unlock(&data->activelock);

	return size;
}


static ssize_t tsl2511_polling_enable_store(struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	u32 hamming_on_ff = 0;
	int err = 0;

	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &hamming_on_ff);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}

	err = tsl2511_polling_enable(data,hamming_on_ff);

	ALS_dbg("%s - tsl2511_polling_enable_store %d \n", __func__, hamming_on_ff);

	mutex_unlock(&data->activelock);

	return size;
}

/*  Attributes  */
static ssize_t tsl2511_regs_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	//struct ams_chip *chip = dev_get_drvdata(dev);

	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	//return snprintf(buf, PAGE_SIZE, "%d\n", data->fifo_thr);

	uint8_t i;
	uint8_t j;
	int len = 0;
	uint8_t byte = 0;
	uint8_t r_value = 0x00;

	mutex_lock(&data->i2clock);

	for (i = 0x80; i >= 0x80; i += 8) {
		len += scnprintf(buf + len, PAGE_SIZE - len, "0x%02X: ", i);
		for (j = 0; j < 8; ++j) {
			byte = tsl2511_read_reg(data, i + j ,&r_value,1);
			len += scnprintf(buf + len, PAGE_SIZE - len, "0x%02x\t\t", r_value);
		}
		len += scnprintf(buf + len, PAGE_SIZE - len, "\n");
	}
	mutex_unlock(&data->i2clock);
	return len;
}


static ssize_t tsl2511_regs_write_store (struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	int num = 0;
	u8 reg = 0x00;
	u8 ret = 0x00;

	char r_value = 0x00;
	char w_value = 0x00;

	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	num = sscanf(buf,"W:0x%hhx,0x%hhx",&reg,&w_value);

	mutex_lock(&data->activelock);

	ret = tsl2511_read_reg(data, (u8)reg, &r_value, 1);
	if (ret != 0) {
		ALS_err("%s - err=%d, val=0x%06x\n",
				__func__, ret, r_value);
		mutex_unlock(&data->activelock);
		return ret;
	}

	ret = tsl2511_pon_reenable(data,true);//pon

	if (ret < 0) {
		ALS_err("%s - failed to AMS_ENABLE_PON\n", __func__);
		mutex_unlock(&data->activelock);
		return 0;
	}

	ALS_dbg("%s   read reg 0x%x , val 0x%x \n",__func__, reg,r_value);

	ret = tsl2511_write_reg(data, (u8)reg, (u8)w_value);
	if (ret < 0) {
		ALS_err("%s - fail err = %d\n", __func__, ret);
		mutex_unlock(&data->activelock);
		return ret;
	}

	ALS_dbg("%s   write reg 0x%x , val 0x%x \n",__func__, reg,w_value);

	ret = tsl2511_pon_reenable(data,false);//reenable

	if (ret < 0) {
		ALS_err("%s - failed to AMS_REENABLE\n", __func__);
		mutex_unlock(&data->activelock);
		return 0;
	}

	mutex_unlock(&data->activelock);
	return size;
}

static ssize_t tsl2511_sensor_mode_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->sensor_mode);
}

static ssize_t tsl2511_sensor_mode_store (struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	u32 sensor_mode = 0;
	int err = 0;
	int prev_state = 0;

	prev_state = data->enabled;

	if (data->enabled > 0) {
		tsl2511_stop(data);
	}
	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &sensor_mode);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}

	data->sensor_mode = (u8)sensor_mode;
	ALS_dbg("%s - tsl2511_sensor_mode %d \n", __func__, sensor_mode);

	mutex_unlock(&data->activelock);

	if (prev_state > 0) {
		tsl2511_start(data);
	}

	return size;
}

static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2511_enable_show, tsl2511_enable_store);
static DEVICE_ATTR(poll_delay, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2511_poll_delay_show, tsl2511_poll_delay_store);
static DEVICE_ATTR(fifo_thr, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2511_fifo_thr_show, tsl2511_fifo_thr_store);
static DEVICE_ATTR(fd_nr_sample, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2511_fd_nr_sample_show, tsl2511_fd_nr_sample_store);
static DEVICE_ATTR(sampling_time, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2511_sampling_time_show, tsl2511_sampling_time_store);
static DEVICE_ATTR(hamming_on_off, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2511_hamming_show, tsl2511_hamming_store);
static DEVICE_ATTR(poll_enable, S_IRUGO | S_IWUSR | S_IWGRP,
		NULL, tsl2511_polling_enable_store);
static DEVICE_ATTR(2511_regs, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2511_regs_show, tsl2511_regs_write_store);
static DEVICE_ATTR(sensor_mode, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2511_sensor_mode_show, tsl2511_sensor_mode_store);

static struct attribute *als_sysfs_attrs[] = {
	&dev_attr_enable.attr,
	&dev_attr_poll_delay.attr,
	&dev_attr_poll_enable.attr,
	&dev_attr_fifo_thr.attr,
	&dev_attr_fd_nr_sample.attr,
	&dev_attr_sampling_time.attr,
	&dev_attr_hamming_on_off.attr,
	&dev_attr_2511_regs.attr,
	&dev_attr_sensor_mode.attr,
	NULL
};

static struct attribute_group als_attribute_group = {
	.attrs = als_sysfs_attrs,
};

/* als_sensor sysfs */
static ssize_t tsl2511_name_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	ams_deviceCtx_t *ctx = data->deviceCtx;
	char chip_name[NAME_LEN];

	switch (ctx->deviceId) {
		case AMS_TSL2511:
			strlcpy(chip_name, TSL2511_CHIP_NAME, sizeof(chip_name));
			break;

		default:
			strlcpy(chip_name, TSL2511_CHIP_NAME, sizeof(chip_name));
			break;
	}

	return snprintf(buf, PAGE_SIZE, "%s\n", chip_name);
}

static ssize_t tsl2511_vendor_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", VENDOR);
}

static ssize_t tsl2511_flush_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	//ams_deviceCtx_t *ctx = data->deviceCtx;
	int ret = 0;
	u8 handle = 0;

	mutex_lock(&data->activelock);
	ret = kstrtou8(buf, 10, &handle);
	if (ret < 0) {
		ALS_err("%s - kstrtou8 failed.(%d)\n", __func__, ret);
		mutex_unlock(&data->activelock);
		return ret;
	}
	ALS_dbg("%s - handle = %d\n", __func__, handle);
	mutex_unlock(&data->activelock);

	input_report_rel(data->als_input_dev, REL_MISC, handle);

	return size;
}

static ssize_t tsl2511_int_pin_check_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	/* need to check if this should be implemented */
	ALS_dbg("%s - not implement\n", __func__);
	return snprintf(buf, PAGE_SIZE, "%d\n", 0);
}

static ssize_t tsl2511_read_reg_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	ALS_info("%s - val=0x%06x\n", __func__, data->reg_read_buf);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->reg_read_buf);
}

static ssize_t tsl2511_read_reg_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	int err = -1;
	unsigned int cmd = 0;
	u8 val = 0;

	mutex_lock(&data->i2clock);
	if (data->regulator_state == 0) {
		ALS_dbg("%s - need to power on\n", __func__);
		mutex_unlock(&data->i2clock);
		return size;
	}
	err = sscanf(buf, "%8x", &cmd);
	if (err == 0) {
		ALS_err("%s - sscanf fail\n", __func__);
		mutex_unlock(&data->i2clock);
		return size;
	}

	err = tsl2511_read_reg(data, (u8)cmd, &val, 1);
	if (err != 0) {
		ALS_err("%s - err=%d, val=0x%06x\n",
				__func__, err, val);
		mutex_unlock(&data->i2clock);
		return size;
	}
	data->reg_read_buf = (u32)val;
	mutex_unlock(&data->i2clock);

	return size;
}
static ssize_t tsl2511_write_reg_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	int err = -1;
	unsigned int cmd = 0;
	unsigned int val = 0;

	mutex_lock(&data->i2clock);
	if (data->regulator_state == 0) {
		ALS_dbg("%s - need to power on.\n", __func__);
		mutex_unlock(&data->i2clock);
		return size;
	}
	err = sscanf(buf, "%8x, %8x", &cmd, &val);
	if (err == 0) {
		ALS_err("%s - sscanf fail %s\n", __func__, buf);
		mutex_unlock(&data->i2clock);
		return size;
	}

	err = tsl2511_write_reg(data, (u8)cmd, (u8)val);
	if (err < 0) {
		ALS_err("%s - fail err = %d\n", __func__, err);
		mutex_unlock(&data->i2clock);
		return err;
	}
	mutex_unlock(&data->i2clock);

	return size;
}

static ssize_t tsl2511_debug_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	ALS_info("%s - debug mode = %u\n", __func__, data->debug_mode);

	return snprintf(buf, PAGE_SIZE, "%u\n", data->debug_mode);
}

static ssize_t tsl2511_debug_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	int err;
	s32 mode;

	mutex_lock(&data->activelock);
	err = kstrtoint(buf, 10, &mode);
	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}
	data->debug_mode = (u8)mode;
	ALS_info("%s - mode = %d\n", __func__, mode);

	switch (data->debug_mode) {
		case DEBUG_REG_STATUS:
			tsl2511_print_reg_status();
			break;
		case DEBUG_VAR:
			tsl2511_debug_var(data);
			break;
		default:
			break;
	}
	mutex_unlock(&data->activelock);

	return size;
}

static ssize_t tsl2511_device_id_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ALS_dbg("%s - device_id not support\n", __func__);

	return snprintf(buf, PAGE_SIZE, "NOT SUPPORT\n");
}

static ssize_t tsl2511_part_type_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	ams_deviceCtx_t *ctx = data->deviceCtx;

	return snprintf(buf, PAGE_SIZE, "%d\n", ctx->deviceId);
}

static ssize_t tsl2511_i2c_err_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	u32 err_cnt = 0;

	err_cnt = data->i2c_err_cnt;

	return snprintf(buf, PAGE_SIZE, "%d\n", err_cnt);
}

static ssize_t tsl2511_i2c_err_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	data->i2c_err_cnt = 0;

	return size;
}

static ssize_t tsl2511_curr_adc_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE,
			"\"HRIC\":\"%d\",\"HRRC\":\"%d\",\"HRIA\":\"%d\",\"HRRA\":\"%d\"\n",
			0, 0, data->user_ir_data, data->user_flicker_data);
}

static ssize_t tsl2511_curr_adc_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	data->user_ir_data = 0;
	data->user_flicker_data = 0;

	return size;
}

static ssize_t tsl2511_mode_cnt_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE,
			"\"CNT_HRM\":\"%d\",\"CNT_AMB\":\"%d\",\"CNT_PROX\":\"%d\",\"CNT_SDK\":\"%d\",\"CNT_CGM\":\"%d\",\"CNT_UNKN\":\"%d\"\n",
			data->mode_cnt.hrm_cnt, data->mode_cnt.amb_cnt, data->mode_cnt.prox_cnt,
			data->mode_cnt.sdk_cnt, data->mode_cnt.cgm_cnt, data->mode_cnt.unkn_cnt);
}

static ssize_t tsl2511_mode_cnt_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	data->mode_cnt.hrm_cnt = 0;
	data->mode_cnt.amb_cnt = 0;
	data->mode_cnt.prox_cnt = 0;
	data->mode_cnt.sdk_cnt = 0;
	data->mode_cnt.cgm_cnt = 0;
	data->mode_cnt.unkn_cnt = 0;

	return size;
}

static ssize_t tsl2511_factory_cmd_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	static int cmd_result;

	mutex_lock(&data->activelock);

	if (data->isTrimmed)
		cmd_result = 1;
	else
		cmd_result = 0;

	ALS_dbg("%s - cmd_result = %d\n", __func__, cmd_result);

	mutex_unlock(&data->activelock);

	return snprintf(buf, PAGE_SIZE, "%d\n", cmd_result);
}

static ssize_t tsl2511_version_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ALS_info("%s - cmd_result = %s.%s.%s%s\n", __func__,
			VERSION, SUB_VERSION, HEADER_VERSION, VENDOR_VERSION);

	return snprintf(buf, PAGE_SIZE, "%s.%s.%s%s\n",
			VERSION, SUB_VERSION, HEADER_VERSION, VENDOR_VERSION);
}

static ssize_t tsl2511_sensor_info_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ALS_dbg("%s - sensor_info_data not support\n", __func__);

	return snprintf(buf, PAGE_SIZE, "NOT SUPPORT\n");
}



#if IS_ENABLED(CONFIG_SENSORS_FLICKER_SELF_TEST)
static struct result_data *eol_result = NULL;

static ssize_t tsl2511_eol_mode_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	if (data->eol_enabled) {
		snprintf(buf, MAX_TEST_RESULT, "EOL_RUNNING");
	} else if (eol_result == NULL) {
		snprintf(buf, MAX_TEST_RESULT, "NO_EOL_TEST");
	} else {
		snprintf(buf, MAX_TEST_RESULT, "%d, %s, %d, %s, %d, %s, %d, %s, %d, %s, %d, %s, %d, %s, %d, %s, %d, %s, %d, %s\n",
				eol_result->flicker[EOL_STATE_100], FREQ100_SPEC_IN(eol_result->flicker[EOL_STATE_100]),
				eol_result->flicker[EOL_STATE_120], FREQ120_SPEC_IN(eol_result->flicker[EOL_STATE_120]),
				eol_result->wideband[EOL_STATE_100], WIDE_SPEC_IN(eol_result->wideband[EOL_STATE_100]),
				eol_result->wideband[EOL_STATE_120], WIDE_SPEC_IN(eol_result->wideband[EOL_STATE_120]),
				eol_result->clear[EOL_STATE_100], CLEAR_SPEC_IN(eol_result->clear[EOL_STATE_100]),
				eol_result->clear[EOL_STATE_120], CLEAR_SPEC_IN(eol_result->clear[EOL_STATE_120]),
				eol_result->ratio[EOL_STATE_100], ICRATIO_SPEC_IN(eol_result->ratio[EOL_STATE_100]),
				eol_result->ratio[EOL_STATE_120], ICRATIO_SPEC_IN(eol_result->ratio[EOL_STATE_120]),
				eol_result->uv[EOL_STATE_100], UV_SPEC_IN(eol_result->uv[EOL_STATE_100]),
				eol_result->uv[EOL_STATE_120], UV_SPEC_IN(eol_result->uv[EOL_STATE_120]));

		eol_result = NULL;
	}
	ALS_dbg("%s", buf);

	return MAX_TEST_RESULT;
}

static ssize_t tsl2511_eol_mode_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	ams_deviceCtx_t *ctx = data->deviceCtx;
	int err = 0;
	static int prev_sensor_mode = 0, prev_state = 0;
	ssize_t ret = 0;
	ALS_info("%s - en : %d\n", __func__, data->enabled);

	data->eol_enabled = true;
	prev_sensor_mode = data->sensor_mode;
	data->sensor_mode = 0;
	tsl2511_start(data);

	AMS_AGC_AZ_MODE(0x00, err);//agc az disable
	if (err < 0)
		ALS_err("%s - failed to disable AGC\n", __func__);
	AMS_SET_STEP0_ALS_GAIN0(EOL_GAIN, err);
	if (err < 0)
		ALS_err("%s - failed to AMS_SET_STEP0_ALS_GAIN0\n", __func__);
	AMS_SET_STEP0_ALS_GAIN1(EOL_GAIN, err);
	if (err < 0)
		ALS_err("%s - failed to AMS_SET_STEP0_ALS_GAIN1\n", __func__);
	AMS_SET_STEP0_ALS_GAIN2(EOL_GAIN, err);
	if (err < 0)
		ALS_err("%s - failed to AMS_SET_STEP0_ALS_GAIN2\n", __func__);
	AMS_SET_STEP1_ALS_GAIN0(EOL_GAIN, err);
	if (err < 0)
		ALS_err("%s - failed to AMS_SET_STEP1_ALS_GAIN0\n", __func__);
	AMS_SET_STEP1_ALS_GAIN1(EOL_GAIN, err);
	if (err < 0)
		ALS_err("%s - failed to AMS_SET_STEP1_ALS_GAIN1\n", __func__);
	AMS_SET_STEP1_ALS_GAIN2(EOL_GAIN, err);
	if (err < 0)
		ALS_err("%s - failed to AMS_SET_STEP1_ALS_GAIN2\n", __func__);
	ALS_info("%s - fixed ALS GAIN : %d\n", __func__, EOL_GAIN);
	//tsl2511_print_reg_status();

	als_eol_set_env(true, 80);
	eol_result = als_eol_mode();

	AMS_AGC_AZ_MODE(MASK_MOD_CALIB_NTH_ITERATION_AZ_ENABLE | MASK_MOD_CALIB_NTH_ITERATION_AGC_ENABLE, err);
	if (err < 0)
		ALS_err("%s - failed to enable AGC", __func__);

	err = tsl2511_stop(data);
	if (err < 0)
		ALS_err("%s - err in stop", __func__);

	data->sensor_mode = prev_sensor_mode;
	data->eol_enabled = false;

	return size;
}
#endif

static ssize_t tsl2511_bk_kcoef_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->sum_bk_bkCal_kcoef);
}



static ssize_t tsl2511_bk_kcoef_store (struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	ams_deviceCtx_t *ctx = data->deviceCtx;

	int sensor_mode = 0;
	int err = 0;
	int prev_state = 0;

	prev_state = data->enabled;

	if (data->enabled > 0) {
		tsl2511_stop(data);
	}
	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &sensor_mode);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}

	ctx->sum_bk_bkCal_kcoef = data->sum_bk_bkCal_kcoef = sensor_mode;
	ALS_dbg("%s - sum_bk_bkCal_kcoef %d data->enabled %d prev_state %d \n", __func__, ctx->sum_bk_bkCal_kcoef,data->enabled,prev_state);

	mutex_unlock(&data->activelock);

	if (prev_state > 0) {
		tsl2511_start(data);
	}

	return size;
}

static ssize_t tsl2511_bk_offset_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);

	return snprintf(buf, PAGE_SIZE, "%d\n", data->sum_bk_bkCal_offset);
}



static ssize_t tsl2511_bk_offset_store (struct device *dev,
		struct device_attribute *attr,
		const char *buf, size_t size)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	ams_deviceCtx_t *ctx = data->deviceCtx;

	int sensor_mode = 0;
	int err = 0;
	int prev_state = 0;

	prev_state = data->enabled;

	if (data->enabled > 0) {
		tsl2511_stop(data);
	}
	mutex_lock(&data->activelock);

	err = kstrtoint(buf, 10, &sensor_mode);

	if (err < 0) {
		ALS_err("%s - kstrtoint failed.(%d)\n", __func__, err);
		mutex_unlock(&data->activelock);
		return err;
	}

	ctx->sum_bk_bkCal_offset = data->sum_bk_bkCal_offset = sensor_mode;
	ALS_dbg("%s - offset %d data->enabled %d prev_state %d \n", __func__, ctx->sum_bk_bkCal_offset,data->enabled,prev_state);

	mutex_unlock(&data->activelock);

	if (prev_state > 0) {
		tsl2511_start(data);
	}

	return size;
}



static DEVICE_ATTR(name, S_IRUGO, tsl2511_name_show, NULL);
static DEVICE_ATTR(vendor, S_IRUGO, tsl2511_vendor_show, NULL);
static DEVICE_ATTR(als_flush, S_IWUSR | S_IWGRP, NULL, tsl2511_flush_store);
static DEVICE_ATTR(int_pin_check, S_IRUGO, tsl2511_int_pin_check_show, NULL);
static DEVICE_ATTR(read_reg, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2511_read_reg_show, tsl2511_read_reg_store);
static DEVICE_ATTR(write_reg, S_IWUSR | S_IWGRP, NULL, tsl2511_write_reg_store);
static DEVICE_ATTR(als_debug, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2511_debug_show, tsl2511_debug_store);
static DEVICE_ATTR(device_id, S_IRUGO, tsl2511_device_id_show, NULL);
static DEVICE_ATTR(part_type, S_IRUGO, tsl2511_part_type_show, NULL);
static DEVICE_ATTR(i2c_err_cnt, S_IRUGO | S_IWUSR | S_IWGRP, tsl2511_i2c_err_show, tsl2511_i2c_err_store);
static DEVICE_ATTR(curr_adc, S_IRUGO | S_IWUSR | S_IWGRP, tsl2511_curr_adc_show, tsl2511_curr_adc_store);
static DEVICE_ATTR(mode_cnt, S_IRUGO | S_IWUSR | S_IWGRP, tsl2511_mode_cnt_show, tsl2511_mode_cnt_store);
static DEVICE_ATTR(als_factory_cmd, S_IRUGO, tsl2511_factory_cmd_show, NULL);
static DEVICE_ATTR(als_version, S_IRUGO, tsl2511_version_show, NULL);
static DEVICE_ATTR(sensor_info, S_IRUGO, tsl2511_sensor_info_show, NULL);
static DEVICE_ATTR(als_ir, S_IRUGO, als_ir_show, NULL);
static DEVICE_ATTR(als_red, S_IRUGO, als_red_show, NULL);
static DEVICE_ATTR(als_green, S_IRUGO, als_green_show, NULL);
static DEVICE_ATTR(als_blue, S_IRUGO, als_blue_show, NULL);
static DEVICE_ATTR(als_clear, S_IRUGO, als_clear_show, NULL);
static DEVICE_ATTR(als_wideband, S_IRUGO, als_wideband_show, NULL);
static DEVICE_ATTR(als_uv, S_IRUGO, als_uv_show, NULL);
static DEVICE_ATTR(als_raw_data, S_IRUGO, als_raw_data_show, NULL);
#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
static DEVICE_ATTR(flicker_data, S_IRUGO, flicker_data_show, NULL);
#endif
#if IS_ENABLED(CONFIG_SENSORS_FLICKER_SELF_TEST)
static DEVICE_ATTR(eol_mode, S_IRUGO | S_IWUSR | S_IWGRP, tsl2511_eol_mode_show, tsl2511_eol_mode_store);
#endif
#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
static DEVICE_ATTR(als_enable, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2511_als_enable_show, tsl2511_als_enable_store);
static DEVICE_ATTR(als_data, S_IRUGO, tsl2511_als_data_show, NULL);

/*ams debug*/
static DEVICE_ATTR(bk_offset_mode, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2511_bk_offset_show, tsl2511_bk_offset_store);
static DEVICE_ATTR(bk_kcoef_mode, S_IRUGO | S_IWUSR | S_IWGRP,
		tsl2511_bk_kcoef_show, tsl2511_bk_kcoef_store);
#endif

static struct device_attribute *tsl2511_sensor_attrs[] = {
	&dev_attr_name,
	&dev_attr_vendor,
	&dev_attr_als_flush,
	&dev_attr_int_pin_check,
	&dev_attr_read_reg,
	&dev_attr_write_reg,
	&dev_attr_als_debug,
	&dev_attr_device_id,
	&dev_attr_part_type,
	&dev_attr_i2c_err_cnt,
	&dev_attr_curr_adc,
	&dev_attr_mode_cnt,
	&dev_attr_als_factory_cmd,
	&dev_attr_als_version,
	&dev_attr_sensor_info,
	&dev_attr_als_ir,
	&dev_attr_als_red,
	&dev_attr_als_green,
	&dev_attr_als_blue,
	&dev_attr_als_clear,
	&dev_attr_als_wideband,
	&dev_attr_als_uv,
	&dev_attr_als_raw_data,
#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
	&dev_attr_flicker_data,
#endif
#if IS_ENABLED(CONFIG_SENSORS_FLICKER_SELF_TEST)
	&dev_attr_eol_mode,
#endif
#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
	&dev_attr_als_enable,
	&dev_attr_als_data,
#endif
	&dev_attr_bk_offset_mode,
	&dev_attr_bk_kcoef_mode,
	NULL,
};
static int _2511_handleAlsEvent(ams_deviceCtx_t *ctx);
static void _2511_handleFIFOEvent(ams_deviceCtx_t *ctx);

static void _2511_handleFIFOEvent(ams_deviceCtx_t *ctx)
{
	int err =0;
	int clear_gain;
	int wideband_gain;
	int fifo_mod0_gain;
	int fifo_mod1_gain;
#ifdef CONFIG_AMS_OPTICAL_SENSOR_2511_UVA
	int uv_gain;
	int fifo_mod2_gain;
#endif
	amsAlsDataSet_t inputData;
	adcDataSet_t dataSet;

	inputData.status = ALS_STATUS_RDY;
	inputData.datasetArray = (alsData_t *)&dataSet;

	ccb_FIFOEvent(ctx);

	if(ctx->flickerCtx.data_ready == 1) {

		AMS_ENABLE_PON(err);
		if (err < 0) {
			ALS_err("%s - failed to AMS_ENABLE_PON\n", __func__);
		}

		ccb_sw_bin4096_flicker_GetResult(ctx);
		ctx->updateAvailable |= (1 << AMS_FLICKER_SENSOR);
		ctx->mod1_step_counter = 0;
		ams_tsl2511_auto_gain_max_samples(ctx);
		ctx->flickerCtx.max_samples.y_max =0 ;
		ctx->flickerCtx.max_samples.ir_max =0 ;
		ctx->flickerCtx.max_samples.bk_max =0 ;
		ctx->flickerCtx.max_samples.uva_max =0 ;
		AMS_REENABLE_FD_PON(err);
		if (err < 0) {
			ALS_err("%s - failed to AMS_REENABLE_FD_PON\n", __func__);
		}

	} else if(ctx->flickerCtx.als_data_ready == 1) {
		ctx->updateAvailable |= (1 << AMS_AMBIENT_SENSOR);
	}
}

static int ams_devicePollingHandler(struct tsl2511_device_data *data)
{
	int ret = 0;
	uint8_t vsync_cfg;
	//uint8_t bypass = 0;
	uint8_t save=0;
	uint8_t step0_gain_low=0;
	uint8_t step0_gain_high=0;

	uint8_t step1_gain_low=0;
	uint8_t step1_gain_high=0;

	ams_deviceCtx_t *ctx = data->deviceCtx;

	ret = ams_getByte(ctx->portHndl, DEVREG_STATUS, &ctx->shadowStatus1Reg);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_STATUS\n", __func__);
		return ret;
	}

	ret = ams_getByte(ctx->portHndl, DEVREG_STATUS2, &ctx->shadowStatus2Reg);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_STATUS2\n", __func__);
		return ret;
	}

	ret = ams_getByte(ctx->portHndl, DEVREG_STATUS3, &ctx->shadowStatus3Reg);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_STATUS3\n", __func__);
		return ret;
	}

	ret = ams_getByte(ctx->portHndl, DEVREG_STATUS5, &ctx->shadowStatus5Reg);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_STATUS5\n", __func__);
		return ret;
	}

	ret = ams_getByte(ctx->portHndl, DEVREG_VSYNC_CONTROL, &ctx->vsyncControl);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_VSYNC_CONTROL\n", __func__);
		return ret;
	}

 	ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS,	&ctx->shadowAlsStatusReg);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_ALS_STATUS\n", __func__);
		return ret;
	}

	ret = ams_getByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L,	&step0_gain_low);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_ALS_STATUS\n", __func__);
		return ret;
	}

	ret = ams_getByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_H,	&step0_gain_high);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_ALS_STATUS\n", __func__);
		return ret;
	}

	ret = ams_getByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_L,	&step1_gain_low);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_ALS_STATUS\n", __func__);
		return ret;
	}

	ret = ams_getByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP1_MOD_GAINX_H,	&step1_gain_high);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_ALS_STATUS\n", __func__);
		return ret;
	}

	ctx->flickerCtx.als_raw_data.y_gain =  step0_gain_low & 0x0F;
	ctx->flickerCtx.als_raw_data.ir_gain =  ((step0_gain_low & 0xF0) >> 4);
	ctx->flickerCtx.als_raw_data.uva_gain =  step0_gain_high & 0x0F;
	ctx->flickerCtx.als_raw_data.bk_gain =  ((step1_gain_low & 0xF0) >> 4);

	ALS_info("%s : y_gain 0x%x, ir_gain 0x%x , bk_gain 0x%x, uv_gain  0x%x\n", __func__,ctx->flickerCtx.als_raw_data.y_gain,ctx->flickerCtx.als_raw_data.ir_gain,ctx->flickerCtx.als_raw_data.bk_gain,ctx->flickerCtx.als_raw_data.uva_gain);

	//ALS_info("%s step0 gainL  0x%x,  gainH 0x%x  , step1 gainL 0x%x, gainH 0x%x\n", __func__,step0_gain_low,step0_gain_high,step1_gain_low,step1_gain_high);
	ALS_info("%s - STATUS = 0x%x , STATUS2 = 0x%x ,STATUS3 = 0x%x ,STATUS5 = 0x%x ,Vsync = 0x%x , ALS_STATUS = 0x%x \n", __func__,
		ctx->shadowStatus1Reg, ctx->shadowStatus2Reg, ctx->shadowStatus3Reg, ctx->shadowStatus5Reg,ctx->vsyncControl,ctx->shadowAlsStatusReg);
	if (ctx->shadowStatus1Reg & SINT) {
		/* check status5 and status3*/
		//if (ctx->shadowStatus5Reg & TSL2511_REG_STATUS5__sint_vsync__MASK ) {
		if ((ctx->vsyncControl == 0x00) && (ctx->internal_clock_once == false)) {//internal clock status
			if (ctx->shadowStatus3Reg&TSL2511_REG_STATUS3__vsync_lost__MASK) {
				ALS_info("%s will change external to internal colock \n", __func__);
				ams_getByte(ctx->portHndl, DEVREG_ENABLE, &save);
				ams_setByte(ctx->portHndl, DEVREG_ENABLE, 0);
				ams_getByte(ctx->portHndl, DEVREG_VSYNC_CFG, &vsync_cfg);
				ams_setByte(ctx->portHndl, DEVREG_CFG7, MOD_DIV_SEL_1); // 1/12  , internal clock 720khz

				/* vsync_lost occurred, set configuration and reset FIFO */
				//tsl2511_set_sample_time(chip, (uint16_t)DEFAULT_SAMPLE_TIME_INT_CLK);
				tsl2511_set_sampling_time(data, (uint16_t)DEFAULT_SAMPLE_TIME_INT_CLK);
				//AMS_SET_SAMPLE_TIME(DEFAULT_SAMPLE_TIME_INT_CLK,ret);
				//chip->clk_period_ns = TSL2511_MODCLK_PERIOD_NS;
				/* set to HW_SYNC_MODE */
				vsync_cfg &= ~(TSL2511_REG_VSYNC_CFG__osc_calib_mode__MASK<<TSL2511_REG_VSYNC_CFG__osc_calib_mode__SHIFT);
				vsync_cfg &= ~(TSL2511_REG_VSYNC_CFG__extclk_as_sysclk__MASK<<TSL2511_REG_VSYNC_CFG__extclk_as_sysclk__SHIFT);
				vsync_cfg &= ~(TSL2511_REG_VSYNC_CFG__vsync_mode__MASK<<TSL2511_REG_VSYNC_CFG__vsync_mode__SHIFT);
				vsync_cfg |= (TSL2511_HW_SYNC_MODE<<TSL2511_REG_VSYNC_CFG__vsync_mode__SHIFT);
				ams_setByte(ctx->portHndl, DEVREG_VSYNC_CFG, vsync_cfg);
				kfifo_reset(&ams_fifo);
				AMS_FIFO_CLEAR(ret);
				ctx->mod1_step_counter = 0;
				ams_setByte(ctx->portHndl, DEVREG_INTENAB, SIEN|FIEN); //internal clock case, need to interrupt enable, external case, doesnt need to interrupt enable.
				if (data->eol_enabled == true) {
					ams_setByte(ctx->portHndl, DEVREG_ENABLE, FDEN|PON);
				} else {
					ams_setByte(ctx->portHndl, DEVREG_ENABLE, save);
				}
				/* not execute irq in this situation */
				ctx->internal_clock_once = true;
				//bypass = 1;
				usleep_range(1000, 1100);
			}
		}
	}

	/***************************************************************************************/
	if (ctx->shadowStatus1Reg & FINT) {
		ALS_info("%s - _2511_handleFIFOEvent \n", __func__);
		_2511_handleFIFOEvent(ctx);
	}

	if ((ctx->shadowStatus2Reg & ALS_DATA_VALID) /*|| ctx->alwaysReadAls*/) {
		ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS, &ctx->shadowAlsStatusReg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_ALS_STATUS\n", __func__);
			return ret;
		}

		ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS2, &ctx->shadowAlsStatus2Reg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_ALS_STATUS2\n", __func__);
			return ret;
		}

		if (ctx->mode & MODE_ALS_ALL) {
			ALS_info("%s - _2511_handleAlsEvent :%d alwaysReadAls = %d\n", __func__, (ctx->shadowStatus1Reg & AINT), ctx->alwaysReadAls);
			ret = _2511_handleAlsEvent(ctx);
			if (ret < 0) {
				ALS_err("%s - failed to _2511_handleAlsEvent\n", __func__);
				//return ret;
			}
		}
	}

	ret = ams_setByte(ctx->portHndl, DEVREG_STATUS, ctx->shadowStatus1Reg);
	if (ret < 0) {
		ALS_err("%s - failed to set DEVREG_STATUS\n", __func__);
		return ret;
	}

	ret = ams_setByte(ctx->portHndl, DEVREG_STATUS2, ctx->shadowStatus2Reg);
	if (ret < 0) {
		ALS_err("%s - failed to set DEVREG_STATUS2\n", __func__);
		return ret;
	}

	ret = ams_setByte(ctx->portHndl, DEVREG_STATUS3, ctx->shadowStatus3Reg);
	if (ret < 0) {
		ALS_err("%s - failed to set DEVREG_STATUS3\n", __func__);
		return ret;
	}
	return 0;

	ret = ams_setByte(ctx->portHndl, DEVREG_STATUS5, ctx->shadowStatus5Reg);
	if (ret < 0) {
		ALS_err("%s - failed to set DEVREG_STATUS5\n", __func__);
		return ret;
	}
	return 0;

	ret = ams_setByte(ctx->portHndl, DEVREG_VSYNC_CONTROL, ctx->vsyncControl);
	if (ret < 0) {
		ALS_err("%s - failed to set DEVREG_VSYNC_CONTROL\n", __func__);
		return ret;
	}
	return 0;
}


static int ams_deviceEventHandler(ams_deviceCtx_t *ctx)
{
	int ret = 0;
#if 0//not used anymore
	uint8_t status5 = 0;

	ret = ams_getByte(ctx->portHndl, DEVREG_STATUS, &ctx->shadowStatus1Reg);

	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_STATUS\n", __func__);
		return ret;
	}

	ret = ams_getByte(ctx->portHndl, DEVREG_STATUS2, &ctx->shadowStatus2Reg);

	//ret = ams_getByte(ctx->portHndl, DEVREG_MEAS_SEQR_STEP0_MOD_GAINX_L, &ctx->fifo_mod0_gain);
	//ret = ams_getByte(ctx->portHndl, DEVREG_MOD_GAIN_H, &ctx->fifo_mod1_gain);

	//clear_gain = tsl2511_gain_conversion[ctx->fifo_mod0_gain];
	//wideband_gain = tsl2511_gain_conversion[ctx->fifo_mod1_gain];


	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_STATUS\n", __func__);
		return ret;
	}

	if (ctx->shadowStatus1Reg & SINT) {
		ret = ams_getByte(ctx->portHndl, DEVREG_STATUS5, &status5);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_STATUS5\n", __func__);
			return ret;
		}
		ALS_info("%s - ctx->shadowStatus1Reg %x, status5 %x, mode %x", __func__, ctx->shadowStatus1Reg, status5, ctx->mode);
	}

loop:
	ALS_info("%s - loop: DCB 0x%02x, STATUS 0x%02x, ALS_STATUS 0x%02x, ALS_STATUS2 0x%02x\n", __func__, ctx->mode, ctx->shadowStatus1Reg, ctx->shadowAlsStatusReg, ctx->shadowAlsStatus2Reg);


#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
	if (ctx->shadowStatus1Reg & FINT) {
		ret = ams_getByte(ctx->portHndl, DEVREG_FIFO_STATUS0, &ctx->shadowFIFOStatusReg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_FIFO_STATUS0\n", __func__);
			//return ret;
		}
		if (ctx->mode & MODE_FLICKER) {
			ALS_info("%s - _2511_handleFIFOEvent \n", __func__);
			_2511_handleFIFOEvent(ctx);
		}
	}
#endif

	//if ((ctx->shadowStatus1Reg & AINT) /*|| ctx->alwaysReadAls*/) {
	if ((ctx->shadowStatus2Reg & ALS_DATA_VALID) /*|| ctx->alwaysReadAls*/) {
		ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS, &ctx->shadowAlsStatusReg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_ALS_STATUS\n", __func__);
			return ret;
		}
		ret = ams_getByte(ctx->portHndl, DEVREG_ALS_STATUS2, &ctx->shadowAlsStatus2Reg);
		if (ret < 0) {
			ALS_err("%s - failed to get DEVREG_ALS_STATUS2\n", __func__);
			return ret;
		}
		if (ctx->mode & MODE_ALS_ALL) {
			ALS_info("%s - _2511_handleAlsEvent :%d alwaysReadAls = %d\n", __func__, (ctx->shadowStatus1Reg & AINT), ctx->alwaysReadAls);
			ret = _2511_handleAlsEvent(ctx);
			if (ret < 0) {
				ALS_err("%s - failed to _2511_handleAlsEvent\n", __func__);
				//return ret;
			}
		}
	}

	/* Clear Processed Interrupt */
	/* this clears interrupt(s) and STATUS5 */
	if (ctx->shadowStatus1Reg != 0) {
		/* this clears interrupt(s) and STATUS5 */
		ret = ams_setByte(ctx->portHndl, DEVREG_STATUS, ctx->shadowStatus1Reg);
		if (ret < 0) {
			ALS_err("%s - failed to set DEVREG_STATUS\n", __func__);
			return ret;
		}
	}

	if (status5 != 0) {
		ret = ams_setByte(ctx->portHndl, DEVREG_STATUS5, status5);
		if (ret < 0) {
			ALS_err("%s - failed to set DEVREG_STATUS5\n", __func__);
			return ret;
		}
	}

	/* Check Remainning Interrupt */
	ret = ams_getByte(ctx->portHndl, DEVREG_STATUS, &ctx->shadowStatus1Reg);
	if (ret < 0) {
		ALS_err("%s - failed to get DEVREG_STATUS\n", __func__);
		return ret;
	}
	if (ctx->shadowStatus1Reg != 0) {
		ALS_err("%s - goto loop", __func__);
		goto loop;
	}

	/*
	 *	the individual handlers may have temporarily disabled things
	 *	AMS_REENABLE(ret);
	 *	if (ret < 0) {
	 *		ALS_err("%s - failed to AMS_REENABLE\n", __func__);
	 *		return ret;
	 *	}
	 */
	#endif
	return ret;
}


irqreturn_t tsl2511_irq_handler(int dev_irq, void *device)
{
	int err;
	struct tsl2511_device_data *data = device;
	int interruptsHandled = 0;

	ALS_info("%s - als_irq = %d\n", __func__, dev_irq);

	if (data->regulator_state == 0) {
		ALS_dbg("%s - stop irq handler (reg_state : %d, enabled : %d)\n",
				__func__, data->regulator_state, data->enabled);
		return IRQ_HANDLED;
	} else if (data->enabled == 0) {
		ALS_dbg("%s - ALS not enabled, clear irq (regulator_state : %d, enabled : %d)",
				__func__, data->regulator_state, data->enabled);
		ams_setByte(data->client, DEVREG_STATUS, AMS_ALL_INT);
		return IRQ_HANDLED;
	}

	//mutex_lock(&data->activelock);

	err = ams_deviceEventHandler(data->deviceCtx);
	interruptsHandled = ams_getResult(data->deviceCtx);

	if (err == 0) {
		if (data->als_input_dev == NULL) {
			ALS_err("%s - als_input_dev is NULL\n", __func__);
		}
		else {
#if defined(CONFIG_AMS_OPTICAL_SENSOR_ALS)
			if (interruptsHandled & (1 << AMS_AMBIENT_SENSOR))
				report_als(data);
#endif

#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
			if (interruptsHandled & (1 << AMS_FLICKER_SENSOR)){
				report_flicker(data);


			}

			if (interruptsHandled & (1 << AMS_SW_FLICKER_SENSOR)) {
				report_als(data);

				msleep_interruptible(30);
				/* HwModuleTest need this delay to distinguish ALS / Flicker */
				report_flicker(data);

				if(data->eol_enabled == true){
				data->eol_set_count--;

					if(data->eol_set_count==0){
						//tsl2511_stop(data);
						//als_enable_set(data, AMSDRIVER_ALS_DISABLE);
						//disable_irq(data->dev_irq);
						data->eol_enabled = false;
					}
				}
			}
#endif
		}
	} else {
		ALS_err("%s - ams_deviceEventHandler failed\n", __func__);
	}

	//mutex_unlock(&data->activelock);

	return IRQ_HANDLED;
}

#if defined(CONFIG_AMS_OPTICAL_SENSOR_POLLING)
static void tsl2511_work_func_light(struct work_struct *work)
{
	int err;
	//    int lux;
	int pollingHandled = 0;

	struct tsl2511_device_data *data
		= container_of(work, struct tsl2511_device_data, work_light);
	//ALS_info("%s -msec \n", __func__);

	// testing
	//return 0;
	if (data->regulator_state == 0 || data->enabled == 0) {
		ALS_dbg("%s - stop irq handler (reg_state : %d, enabled : %d)\n",
				__func__, data->regulator_state, data->enabled);

		ams_setByte(data->client, DEVREG_STATUS, (AINT | AMS_ALL_INT));
	}

	mutex_lock(&data->flickerdatalock);

	err = ams_devicePollingHandler(data);
	pollingHandled = ams_getResult(data->deviceCtx);

	if (err == 0) {
		if (data->als_input_dev == NULL) {
			ALS_err("%s - als_input_dev is NULL\n", __func__);
		} else {
#if defined(CONFIG_AMS_OPTICAL_SENSOR_ALS)
			if (pollingHandled & (1 << AMS_AMBIENT_SENSOR)) {
				report_als(data);
			}
#endif

#if defined(CONFIG_AMS_OPTICAL_SENSOR_FLICKER)
			if (pollingHandled & (1 << AMS_FLICKER_SENSOR))
				report_flicker(data);
#endif
		}
	} else {
		ALS_err("%s - ams_deviceEventHandler failed\n", __func__);
	}

	mutex_unlock(&data->flickerdatalock);
}

static enum hrtimer_restart tsl2511_timer_func(struct hrtimer *timer)
{
	struct tsl2511_device_data *data = container_of(timer, struct tsl2511_device_data, timer);
	queue_work(data->wq, &data->work_light);
	hrtimer_forward_now(&data->timer, data->light_poll_delay);
	return HRTIMER_RESTART;
}
#endif

#if 0
static int tsl2511_setup_irq(struct tsl2511_device_data *data)
{
	int errorno = -EIO;
	errorno = request_threaded_irq(data->dev_irq, NULL,
			tsl2511_irq_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
			"als_rear_sensor_irq", data);

	if (errorno < 0) {
		ALS_err("%s - failed for setup dev_irq errono= %d\n",
				__func__, errorno);
		errorno = -ENODEV;
		return errorno;
	}

	disable_irq(data->dev_irq);

	return errorno;
}
#endif

static void tsl2511_init_var(struct tsl2511_device_data *data)
{
	data->client = NULL;
	data->dev = NULL;
	data->als_input_dev = NULL;
	data->als_pinctrl = NULL;
	data->pins_sleep = NULL;
	data->pins_active = NULL;
	data->enabled = 0;
	data->sampling_period_ns = 0;
	data->regulator_state = 0;
	data->regulator_vbus_1p8 = NULL;
	data->regulator_vdd_1p8 = NULL;
	data->vbus_1p8_enable = false;
	data->vdd_1p8_enable = false;
	data->irq_state = 0;
	data->suspend_cnt = 0;
	data->reg_read_buf = 0;
	data->pm_state = PM_RESUME;
	data->i2c_err_cnt = 0;
	data->user_ir_data = 0;
	data->user_flicker_data = 0;
	data->awb_sample_cnt = 0;
	data->flicker_data_cnt = 0;
	//flicker_data_cnt = 0;
	data->saturation = false;
	data->timer_is_exist = false;
	data->timer_is_active = false;
}

static int tsl2511_parse_dt(struct tsl2511_device_data *data)
{
	struct device *dev = &data->client->dev;
	struct device_node *dNode = dev->of_node;
	struct device_node *vbus_of_node = NULL;
	struct device_node *vdd_of_node = NULL;
#if IS_ENABLED(CONFIG_OF)
	enum of_gpio_flags flags;

	if (dNode == NULL)
		return -ENODEV;
#endif 	/* CONFIG_OF */


	vbus_of_node = of_parse_phandle(dNode, "vbus_1p8-supply", 0);
	if (vbus_of_node) {
		data->regulator_vbus_1p8 = regulator_get(&data->client->dev, "vbus_1p8");
		if (IS_ERR(data->regulator_vbus_1p8) || data->regulator_vbus_1p8 == NULL) {
			ALS_err("%s - get vbus_1p8 regulator failed\n", __func__);
			data->regulator_vbus_1p8 = NULL;
		} else {
			ALS_dbg("%s - get vbus_1p8 regulator = %p done \n", __func__, data->regulator_vbus_1p8);
		}
	}

	vdd_of_node = of_parse_phandle(dNode, "vdd_1p8-supply", 0);
	if (vdd_of_node) {
		data->regulator_vdd_1p8 = regulator_get(&data->client->dev, "vdd_1p8");
		if (IS_ERR(data->regulator_vdd_1p8) || data->regulator_vdd_1p8 == NULL) {
			ALS_err("%s - get vdd_1p8 regulator failed\n", __func__);
			data->regulator_vdd_1p8 = NULL;
			return -ENODEV;
		} else {
			ALS_dbg("%s - get vdd_1p8 regulator = %p done \n", __func__, data->regulator_vdd_1p8);
		}
	}

	data->pin_flicker_1p8_en = of_get_named_gpio_flags(dNode, "flicker_1p8_en_gpio", 0, &flags);
	if (data->pin_flicker_1p8_en >= 0) {
		data->als_pinctrl = devm_pinctrl_get(dev);
		if (IS_ERR_OR_NULL(data->als_pinctrl)) {
			ALS_err("%s - get pinctrl(%li) error\n",
					__func__, PTR_ERR(data->als_pinctrl));
			data->als_pinctrl = NULL;
			return -EINVAL;
		}

		data->pins_sleep = pinctrl_lookup_state(data->als_pinctrl, "sleep");
		if (IS_ERR_OR_NULL(data->pins_sleep)) {
			ALS_info("%s - get pins_sleep(%li) error\n",
					__func__, PTR_ERR(data->pins_sleep));
			devm_pinctrl_put(data->als_pinctrl);
			data->pins_sleep = NULL;
			return -EINVAL;
		}

		data->pins_active = pinctrl_lookup_state(data->als_pinctrl, "active");
		if (IS_ERR_OR_NULL(data->pins_active)) {
			ALS_info("%s - get pins_active(%li) error\n",
					__func__, PTR_ERR(data->pins_active));

			devm_pinctrl_put(data->als_pinctrl);
			data->pins_active = NULL;
			return -EINVAL;
		}
	} else {
		data->als_pinctrl = NULL;
		ALS_info("%s - get pin_flicker_1p8_en error\n", __func__);
	}

	ALS_dbg("%s - done.\n", __func__);

	return 0;
}

static int _2511_alsInit(ams_deviceCtx_t *ctx, ams_calibrationData_t *calibrationData)
{
	int ret = 0;

	if (calibrationData == NULL) {
		ams_ccb_als_info_t infoData;

		ALS_info("%s - calibrationData is null\n", __func__);
		ccb_alsInfo(&infoData);
		ctx->ccbAlsCtx.initData.calibrationData.calibrationFactor = infoData.defaultCalibrationData.calibrationFactor;
		ctx->ccbAlsCtx.initData.calibrationData.Time_base = infoData.defaultCalibrationData.Time_base;
		ctx->ccbAlsCtx.initData.calibrationData.thresholdLow = infoData.defaultCalibrationData.thresholdLow;
		ctx->ccbAlsCtx.initData.calibrationData.thresholdHigh = infoData.defaultCalibrationData.thresholdHigh;
		ctx->ccbAlsCtx.initData.calibrationData.calibrationFactor = infoData.defaultCalibrationData.calibrationFactor;
	}
	else {
		ALS_info("%s - calibrationData is non-null\n", __func__);
		//ctx->ccbAlsCtx.initData.calibrationData.luxTarget = calibrationData->alsCalibrationLuxTarget;
		//ctx->ccbAlsCtx.initData.calibrationData.luxTargetError = calibrationData->alsCalibrationLuxTargetError;
		ctx->ccbAlsCtx.initData.calibrationData.calibrationFactor = calibrationData->alsCalibrationFactor;
		ctx->ccbAlsCtx.initData.calibrationData.Time_base = calibrationData->timeBase_us;
		ctx->ccbAlsCtx.initData.calibrationData.thresholdLow = calibrationData->alsThresholdLow;
		ctx->ccbAlsCtx.initData.calibrationData.thresholdHigh = calibrationData->alsThresholdHigh;
	}
	ctx->ccbAlsCtx.initData.calibrate = false;
	//ctx->ccbAlsCtx.initData.configData.gain = 64000;//AGAIN
	ctx->ccbAlsCtx.initData.configData.gain = 16000;//AGAIN
	ctx->ccbAlsCtx.initData.configData.uSecTime = AMS_ALS_ATIME; /*ALS Inegration time 50msec*/

	ctx->alwaysReadAls = false;
	ctx->alwaysReadFlicker = false;
	ctx->ccbAlsCtx.initData.autoGain = true; //AutoGainCtrol on
	ctx->ccbAlsCtx.initData.hysteresis = 0x02; /*Lower threshold for adata in AGC */
	return ret;
}

static bool ams_deviceGetAls(ams_deviceCtx_t *ctx, ams_apiAls_t *exportData)
{
	ams_ccb_als_result_t result;

	ccb_alsGetResult(ctx, &result);
	exportData->clear = result.clear;
	exportData->ir = result.ir;
	exportData->time_us = result.time_us;
	exportData->ClearGain = result.ClearGain;
	exportData->WBGain = result.WBGain;
	exportData->BKGain = result.BKGain;
	exportData->UVGain = result.UVGain;
	exportData->wideband    = result.wideband;
	exportData->rawClear = result.rawClear;
	exportData->rawWideband = result.rawWideband;
	exportData->rawBK = result.rawBK;
	exportData->rawUv = result.rawUv;
	exportData->subtracted_rawUv = result.subtracted_rawUv;
	return false;
}

static int _2511_handleAlsEvent(ams_deviceCtx_t *ctx)
{
	int ret = 0;
	ams_ccb_als_dataSet_t ccbAlsData;

	ccbAlsData.statusReg = ctx->shadowStatus1Reg;
	ccbAlsData.status2Reg = ctx->shadowStatus2Reg;
	ccbAlsData.alsstatusReg = ctx->shadowAlsStatusReg;
	ccbAlsData.alsstatus2Reg = ctx->shadowAlsStatus2Reg;

	//ret = ccb_alsHandle(ctx, &ccbAlsData);

	return ret;
}

static bool ams_deviceGetFlicker(ams_deviceCtx_t *ctx, ams_apiAlsFlicker_t *exportData)
{
	ams_flicker_ctx_t *flickerCtx = (ams_flicker_ctx_t *)&ctx->flickerCtx;

	exportData->mHz = flickerCtx->frequency;
	return false;
}

static int ams_deviceSoftReset(ams_deviceCtx_t *ctx)
{
	int err = 0;

	ALS_dbg("%s - Start\n", __func__);

	// Before S/W reset, the PON has to be asserted
	err = ams_setByte(ctx->portHndl, DEVREG_ENABLE, PON);
	if (err < 0) {
		ALS_err("%s - failed to set DEVREG_ENABLE\n", __func__);
		return err;
	}

	err = ams_setField(ctx->portHndl, DEVREG_CONTROL, HIGH, MASK_SOFT_RESET);
	if (err < 0) {
		ALS_err("%s - failed to set DEVREG_SOFT_RESET\n", __func__);
		return err;
	}
	// Need 1 msec delay
	usleep_range(1000, 1100);

	// Recover the previous enable setting
	err = ams_setByte(ctx->portHndl, DEVREG_ENABLE, ctx->shadowEnableReg);
	if (err < 0) {
		ALS_err("%s - failed to set DEVREG_ENABLE\n", __func__);
		return err;
	}

	return err;
}

static int ams_als_trim_data(ams_deviceCtx_t *ctx)
{
	uint8_t trim;

	/* read ir trim value */
	ams_getByte(ctx->portHndl, DEVREG_IR_CALIB, &trim);
	/* bit 7 value 0 means trim valid */
	if (!(trim & (1<<TSL2511_REG_IR_CALIB__ir_calib_valid__SHIFT))) {
		ctx->ir_calib_val = trim & 0x7F;
		ctx->ir_calib_val_valid = true;
	} else {
		/*  bit 7 value 1 means untrimmed */
		ctx->ir_calib_val_valid = false;
	}

	if (ctx->ir_calib_val_valid) {
		/* means bk is also trimmed */
		ams_getByte(ctx->portHndl, DEVREG_BK_CALIB, &trim);
		ctx->bk_calib_val = trim & 0xFF;
	}

	/* read uva trim value */
	ams_getByte(ctx->portHndl, DEVREG_UV_CALIB, &trim);
	/* bit 7 value 0 means trim valid */
	if (!(trim & (1<<TSL2511_REG_UV_CALIB__uv_calib_valid__SHIFT))) {
		ctx->uva_calib_val = trim & 0x7F;
		ctx->uva_calib_val_valid = true;
	} else {
		/* bit 7 value 1 means untrimmed */
		ctx->uva_calib_val_valid = false;
	}
	return 0;
}


static ams_deviceIdentifier_e ams_validateDevice(AMS_PORT_portHndl *portHndl)
{
	uint8_t chipId;
	uint8_t revId;
	uint8_t auxId = 0;
	uint8_t i = 0;
	int err = 0;

	struct tsl2511_device_data *data = i2c_get_clientdata(portHndl);

	err = ams_getByte(portHndl, DEVREG_ID, &chipId);
	if (err < 0) {
		ALS_err("%s - failed to get DEVREG_ID\n", __func__);
		return AMS_UNKNOWN_DEVICE;
	}
	err = ams_getByte(portHndl, DEVREG_REVID, &revId);
	if (err < 0) {
		ALS_err("%s - failed to get DEVREG_REVID\n", __func__);
		return AMS_UNKNOWN_DEVICE;
	}
	err = ams_getByte(portHndl, DEVREG_AUXID, &auxId);
	if (err < 0) {
		ALS_err("%s - failed to get DEVREG_AUXID\n", __func__);
		return AMS_UNKNOWN_DEVICE;
	}
	ALS_dbg("%s - ID:0x%02x, revID:0x%02x, auxID:0x%02x\n", __func__, chipId, revId, auxId);

	if ((revId & 0x12) == 0x12)
		data->isTrimmed = 1;
	else
		data->isTrimmed = 0;

	do {
		if (((chipId & deviceIdentifier[i].deviceIdMask) ==
				(deviceIdentifier[i].deviceId & deviceIdentifier[i].deviceIdMask)) &&
				((revId & deviceIdentifier[i].deviceRefMask) ==
				 (deviceIdentifier[i].deviceRef & deviceIdentifier[i].deviceRefMask))) {

			return deviceIdentifier[i].device;
		}
		i++;
	} while (deviceIdentifier[i].device != AMS_LAST_DEVICE);

	return AMS_UNKNOWN_DEVICE;
}


static int ams_deviceInit(ams_deviceCtx_t *ctx, AMS_PORT_portHndl *portHndl, ams_calibrationData_t *calibrationData, bool osc_cal)
{
	struct tsl2511_device_data *data = i2c_get_clientdata(portHndl);

	int ret = 0;
	u16 vsync_period = 0;


	ctx->portHndl = portHndl;
	ctx->mode = MODE_OFF;
	ctx->systemCalibrationData = calibrationData;
	ctx->deviceId = ams_validateDevice(ctx->portHndl);
	ctx->shadowEnableReg = deviceRegisterDefinition[DEVREG_ENABLE].resetValue;
	ctx->agc = true;
	ctx->internal_clock_once = false;
	ctx->sum_bk_bkCal_offset = data->sum_bk_bkCal_offset;
	ctx->sum_bk_bkCal_kcoef = data->sum_bk_bkCal_kcoef;
	kfifo_reset(&ams_fifo);
	ALS_info("%s sum_bk_bkCal_offset %d\n", __func__,data->sum_bk_bkCal_offset);

	ret = ams_deviceSoftReset(ctx);
	if (ret < 0) {
		ALS_err("%s - failed to ams_deviceSoftReset\n", __func__);
		return ret;
	}

	/*EXT_CLK select*/
	ret = ams_setByte(ctx->portHndl, DEVREG_ENABLE, PON);
	if (ret < 0) {
		ALS_err("%s - failed to set DEVREG_ENABLE\n", __func__);
		return ret;
	}

	ret = ams_setByte(ctx->portHndl, DEVREG_OSCEN, 0x01); // force osc on
	if (ret < 0) {
		ALS_err("%s - failed to set DEVREG_OSCEN\n", __func__);
		return ret;
	}
	ams_setByte(portHndl, DEVREG_CFG7, MOD_DIV_SEL_0); // 1/6 = 1600khz mod clock
	ams_setByte(portHndl, DEVREG_VSYNC_GPIO_INT, 0x20); // INT_IN_EN = 1
	ams_setByte(portHndl, DEVREG_VSYNC_PERIOD_TARGET_L, 0x33);
	ams_setByte(portHndl, DEVREG_VSYNC_PERIOD_TARGET_H, 0xAB);
	//if sync_mode ==3
	ams_setByte(portHndl,DEVREG_VSYNC_CFG, 0x76);//ext_clk auto run after pon + ext_clk_mode + div(8192) + SYNC/INT pin used EXT_CLK

	/* set interrupt as per step */
	ams_setByte(portHndl, DEVREG_CFG4, TSL2511_REG_CFG4__sint_per_step__MASK);

	usleep_range(1000, 1100);
	/********get trimm for uv , ir , bk****************/
	ams_als_trim_data(ctx);

	/*AMS_SET_SAMPLE_TIME(AMS_SAMPLING_TIME, ret);
	if (ret < 0) {
		ALS_err("%s - failed to Sample time \n", __func__);
		return ret;
	}*/

	tsl2511_set_sampling_time( data,AMS_SAMPLING_TIME);

#if defined(CONFIG_AMS_OPTICAL_SENSOR_ALS_CCB)
	ret = _2511_alsInit(ctx, calibrationData);
	if (ret < 0) {
		ALS_err("%s - failed to _2511_alsInit\n", __func__);
		return ret;
	}
#endif

	return ret;
}

static bool ams_getDeviceInfo(ams_deviceInfo_t *info, ams_deviceIdentifier_e deviceId)
{
	memset(info, 0, sizeof(ams_deviceInfo_t));

	info->defaultCalibrationData.timeBase_us = AMS_USEC_PER_TICK;
	info->numberOfSubSensors = 0;
	info->memorySize = sizeof(ams_deviceCtx_t);

	switch (deviceId) {
		case AMS_TSL2511:
			info->deviceModel = "TSL2511";
			break;
		default:
			info->deviceModel = "UNKNOWN";
			break;
	}

	memcpy(info->defaultCalibrationData.deviceName, info->deviceModel, sizeof(info->defaultCalibrationData.deviceName));
	info->deviceName = "ALS/FLKR";
	info->driverVersion = "Alpha";
#if defined(CONFIG_AMS_OPTICAL_SENSOR_ALS_CCB)
	{
		/* TODO */
		ams_ccb_als_info_t infoData;

		ccb_alsInfo(&infoData);
		info->tableSubSensors[info->numberOfSubSensors] = AMS_AMBIENT_SENSOR;
		info->numberOfSubSensors++;

		info->alsSensor.driverName = infoData.algName;
		info->alsSensor.adcBits = 8;
		info->alsSensor.maxPolRate = 50;
		info->alsSensor.activeCurrent_uA = 100;
		info->alsSensor.standbyCurrent_uA = 5;
		info->alsSensor.rangeMax = 1;
		info->alsSensor.rangeMin = 0;

		info->defaultCalibrationData.alsCalibrationFactor = infoData.defaultCalibrationData.calibrationFactor;
		//		info->defaultCalibrationData.alsCalibrationLuxTarget = infoData.defaultCalibrationData.luxTarget;
		//		info->defaultCalibrationData.alsCalibrationLuxTargetError = infoData.defaultCalibrationData.luxTargetError;
#if defined(CONFIG_AMS_ALS_CRWBI) || defined(CONFIG_AMS_ALS_CRGBW)
		info->tableSubSensors[info->numberOfSubSensors] = AMS_WIDEBAND_ALS_SENSOR;
		info->numberOfSubSensors++;
#endif
	}
#endif
	return false;
}


static void fifo_work_cb(struct work_struct *work)
{
	struct fifo_chip *fifo = NULL;

	if (work) {
		fifo = container_of(work, struct fifo_chip, work);
	}
}

static int tsl2511_init_fifo(struct tsl2511_device_data *data)
{
	static struct fifo_chip fifo;

	memset(&fifo, 0, sizeof(struct fifo_chip));

	//fifo.callbacks.irq = fifo_irq;
	//data->fifo = &fifo.work;
	fifo.data = data;
	init_waitqueue_head(&data->fifo_wait);
	//if (init_fifo_device_tree(chip)) {
	//fifo_reset(chip);
	INIT_WORK(&fifo.work, fifo_work_cb);
	INIT_KFIFO(ams_fifo);
	//enable_fifo(chip, FIFO_OFF);
	//if (sysfs_create_groups(&chip->input->dev.kobj, fifo_groups)) {
	//	dev_err(&chip->input->dev, "Error creating sysfs attribute group.\n");
	//}
	//}
	return 0;
}

int tsl2511_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
	int err = -ENODEV;
	struct device *dev = &client->dev;
	static struct tsl2511_device_data *data;
	struct amsdriver_i2c_platform_data *pdata = dev->platform_data;
	ams_deviceInfo_t amsDeviceInfo;
	ams_deviceIdentifier_e deviceId;

	als_eol_set_err_handler(tsl2511_print_reg_status);

	ALS_dbg("%s - start\n", __func__);
	printk(KERN_ERR "\nams_tsl2511: tsl2511_probe() client->irq= %d\n", client->irq);

	/* check to make sure that the adapter supports I2C */
	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
		ALS_err("%s - I2C_FUNC_I2C not supported\n", __func__);
		return -ENODEV;
	}
	/* allocate some memory for the device */
	data = devm_kzalloc(dev, sizeof(struct tsl2511_device_data), GFP_KERNEL);
	if (data == NULL) {
		ALS_err("%s - couldn't allocate device data memory\n", __func__);
		return -ENOMEM;
	}

	data->flicker_data = devm_kzalloc(dev, sizeof(int16_t)*AMS_FFT_SIZE, GFP_KERNEL);
	if (data == NULL) {
		ALS_err("%s - couldn't allocate device flicker_data memory\n", __func__);
		return -ENOMEM;
	}

	tsl2511_data = data;
	tsl2511_init_var(data);

	if (!pdata) {
		pdata = devm_kzalloc(dev, sizeof(struct amsdriver_i2c_platform_data),
				GFP_KERNEL);
		if (pdata == NULL) {
			ALS_err("%s - couldn't allocate device pdata memory\n", __func__);
			goto err_malloc_pdata;
		}
#if IS_ENABLED(CONFIG_OF)
		if (of_match_device(tsl2511_match_table, &client->dev))
			pdata->of_node = client->dev.of_node;
#endif
	}

	data->client = client;
	data->miscdev.minor = MISC_DYNAMIC_MINOR;
	data->miscdev.name = MODULE_NAME_ALS;
	data->miscdev.fops = &tsl2511_fops;
	data->miscdev.mode = S_IRUGO;
	data->pdata = pdata;
	i2c_set_clientdata(client, data);
	ALS_info("%s client = %p\n", __func__, client);

	err = misc_register(&data->miscdev);
	if (err < 0) {
		ALS_err("%s - failed to misc device register\n", __func__);
		goto err_misc_register;
	}
	mutex_init(&data->i2clock);
	mutex_init(&data->activelock);
	mutex_init(&data->suspendlock);
	mutex_init(&data->flickerdatalock);

	err = tsl2511_parse_dt(data);
	if (err < 0) {
		ALS_err("%s - failed to parse dt\n", __func__);
		err = -ENODEV;
		goto err_parse_dt;
	}

	err = tsl2511_power_ctrl(data, PWR_ON);
	if (err < 0) {
		ALS_err("%s - failed to power on ctrl\n", __func__);
		goto err_power_on;
	}
	if (data->client->addr == TSL2511_SLAVE_I2C_ADDR_REVID_V0) {
		ALS_dbg("%s - slave address is REVID_V0\n", __func__);
	}
	else {
		err = -EIO;
		ALS_err("%s - slave address error, 0x%02x\n", __func__, data->client->addr);
		goto err_init_fail;
	}

	/********************************************************************/
	/* Validate the appropriate ams device is available for this driver */
	/********************************************************************/
	deviceId = ams_validateDevice(data->client);

	if (deviceId == AMS_UNKNOWN_DEVICE) {
		ALS_err("%s - ams_validateDevice failed: AMS_UNKNOWN_DEVICE\n", __func__);
		err = -EIO;
		goto err_id_failed;
	}
	ALS_dbg("%s - deviceId: %d\n", __func__, deviceId);

	ams_getDeviceInfo(&amsDeviceInfo, deviceId);
	ALS_dbg("%s - name: %s, model: %s, driver ver:%s\n", __func__,
			amsDeviceInfo.deviceName, amsDeviceInfo.deviceModel, amsDeviceInfo.driverVersion);

	data->deviceCtx = devm_kzalloc(dev, amsDeviceInfo.memorySize, GFP_KERNEL);
	if (data->deviceCtx == NULL) {
		ALS_err("%s - couldn't allocate device deviceCtx memory\n", __func__);
		err = -ENOMEM;
		goto err_malloc_deviceCtx;
	}

	data->sensor_mode = 0;
	data->sum_bk_bkCal_offset = 5;
	data->sum_bk_bkCal_kcoef = 0;

	err = ams_deviceInit(data->deviceCtx, data->client, NULL,true);
	if (err < 0) {
		ALS_err("%s - ams_deviceInit failed.\n", __func__);
		goto err_id_failed;
	}
	else {
		ALS_dbg("%s - ams_deviceInit ok\n", __func__);
	}

	/*
	 * S-MUX Read/Write
	 * 1  read configuration to ram Read smux configuration to RAM from smux chain
	 * 2  write configuration from ram Write smux configuration from RAM to smux chain
	 */
		//ams_smux_set(data->deviceCtx);




	data->als_input_dev = input_allocate_device();
	if (!data->als_input_dev) {
		ALS_err("%s - could not allocate input device\n", __func__);
		err = -EIO;
		goto err_input_allocate_device;
	}
	data->als_input_dev->name = MODULE_NAME_ALS;
	data->als_input_dev->id.bustype = BUS_I2C;
	input_set_drvdata(data->als_input_dev, data);
	input_set_capability(data->als_input_dev, EV_REL, REL_X);
	input_set_capability(data->als_input_dev, EV_REL, REL_Y);
	input_set_capability(data->als_input_dev, EV_REL, REL_Z);
	input_set_capability(data->als_input_dev, EV_REL, REL_RX);
	input_set_capability(data->als_input_dev, EV_REL, REL_RY);
	input_set_capability(data->als_input_dev, EV_REL, REL_RZ);
	input_set_capability(data->als_input_dev, EV_REL, REL_MISC);
	input_set_capability(data->als_input_dev, EV_ABS, ABS_X);
	input_set_capability(data->als_input_dev, EV_ABS, ABS_Y);
	input_set_capability(data->als_input_dev, EV_ABS, ABS_Z);

	err = input_register_device(data->als_input_dev);
	if (err < 0) {
		input_free_device(data->als_input_dev);
		ALS_err("%s - could not register input device\n", __func__);
		goto err_input_register_device;
	}

#if IS_ENABLED(CONFIG_ARCH_EXYNOS)
	err = sensors_create_symlink(data->als_input_dev);
#else
	err = sensors_create_symlink(&data->als_input_dev->dev.kobj, data->als_input_dev->name);
#endif
	if (err < 0) {
		ALS_err("%s - could not create_symlink\n", __func__);
		goto err_sensors_create_symlink;
	}

	err = sysfs_create_group(&data->als_input_dev->dev.kobj, &als_attribute_group);
	if (err) {
		ALS_err("%s - could not create sysfs group\n", __func__);
		goto err_sysfs_create_group;
	}
	err = sensors_register(&data->sensor_dev, data, tsl2511_sensor_attrs, MODULE_NAME_ALS);
	if (err) {
		ALS_err("%s - cound not register als_sensor(%d).\n", __func__, err);
		goto als_sensor_register_failed;
	}

	//err = tsl2511_setup_irq(data);
	//if (err) {
	//	ALS_err("%s - could not setup dev_irq\n", __func__);
	//	goto err_setup_irq;
	//}

#if defined(CONFIG_AMS_OPTICAL_SENSOR_POLLING)
	data->wq = create_singlethread_workqueue("tsl2511_wq");
	if (data->wq) {
		INIT_WORK(&data->work_light, tsl2511_work_func_light);
		hrtimer_init(&data->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
		//flikcer detection support polling for tsl2511 ,

		//data->light_poll_delay = ns_to_ktime(64 * NSEC_PER_MSEC);  //60 msec Polling time
		//data->light_poll_delay = ns_to_ktime(32 * NSEC_PER_MSEC);  //20 msec Polling time
		data->light_poll_delay = ns_to_ktime(10 * NSEC_PER_MSEC);
		data->timer.function = tsl2511_timer_func;
		data->timer_is_exist = true;
		ALS_dbg("%s - workqueue created and set light_poll_delay as %d\n", __func__, data->light_poll_delay);
	} else {
		data->timer_is_exist = false;
		//ret = -ENOMEM;
		ALS_err("%s: could not create workqueue\n", __func__);
		// HAVE TO GO TO ERROR CASED
		//goto init_failed;
	}
#endif  //CONFIG_AMS_OPTICAL_SENSOR_POLLING


	err = tsl2511_init_fifo(data);

	if (err) {
		ALS_err("%s - error tsl2511_init_fifo\n", __func__);
	}

	//tsl2511_irq_set_state(data, PWR_ON); /* For flushing interrupt request */
	err = tsl2511_power_ctrl(data, PWR_OFF);
	if (err < 0) {
		ALS_err("%s - failed to power off ctrl\n", __func__);
		goto dev_set_drvdata_failed;
	}

	//tsl2511_irq_set_state(data, PWR_OFF);
	ALS_dbg("%s - success\n", __func__);
	goto done;

dev_set_drvdata_failed:
	//free_irq(data->dev_irq, data);
err_setup_irq:
	sensors_unregister(data->sensor_dev, tsl2511_sensor_attrs);
als_sensor_register_failed:
	sysfs_remove_group(&data->als_input_dev->dev.kobj,
			&als_attribute_group);
err_sysfs_create_group:
#if IS_ENABLED(CONFIG_ARCH_EXYNOS)
	sensors_remove_symlink(data->als_input_dev);
#else
	sensors_remove_symlink(&data->als_input_dev->dev.kobj, data->als_input_dev->name);
#endif
err_sensors_create_symlink:
	input_unregister_device(data->als_input_dev);
err_input_register_device:
err_input_allocate_device:
err_id_failed:
	//	devm_kfree(data->deviceCtx);
err_malloc_deviceCtx:
err_init_fail:
	tsl2511_power_ctrl(data, PWR_OFF);
err_power_on:
err_setup_gpio:
err_parse_dt:
	if (data->regulator_vbus_1p8) {
		if (data->vbus_1p8_enable) {
			regulator_disable(data->regulator_vbus_1p8);
		}
		ALS_dbg("%s - put vbus_1p8 regulator = %p done (en = %d)\n", __func__, data->regulator_vbus_1p8, data->vbus_1p8_enable);
		regulator_put(data->regulator_vbus_1p8);
		data->regulator_vbus_1p8 = NULL;
	}

	if (data->regulator_vdd_1p8) {
		if (data->vdd_1p8_enable) {
			regulator_disable(data->regulator_vdd_1p8);
		}
		ALS_dbg("%s - put vdd_1p8 regulator = %p done (en = %d)\n", __func__, data->regulator_vdd_1p8, data->vdd_1p8_enable);
		regulator_put(data->regulator_vdd_1p8);
		data->regulator_vdd_1p8 = NULL;
	}
	//	devm_kfree(pdata);
err_malloc_pdata:

	if (data->als_pinctrl) {
		devm_pinctrl_put(data->als_pinctrl);
		data->als_pinctrl = NULL;
	}
	if (data->pins_active)
		data->pins_active = NULL;
	if (data->pins_sleep)
		data->pins_sleep = NULL;

	mutex_destroy(&data->i2clock);
	mutex_destroy(&data->activelock);
	mutex_destroy(&data->suspendlock);
	mutex_destroy(&data->flickerdatalock);
	misc_deregister(&data->miscdev);
err_misc_register:
	//	devm_kfree(data);
	ALS_err("%s failed\n", __func__);
done:
	return err;
}

#if KERNEL_VERSION(6,1,0) <= LINUX_VERSION_CODE
void tsl2511_remove(struct i2c_client *client)
#else
int tsl2511_remove(struct i2c_client *client)
#endif
{
	struct tsl2511_device_data *data = i2c_get_clientdata(client);
	//struct fifo_chip *fifo;
	ALS_dbg("%s - start\n", __func__);
	tsl2511_power_ctrl(data, PWR_OFF);
	if (data->regulator_vbus_1p8) {
		if (data->vbus_1p8_enable) {
			regulator_disable(data->regulator_vbus_1p8);
		}
		ALS_dbg("%s - put vbus_1p8 regulator = %p done (en = %d)\n", __func__, data->regulator_vbus_1p8, data->vbus_1p8_enable);
		regulator_put(data->regulator_vbus_1p8);
		data->regulator_vbus_1p8 = NULL;
	}

	if (data->regulator_vdd_1p8) {
		if (data->vdd_1p8_enable) {
			regulator_disable(data->regulator_vdd_1p8);
		}
		ALS_dbg("%s - put vdd_1p8 regulator = %p done (en = %d)\n", __func__, data->regulator_vdd_1p8, data->vdd_1p8_enable);
		regulator_put(data->regulator_vdd_1p8);
		data->regulator_vdd_1p8 = NULL;
	}

	sensors_unregister(data->sensor_dev, tsl2511_sensor_attrs);
	sysfs_remove_group(&data->als_input_dev->dev.kobj, &als_attribute_group);
#if IS_ENABLED(CONFIG_ARCH_EXYNOS)
	sensors_remove_symlink(data->als_input_dev);
#else
	sensors_remove_symlink(&data->als_input_dev->dev.kobj, data->als_input_dev->name);
#endif
	input_unregister_device(data->als_input_dev);

	if (data->als_pinctrl) {
		devm_pinctrl_put(data->als_pinctrl);
		data->als_pinctrl = NULL;
	}
	if (data->pins_active)
		data->pins_active = NULL;
	if (data->pins_sleep)
		data->pins_sleep = NULL;

	if(data->timer_is_exist) {
		hrtimer_cancel(&data->timer);
	}

	if (data->wq) {
		cancel_work_sync(&data->work_light);
		destroy_workqueue(data->wq);
	}

	//disable_irq(data->dev_irq);
	//free_irq(data->dev_irq, data);
	mutex_destroy(&data->i2clock);
	mutex_destroy(&data->activelock);
	mutex_destroy(&data->suspendlock);
	mutex_destroy(&data->flickerdatalock);
	misc_deregister(&data->miscdev);

	//	devm_kfree(data->deviceCtx);
	//	devm_kfree(data->pdata);
	//	devm_kfree(data);
	i2c_set_clientdata(client, NULL);


	//fifo = &data->fifo;
	//cancel_work_sync(&fifo->work);

	data = NULL;
#if KERNEL_VERSION(6,1,0) <= LINUX_VERSION_CODE
	return;
#else
	return 0;
#endif
}

static void tsl2511_shutdown(struct i2c_client *client)
{
	ALS_dbg("%s - start\n", __func__);
}

void tsl2511_pin_control(struct tsl2511_device_data *data, bool pin_set)
{
	int status = 0;

	if (!data->als_pinctrl) {
		ALS_dbg("%s - als_pinctrl is null\n", __func__);
		return;
	}

	if (pin_set) {
		if (!IS_ERR_OR_NULL(data->pins_active)) {
			status = pinctrl_select_state(data->als_pinctrl, data->pins_active);
			if (status) {
				ALS_err("%s - can't set pin active state\n", __func__);
			} else {
				ALS_dbg("%s - active\n", __func__);
			}
		} else {
			ALS_err("%s - pins_active is null\n", __func__);
		}
	} else {
		if (!IS_ERR_OR_NULL(data->pins_sleep)) {
			status = pinctrl_select_state(data->als_pinctrl, data->pins_sleep);
			if (status) {
				ALS_err("%s - can't set pin sleep state\n", __func__);
			} else {
				ALS_dbg("%s - sleep\n", __func__);
			}
		} else {
			ALS_err("%s - pins_sleep is null\n", __func__);
		}
	}
}

#if IS_ENABLED(CONFIG_PM)
static int tsl2511_suspend(struct device *dev)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	int err = 0, cnt = 0;

	ALS_dbg("%s - %d\n", __func__, data->regulator_state);

	if (data->enabled != 0 ) {
#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
		if (data->regulator_state == 0)
			tsl2511_power_ctrl(data, PWR_ON);
#endif
		do {
			err = tsl2511_stop(data);

			if (err < 0) {
				break;
			}
			data->suspend_cnt++;
			cnt++;
		} while (data->enabled && cnt < 5);
		data->enabled = 1;
	} else if (data->regulator_state != 0) {
		ALS_dbg("%s - abnormal state! als not enabled", __func__);
		do {
			err = tsl2511_stop(data);

			if (err < 0) {
				break;
			}
		} while (data->regulator_state != 0);
	}

	mutex_lock(&data->suspendlock);

	data->pm_state = PM_SUSPEND;
	tsl2511_pin_control(data, false);

	mutex_unlock(&data->suspendlock);

	return err;
}

static int tsl2511_resume(struct device *dev)
{
	struct tsl2511_device_data *data = dev_get_drvdata(dev);
	int err = 0;

	ALS_dbg("%s - %d\n", __func__, data->suspend_cnt);

	mutex_lock(&data->suspendlock);

	tsl2511_pin_control(data, true);

	data->pm_state = PM_RESUME;

	mutex_unlock(&data->suspendlock);

#if defined(CONFIG_AMS_ALS_COMPENSATION_FOR_AUTO_BRIGHTNESS)
	if (data->als_flag)
		tsl2511_als_start(data);
#endif

	if (data->enabled != 0) {
		do {
			tsl2511_start(data);
			data->suspend_cnt--;
		} while(data->suspend_cnt > 0);
	}
	return err;
}

static const struct dev_pm_ops tsl2511_pm_ops = {
	.suspend = tsl2511_suspend,
	.resume = tsl2511_resume
};
#endif

static const struct i2c_device_id tsl2511_idtable[] = {
	{ "tsl2511", 0 },
	{ }
};
/* descriptor of the tsl2511 I2C driver */
static struct i2c_driver tsl2511_driver = {
	.driver = {
		.name = "tsl2511",
		.owner = THIS_MODULE,
#if IS_ENABLED(CONFIG_PM)
		.pm = &tsl2511_pm_ops,
#endif
		.of_match_table = tsl2511_match_table,
	},
	.probe = tsl2511_probe,
	.remove = tsl2511_remove,
	.shutdown = tsl2511_shutdown,
	.id_table = tsl2511_idtable,
};

/* initialization and exit functions */
static int __init tsl2511_init(void)
{
	int rc = i2c_add_driver(&tsl2511_driver);
	return rc;
}

static void __exit tsl2511_exit(void)
{
	i2c_del_driver(&tsl2511_driver);
}

module_init(tsl2511_init);
module_exit(tsl2511_exit);

MODULE_SOFTDEP("pre: sensors_core");
MODULE_AUTHOR("Samsung Electronics");
MODULE_DESCRIPTION("TSL2511 ALS Driver");
MODULE_LICENSE("GPL");
